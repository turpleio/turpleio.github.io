<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3">
<meta httpequiv="x-ua-compatible" content="ie=edge">
<meta property="og:type" content="website">
<meta name="author" content="turpleio">
<meta name="generator" content="Docusaurus v2.0.0-alpha.75">
<link href="https://www.googletagmanager.com" rel="dns-prefetch">
<link href="https://www.google-analytics.com" rel="dns-prefetch">
<link rel="icon" href="/favicon.png">
<link rel="apple-touch-icon" href="/img/icons/apple-180x180.png" sizes="180x180">
<meta name="msapplication-config" content="/browserconfig.xml">
<link rel="sitemap" type="application/xml" href="/sitemap.xml">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=GTM-PVR7M2G"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","GTM-PVR7M2G",{anonymize_ip:!0})</script>
<link rel="search" type="application/opensearchdescription+xml" title="Turple: Cloud Native Platform" href="/opensearch.xml">
<link rel="manifest" href="/manifest.webmanifest">
<meta name="theme-color" content="#d14671">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#21222c">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Turple: Cloud Native Platform Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Turple: Cloud Native Platform Blog Atom Feed"><title data-react-helmet="true">QuestDB 6.6.1 - Dynamic Commits | Turple: Cloud Native Platform</title><meta data-react-helmet="true" property="og:title" content="QuestDB 6.6.1 - Dynamic Commits | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="description" content="The detailed story of how QuestDB 6.6.1 increases data freshness"><meta data-react-helmet="true" name="twitter:description" content="The detailed story of how QuestDB 6.6.1 increases data freshness"><meta data-react-helmet="true" property="og:description" content="The detailed story of how QuestDB 6.6.1 increases data freshness"><meta data-react-helmet="true" name="twitter:title" content="QuestDB 6.6.1 - Dynamic Commits | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="twitter:image:alt" content="Image for &quot;QuestDB 6.6.1 - Dynamic Commits | Turple: Cloud Native Platform&quot;"><meta data-react-helmet="true" name="keywords" content="engineering,community,timeseries,datafreshness,database,open source"><meta data-react-helmet="true" property="og:image" content="https://turpleio.github.io/img/blog/2022-11-25/banner.png"><meta data-react-helmet="true" name="twitter:image" content="https://turpleio.github.io/img/blog/2022-11-25/banner.png"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><link rel="stylesheet" href="/assets/css/styles.4f6557e4.css">
</head>
<body itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="Turple: Cloud Native Platform">
<meta itemprop="description" content="Turple is a cloud native platform which can help you build and operate your services on cloud.">
<meta itemprop="url" content="https://turpleio.github.io">
<meta itemprop="logo" content="https://turpleio.github.io/img/favicon.png">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<nav class="navbar navbar_wBc8 navbar--light"><div class="navbar__inner inner_Y8Z6"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand brand_AtiA" href="/">QuestDB</a></div><div class="navbar__items navbar__items--right"></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand brand_AtiA" href="/">QuestDB</a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"></ul></div></div></div></nav><div class="wrapper_DIJ0 blog-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--3"><div class="sidebar_q+wC thin-scrollbar"><h3 class="sidebarItemTitle_9G5K">Recent posts</h3><ul class="sidebarItemList_6T4b"><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/19/merry-questmas-gifts-2023">Merry Questmas! Here are your gifts for 2023...</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/13/using-prometheus-loki-grafana-monitor-questdb-kubernetes">Using Prometheus, Loki, and Grafana to monitor QuestDB in Kubernetes</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/30/full-table-scan-are-fast">Listen to Your CPU - Full-table Scans Are Fast</a></li><li class="sidebarItem_cjdF"><a aria-current="page" class="sidebarItemLink_zyXk sidebarItemLinkActive_wcJs" href="/blog/2022/11/25/questdb-6.6.1-dynamic-commits">QuestDB 6.6.1 - Dynamic Commits</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/23/sql-extensions-time-series-data-questdb-part-ii">SQL Extensions for Time Series Data in QuestDB - Part II</a></li></ul></div></div><main class="col col--7"><article><header><h1 class="title_KBQu">QuestDB 6.6.1 - Dynamic Commits</h1><time datetime="2022-11-25T00:00:00.000Z" class="date_A31P">November 25, 2022 · 5 min read</time><div class="avatar margin-vert--md"><a href="https://github.com/bluestreak01" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars.githubusercontent.com/bluestreak01" alt="Vlad Ilyushchenko"></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/bluestreak01" target="_blank" rel="noopener noreferrer">Vlad Ilyushchenko</a></h4><small class="avatar__subtitle">QuestDB Team</small></div></div></header><div class="markdown"><figure><img alt="QuestDB 6.6.1 release highlights" class="image_1-Fc" height="467" src="/img/blog/2022-11-25/banner.png" width="650"></figure><p>We are excited to announce the release of
<a href="https://github.com/questdb/questdb/releases/tag/6.6.1" target="_blank" rel="noopener noreferrer">QuestDB 6.6.1</a>, which
brings dynamic commits to optimize ingestion throughput and data freshness for
reads. In this blog post, our CTO, Vlad, shares the story driving the creation
of the dynamic commits.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="questdbs-data-structure-and-out-of-order-data-ingestion"></a>QuestDB&#x27;s data structure and out-of-order data ingestion<a class="hash-link" href="#questdbs-data-structure-and-out-of-order-data-ingestion" title="Direct link to heading">#</a></h2><p>Many storage systems adopt a Log-Structured Merge tree at their core. QuestDB
differs from them, and the ingested data will always be ordered by timestamp
once it is committed to disk. QuestDB 6.0 enabled
<a href="/blog/2021/05/10/questdb-release-6-0-tsbs-benchmark/">out-of-order ingestion</a>,
for which we introduced a <a href="/docs/guides/out-of-order-commit-lag/">commit lag</a> to
optimize ingestion throughput for unordered data. The commit lag includes a
time-based buffer and delays the data commit. This way, out-of-order data can be
re-ordered on the fly in memory. QuestDB&#x27;s in-memory reordering is particularly
efficient, and avoids heavy copy-on-merge operations, which would be needed
otherwise.</p><p>As such, we have an implicit trade-off between the ingestion throughput of
unordered data and the availability of data for reads. A higher buffer implies a
longer time delay for the data to be available for reads, while a short buffer
might affect disk write throughput, as we need to reshuffle already committed
out-of-order data.</p><p>To recap, when treating the incoming data, the commit lag ensures:</p><ul><li>Data is sorted chronologically.</li><li>New data is merged with the existing one.</li><li>A consistent view of the existing data is maintained for concurrent reads.</li></ul><p><img src="/assets/images/commit_lag-6f98392ba73df62e9123a813795cd08a.png"></p><p>For QuestDB 6.5.5 and earlier versions, users needed to understand the &quot;shape&quot;
of their data to adjust the commit lag value, either through server
configuration or query settings.</p><p>A misconfigured commit lag would lead to user pain and frustration: some of our
users would expect data to be available for reads immediately, but the default
configuration was out of whack. For heavy out-of-order ingestion patterns, the
default commit lag would lead to too many copy-on-merge operations and
significantly slow down the database. And this was where the story started.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="community-driven-development"></a>Community-driven development<a class="hash-link" href="#community-driven-development" title="Direct link to heading">#</a></h2><p>A couple of weeks ago, I was working on a massive WAL (Write Ahead Log) PR, when
Nic, our CEO, sent me a thread of messages:</p><p><em><strong>Nic:</strong> FYI I asked Javier and Imre to connect and look at this commit lag
together. Our default settings are not good enough…Someone in the community just
asked me if the best we can do is ingestion with a 5-minute delay. These default
settings give the wrong impression that we cannot process data in real time.
Let&#x27;s brainstorm.</em></p><p><em><strong>Me:</strong> They can reduce the commit lag, why would not they do that? They can
set it to 0?</em></p><p><em><strong>Nic:</strong> They don&#x27;t know that the commit lag is configurable, and this leaves a
bad impression on new users.</em></p><p>This feedback was too important to ignore, so I caught up with our Core
Engineer, Imre Aranyosi, and DevRel, Javier Ramirez. It turned out that Javier
had produced a demo project in Go, sending data to QuestDB Cloud in small
batches - approximately 10k rows every 50 ms. When querying data from this
project, Javier could not see new data immediately. Similarly, data visibility
is one of the most frequently asked questions on QuestDB Slack as well as on
Stackoverflow. To our users, it wasn&#x27;t clear which configuration parameters to
set and where to show this data, either. We had to investigate this problem
further.</p><p>Imre and I began exploring and we soon realized that it was due to the commit
lag setting that data were not readily available. To increase data freshness, we
had to commit more often and decouple the commit frequency from the commit lag
value. We wanted to improve our user experience, without complicating the
database configuration. So we went back to the whiteboard and considered the
commit lag anew. Its optimal size depended on the shape of the incoming data,
which was not static. This meant that the commit lag size had to be dynamic! We
needed to predict the commit lag size and resize the value dynamically.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="dynamic-commits"></a>Dynamic commits<a class="hash-link" href="#dynamic-commits" title="Direct link to heading">#</a></h2><p>This is what we eventually implemented for QuestDB 6.6.1: to predict the correct
commit lag value, QuestDB takes the maximum of the latest 4 overlap values with
a multiplication factor - a bigger commit lag is better than a smaller one. This
prediction is updated every second. The commit lag value shrinks down to 0 when
data stops overlapping (no out-of-order data) and inflates rapidly in response
to out-of-order demands, depending on the data shape prediction.</p><p>Javier has upgraded his demo project to QuestDB 6.6.1 and now data is visible
instantly. Our DevRel is happy, and so are our users: it does not matter the
data ingestion method and the scope of the data, QuestDB automatically adjusts
settings and delivers the optimal data immediacy.</p><p>In short, users do not need to do anything to benefit from the optimal ingestion
rate and data availability for read operations. Check us out on
<a href="https://github.com/questdb/questdb/tree/6.6#readme" target="_blank" rel="noopener noreferrer">GitHub</a> for more details.</p></div><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/timeseries">timeseries</a><a class="margin-horiz--sm" href="/blog/tags/database">database</a><a class="margin-horiz--sm" href="/blog/tags/engineering">engineering</a><a class="margin-horiz--sm" href="/blog/tags/community">community</a><a class="margin-horiz--sm" href="/blog/tags/release">release</a></div></footer></article><div></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2022/11/30/full-table-scan-are-fast"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« Listen to Your CPU - Full-table Scans Are Fast</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2022/11/23/sql-extensions-time-series-data-questdb-part-ii"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">SQL Extensions for Time Series Data in QuestDB - Part II »</div></a></div></nav></div></main></div></div><div class="root_0lLS"><div class="cards_xeZk"><div class="root_R798 skinPrimary_JHOH"><svg width="76" height="76" viewBox="0 0 76 76" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="38" cy="38" r="38" fill="#1E1F27"></circle><path d="M56.99 18.792a.817.817 0 00-.117-.303c-.01-.02-.02-.05-.03-.069-.01-.02-.029-.029-.048-.049a.912.912 0 00-.137-.136l-.117-.088c-.02-.01-.03-.03-.05-.04-.029-.01-.068-.029-.107-.039a.85.85 0 00-.146-.049 1.075 1.075 0 00-.176-.019h-.147a1.15 1.15 0 00-.196.049c-.029.01-.068.01-.097.02L12.59 36.67a.979.979 0 00-.509 1.29c.098.216.264.401.48.5l16.07 7.556v15.025c0 .537.44.977.978.977a.964.964 0 00.831-.469l6.794-11.046 10.499 5.533a.974.974 0 001.408-.655l7.84-36.2v-.058c.01-.058.01-.107.019-.156 0-.059 0-.117-.01-.176zM29.413 44.208L15.376 37.6l36.326-15.68-22.289 22.288zm1.174 13.363V47.004l4.917 2.59-4.917 7.977zm16.92-3.87l-9.237-4.86-1.662-1.026-.068.118-5.289-2.786 23.1-23.12L47.508 53.7z" fill="#fff"></path></svg><h3 class="title_BHe0">문의하기</h3><p class="description_Bwvi">이메일을 입력하시면 소개자료를 보내드립니다.</p><div class="content_gAr2"><form class="root_teCd"><div><div class="inputs_0wQ8"><input type="email" class="input_cjQx input_a6pP" name="email" required="" pattern="^[a-zA-Z0-9.!#$%&amp;&#x27;*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$" placeholder="Email address" title="Email address should be valid"><button class="submit_poRs button_f7Ff button--tertiary_vtfp button--uppercase_ESEN" type="submit">보내기</button></div></div></form></div></div></div></div></div><footer class="root_JnvJ"><div class="content_-gfC center_S24y"><img alt="QuestDB logo" class="logo_JrwJ" src="/img/navbar/tp_brand.png" width="108" height="27"><div class="tagline_T1tH"><p>인프라관리부터 서비스운영까지 클라우드환경에 최적화된 클라우드 네이티브 플랫폼</p></div><div class="links_1SgP"></div></div><div class="border_PW0V"><div class="bottom_wPs3 center_S24y">Copyright © 2023 Gitple. All rights are reserved.</div></div></footer></div>
<script src="/assets/js/main.3e047ba9.js" defer="defer"></script>
</body>
</html>
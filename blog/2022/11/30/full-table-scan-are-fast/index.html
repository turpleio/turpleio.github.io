<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3">
<meta httpequiv="x-ua-compatible" content="ie=edge">
<meta property="og:type" content="website">
<meta name="author" content="turpleio">
<meta name="generator" content="Docusaurus v2.0.0-alpha.75">
<link href="https://www.googletagmanager.com" rel="dns-prefetch">
<link href="https://www.google-analytics.com" rel="dns-prefetch">
<link rel="icon" href="/favicon.png">
<link rel="apple-touch-icon" href="/img/icons/apple-180x180.png" sizes="180x180">
<meta name="msapplication-config" content="/browserconfig.xml">
<link rel="sitemap" type="application/xml" href="/sitemap.xml">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=GTM-PVR7M2G"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","GTM-PVR7M2G",{anonymize_ip:!0})</script>
<link rel="search" type="application/opensearchdescription+xml" title="Turple: Cloud Native Platform" href="/opensearch.xml">
<link rel="manifest" href="/manifest.webmanifest">
<meta name="theme-color" content="#d14671">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#21222c">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Turple: Cloud Native Platform Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Turple: Cloud Native Platform Blog Atom Feed"><title data-react-helmet="true">Listen to Your CPU - Full-table Scans Are Fast | Turple: Cloud Native Platform</title><meta data-react-helmet="true" property="og:title" content="Listen to Your CPU - Full-table Scans Are Fast | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="description" content="Demonstrating the raw speed of modern hardware"><meta data-react-helmet="true" name="twitter:description" content="Demonstrating the raw speed of modern hardware"><meta data-react-helmet="true" property="og:description" content="Demonstrating the raw speed of modern hardware"><meta data-react-helmet="true" name="twitter:title" content="Listen to Your CPU - Full-table Scans Are Fast | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="twitter:image:alt" content="Image for &quot;Listen to Your CPU - Full-table Scans Are Fast | Turple: Cloud Native Platform&quot;"><meta data-react-helmet="true" name="keywords" content="mechanical sympathy,performance,full table scans,database,open source"><meta data-react-helmet="true" property="og:image" content="https://turpleio.github.io/img/blog/2022-11-30/scan.png"><meta data-react-helmet="true" name="twitter:image" content="https://turpleio.github.io/img/blog/2022-11-30/scan.png"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><link rel="stylesheet" href="/assets/css/styles.4f6557e4.css">
</head>
<body itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="Turple: Cloud Native Platform">
<meta itemprop="description" content="Turple is a cloud native platform which can help you build and operate your services on cloud.">
<meta itemprop="url" content="https://turpleio.github.io">
<meta itemprop="logo" content="https://turpleio.github.io/img/favicon.png">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<nav class="navbar navbar_wBc8 navbar--light"><div class="navbar__inner inner_Y8Z6"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand brand_AtiA" href="/">QuestDB</a></div><div class="navbar__items navbar__items--right"></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand brand_AtiA" href="/">QuestDB</a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"></ul></div></div></div></nav><div class="wrapper_DIJ0 blog-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--3"><div class="sidebar_q+wC thin-scrollbar"><h3 class="sidebarItemTitle_9G5K">Recent posts</h3><ul class="sidebarItemList_6T4b"><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/19/merry-questmas-gifts-2023">Merry Questmas! Here are your gifts for 2023...</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/13/using-prometheus-loki-grafana-monitor-questdb-kubernetes">Using Prometheus, Loki, and Grafana to monitor QuestDB in Kubernetes</a></li><li class="sidebarItem_cjdF"><a aria-current="page" class="sidebarItemLink_zyXk sidebarItemLinkActive_wcJs" href="/blog/2022/11/30/full-table-scan-are-fast">Listen to Your CPU - Full-table Scans Are Fast</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/25/questdb-6.6.1-dynamic-commits">QuestDB 6.6.1 - Dynamic Commits</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/23/sql-extensions-time-series-data-questdb-part-ii">SQL Extensions for Time Series Data in QuestDB - Part II</a></li></ul></div></div><main class="col col--7"><article><header><h1 class="title_KBQu">Listen to Your CPU - Full-table Scans Are Fast</h1><time datetime="2022-11-30T00:00:00.000Z" class="date_A31P">November 30, 2022 · 6 min read</time><div class="avatar margin-vert--md"><a href="https://twitter.com/jerrinot" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars.githubusercontent.com/jerrinot" alt="Jaromir Hamala"></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://twitter.com/jerrinot" target="_blank" rel="noopener noreferrer">Jaromir Hamala</a></h4><small class="avatar__subtitle">QuestDB Team</small></div></div></header><div class="markdown"><figure><img alt="A magnifying glass placed on a piece of paper with table printed on it." class="image_1-Fc" height="467" src="/img/blog/2022-11-30/scan.png" width="650"></figure><p>One of our core engineers, <a href="https://twitter.com/jerrinot" target="_blank" rel="noopener noreferrer">Jaromir Hamala</a>, was
inspired by an article comparing performance between index merging and composite
indexes. He conducted a similar test on QuestDB&#x27;s table scanning strategy. In
this article, Jaromir explains the benefit of table scanning and shows the
superior query performance it brings.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="a-hacker-news-article-index-merges-and-composite-indexes"></a>A Hacker News article: index merges and composite indexes<a class="hash-link" href="#a-hacker-news-article-index-merges-and-composite-indexes" title="Direct link to heading">#</a></h2><p>While browsing Hacker News, I stumbled upon an excellent article written by
Simon Hørup Eskildsen:
<a href="https://sirupsen.com/index-merges" target="_blank" rel="noopener noreferrer">&quot;Index Merges vs Composite Indexes in Postgres and MySQL&quot;</a>.
Simon compares index performance for queries using a conjunction of two
attributes. This is a fancy way to say that an SQL query contains a predicate
similar to this:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">WHERE attribute1 = &#x27;foo&#x27; AND attribute2 = &#x27;bar;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>The article does multiple things exceptionally well:</p><ul><li>It describes different strategies a database engine can use to evaluate the
query: composite indexes v.s. merging results from individual indexes.</li><li>It shows systematic thinking about performance. It tries to estimate expected
performance results based on the capabilities of modern hardware in
combination with educated guesses about how a database likely works. I found
this part incredibly fascinating. Reasoning about performance from first
principles is more than just cool. It helps to build a better intuition and
deeper understanding of our tools.</li><li>It shows the actual results from MySQL and PostgreSQL, discusses how they
differ from the expected results, and tries to explain the reasons. Again,
very enlightening!</li></ul><p>While reading the article, I wondered: how would QuestDB perform in this
scenario? My curiosity increased after reading a
<a href="https://news.ycombinator.com/item?id=33765570" target="_blank" rel="noopener noreferrer">discussion</a> on Hacker News -
someone posted results from a similar query running on ClickHouse. So I thought
that it&#x27;d be interesting to do a similar one on QuestDB!</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="to-index-or-not-index-that-is-the-question"></a>To index or not index, that is the question<a class="hash-link" href="#to-index-or-not-index-that-is-the-question" title="Direct link to heading">#</a></h2><p>QuestDB - as many other analytical/OLAP databases - tends to rely on table scans
rather than index lookups. This is due to the nature of analytical queries: they
are typically more complex than OLTP queries and often touch a lot of data.</p><p>Table scanning also plays nicely with modern hardware: our hardware is
incredibly fast in everything sequential. Sequential memory access is MUCH
faster than random access. Sequential disk access allows deeper IO queues
resulting in better performance than random access. Sequential access also
offers optimization opportunities, such as using
<a href="/blog/2020/04/02/using-simd-to-aggregate-billions-of-rows-per-second/">SIMD instructions</a>
to evaluate filters. Table scanning also means that there is no index to
maintain, and therefore the concurrency model is simpler. This allows the
<a href="https://www.p99conf.io/session/building-efficient-multi-threaded-filters-for-faster-sql-queries/" target="_blank" rel="noopener noreferrer">utilization of multiple threads</a>
with very little inter-thread communication, which is costly. The simplicity
also translates into another advantage: a straightforward query plan can be
<a href="/blog/2022/01/12/jit-sql-compiler/">Just-In-Time compiled into a native code</a>,
increasing performance further.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="testing-time"></a>Testing time<a class="hash-link" href="#testing-time" title="Direct link to heading">#</a></h2><p>I did what every curious software engineer would do: I started an EC2 instance,
unpacked QuestDB, and started poking it. Specifically, I created an
<code>m6a.8xlarge</code> instance with 32 vCPU and 128GB of RAM. That is not a bad machine,
it&#x27;s probably better than most development workstations. On the other hand, it&#x27;s
not a super beefy machine for a database server. I also asked AWS to use GP3 as
block storage, but that was it. No further tuning; even all GP3 parameters were
left on defaults.</p><p>QuestDB installation is effortless. <a href="https://questdb.io/get-questdb/" target="_blank" rel="noopener noreferrer">Download</a>
a tarball, unzip, and start it:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI bash"><div tabindex="0" class="prism-code language-bash codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">$ </span><span class="token function" style="color:#8be9fd">wget</span><span class="token plain"> https://github.com/questdb/questdb/releases/download/6.6.1/questdb-6.6.1-rt-linux-amd64.tar.gz</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">$ </span><span class="token function" style="color:#8be9fd">tar</span><span class="token plain"> xzvf ./questdb-6.6.1-rt-linux-amd64.tar.gz</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">$ </span><span class="token builtin class-name" style="color:#bd93f9">cd</span><span class="token plain"> ./questdb-6.6.1-rt-linux-amd64/bin/</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">$ ./questdb.sh start</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Then I used the builtin Web Console to create a table and populate it with data:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">CREATE TABLE test_table (</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  id long,</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  text1 String,</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  text2 String,</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  int1000 long,</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  int100 long,</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  int10 long,</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  int10_2 long</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">);</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">INSERT INTO test_table</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  SELECT</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  rnd_long(),</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  rnd_str(1, 1024, 1024, 0),</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  rnd_str(1, 255, 255, 0),</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  rnd_long(0, 999, 0),</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  rnd_long(0, 99, 0),</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  rnd_long(0, 9, 0),</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  rnd_long(0, 9, 0)</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">FROM long_sequence(10000000);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>The <code>INSERT</code> query generates 10 million rows with random data roughly matching
the shape of the table and data from the original article.</p><p>And finally, the moment of truth: how fast will QuestDB run the aggregation with
the same filter? Will it be faster than PostgreSQL&#x27;s composite index? Or at
least faster than MySQL&#x27;s index merge? Will raw performance and mechanical
sympathy outperform smart indexes? Here is the result:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">SELECT count(*)</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  FROM test_table</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  WHERE int100 = 1 AND int1000 = 1;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p><img alt="Screenshot showing result time of 4.95 milliseconds" src="/assets/images/result-9b32866a64e710275ccf89246d3e8113.png"></p><p>It shows the query execution time was just under 5 milliseconds! That is on par
with the best result in the <a href="https://sirupsen.com/index-merges" target="_blank" rel="noopener noreferrer">original blog</a>,
where PostgreSQL uses a composite index specialized for this shape of queries,
and it&#x27;s better than all other results in the original post! Once again, QuestDB
does a full table scan. It does not use any fancy data structure to minimize the
number of reads. It&#x27;s just raw power and algorithms written to use the best out
of your hardware.</p><p>The main advantage of this approach is clear: I did not have to prepare indexes
upfront and specialized them for a given shape of a query. I could run a query
filtering on a different combination of columns and the result would be very
similar. This is a huge advantage for ad-hoc queries, which are very common in
analytics.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="are-indexes-useless"></a>Are indexes useless?<a class="hash-link" href="#are-indexes-useless" title="Direct link to heading">#</a></h2><p>This is not a serious comparison, as I do not know the hardware specs used in
the original post. Perhaps even more importantly, MySQL and PostgreSQL are very
different beasts from time-series/analytical databases. They make different
design and implementation trade-offs because they aim at different typical use
cases. So what is the point of this article? It&#x27;s simple:</p><ol><li>I wanted to satisfy my own curiosity 😄</li><li>I wanted to show how amazingly fast modern hardware is when we - the
developers - are not sabotaging its inner working. Once again, The database
scanned 10M rows in less than 5 ms, and I still find it incredible!</li></ol><p>This is not to say indexes have no place in analytical databases. They still do:
an index with great selectivity (think of a unique index) will outperform full
table scans. Sparse indexes can be cheaper to maintain and help avoid scanning
chunks of data. This can be very relevant in architectures where hot data is
kept on fast local SSDs while cold data is kept on cheaper storages such as AWS
S3. If an index can be used to avoid copying data from a cold storage then it&#x27;s
a performance (and cost!) win, too.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="further-experiments"></a>Further experiments<a class="hash-link" href="#further-experiments" title="Direct link to heading">#</a></h2><p>QuestDB is running a <a href="https://demo.questdb.io/" target="_blank" rel="noopener noreferrer">public demo</a> where you can
explore various datasets. My favorite example of a raw sequential performance is
this super simple aggregation:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">SELECT avg(trip_distance) FROM trips;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>It aggregates 1.6B rows in under 0.5s! When I saw it for the first time, I
assumed it must have been cached. Well, it&#x27;s not. It&#x27;s mechanical sympathy in
practice!</p></div><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/performance">performance</a><a class="margin-horiz--sm" href="/blog/tags/database">database</a><a class="margin-horiz--sm" href="/blog/tags/mechanical-sympathy">mechanical_sympathy</a></div></footer></article><div></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2022/12/13/using-prometheus-loki-grafana-monitor-questdb-kubernetes"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« Using Prometheus, Loki, and Grafana to monitor QuestDB in Kubernetes</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2022/11/25/questdb-6.6.1-dynamic-commits"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">QuestDB 6.6.1 - Dynamic Commits »</div></a></div></nav></div></main></div></div><div class="root_0lLS"><div class="cards_xeZk"><div class="root_R798 skinPrimary_JHOH"><svg width="76" height="76" viewBox="0 0 76 76" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="38" cy="38" r="38" fill="#1E1F27"></circle><path d="M56.99 18.792a.817.817 0 00-.117-.303c-.01-.02-.02-.05-.03-.069-.01-.02-.029-.029-.048-.049a.912.912 0 00-.137-.136l-.117-.088c-.02-.01-.03-.03-.05-.04-.029-.01-.068-.029-.107-.039a.85.85 0 00-.146-.049 1.075 1.075 0 00-.176-.019h-.147a1.15 1.15 0 00-.196.049c-.029.01-.068.01-.097.02L12.59 36.67a.979.979 0 00-.509 1.29c.098.216.264.401.48.5l16.07 7.556v15.025c0 .537.44.977.978.977a.964.964 0 00.831-.469l6.794-11.046 10.499 5.533a.974.974 0 001.408-.655l7.84-36.2v-.058c.01-.058.01-.107.019-.156 0-.059 0-.117-.01-.176zM29.413 44.208L15.376 37.6l36.326-15.68-22.289 22.288zm1.174 13.363V47.004l4.917 2.59-4.917 7.977zm16.92-3.87l-9.237-4.86-1.662-1.026-.068.118-5.289-2.786 23.1-23.12L47.508 53.7z" fill="#fff"></path></svg><h3 class="title_BHe0">문의하기</h3><p class="description_Bwvi">이메일을 입력하시면 소개자료를 보내드립니다.</p><div class="content_gAr2"><form class="root_teCd"><div><div class="inputs_0wQ8"><input type="email" class="input_cjQx input_a6pP" name="email" required="" pattern="^[a-zA-Z0-9.!#$%&amp;&#x27;*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$" placeholder="Email address" title="Email address should be valid"><button class="submit_poRs button_f7Ff button--tertiary_vtfp button--uppercase_ESEN" type="submit">보내기</button></div></div></form></div></div></div></div></div><footer class="root_JnvJ"><div class="content_-gfC center_S24y"><img alt="QuestDB logo" class="logo_JrwJ" src="/img/navbar/tp_brand.png" width="108" height="27"><div class="tagline_T1tH"><p>인프라관리부터 서비스운영까지 클라우드환경에 최적화된 클라우드 네이티브 플랫폼</p></div><div class="links_1SgP"></div></div><div class="border_PW0V"><div class="bottom_wPs3 center_S24y">Copyright © 2023 Gitple. All rights are reserved.</div></div></footer></div>
<script src="/assets/js/main.185a1183.js" defer="defer"></script>
</body>
</html>
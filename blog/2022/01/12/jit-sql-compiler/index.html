<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3">
<meta httpequiv="x-ua-compatible" content="ie=edge">
<meta property="og:type" content="website">
<meta name="author" content="turpleio">
<meta name="generator" content="Docusaurus v2.0.0-alpha.75">
<link href="https://www.googletagmanager.com" rel="dns-prefetch">
<link href="https://www.google-analytics.com" rel="dns-prefetch">
<link rel="icon" href="/favicon.png">
<link rel="apple-touch-icon" href="/img/icons/apple-180x180.png" sizes="180x180">
<meta name="msapplication-config" content="/browserconfig.xml">
<link rel="sitemap" type="application/xml" href="/sitemap.xml">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=GTM-PVR7M2G"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","GTM-PVR7M2G",{anonymize_ip:!0})</script>
<link rel="search" type="application/opensearchdescription+xml" title="Turple: Cloud Native Platform" href="/opensearch.xml">
<link rel="manifest" href="/manifest.webmanifest">
<meta name="theme-color" content="#d14671">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#21222c">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Turple: Cloud Native Platform Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Turple: Cloud Native Platform Blog Atom Feed"><title data-react-helmet="true">How we built a SIMD JIT compiler for SQL in QuestDB | Turple: Cloud Native Platform</title><meta data-react-helmet="true" property="og:title" content="How we built a SIMD JIT compiler for SQL in QuestDB | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="description" content="QuestDB 6.2.0 brings a brand new JIT (Just-in-Time) compiler as a part of the SQL engine. This post describes our storage model, how we built a JIT compiler for SQL and our plans for improving it in future."><meta data-react-helmet="true" name="twitter:description" content="QuestDB 6.2.0 brings a brand new JIT (Just-in-Time) compiler as a part of the SQL engine. This post describes our storage model, how we built a JIT compiler for SQL and our plans for improving it in future."><meta data-react-helmet="true" property="og:description" content="QuestDB 6.2.0 brings a brand new JIT (Just-in-Time) compiler as a part of the SQL engine. This post describes our storage model, how we built a JIT compiler for SQL and our plans for improving it in future."><meta data-react-helmet="true" name="twitter:title" content="How we built a SIMD JIT compiler for SQL in QuestDB | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="twitter:image:alt" content="Image for &quot;How we built a SIMD JIT compiler for SQL in QuestDB | Turple: Cloud Native Platform&quot;"><meta data-react-helmet="true" name="keywords" content="jit,compiler,performance,timeseries,database,engineering"><meta data-react-helmet="true" property="og:image" content="https://turpleio.github.io/img/blog/2022-01-12/banner.png"><meta data-react-helmet="true" name="twitter:image" content="https://turpleio.github.io/img/blog/2022-01-12/banner.png"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><link rel="stylesheet" href="/assets/css/styles.4f6557e4.css">
</head>
<body itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="Turple: Cloud Native Platform">
<meta itemprop="description" content="Turple is a cloud native platform which can help you build and operate your services on cloud.">
<meta itemprop="url" content="https://turpleio.github.io">
<meta itemprop="logo" content="https://turpleio.github.io/img/favicon.png">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<nav class="navbar navbar_wBc8 navbar--light"><div class="navbar__inner inner_Y8Z6"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand brand_AtiA" href="/">QuestDB</a></div><div class="navbar__items navbar__items--right"></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand brand_AtiA" href="/">QuestDB</a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"></ul></div></div></div></nav><div class="wrapper_DIJ0 blog-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--3"><div class="sidebar_q+wC thin-scrollbar"><h3 class="sidebarItemTitle_9G5K">Recent posts</h3><ul class="sidebarItemList_6T4b"><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/19/merry-questmas-gifts-2023">Merry Questmas! Here are your gifts for 2023...</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/13/using-prometheus-loki-grafana-monitor-questdb-kubernetes">Using Prometheus, Loki, and Grafana to monitor QuestDB in Kubernetes</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/30/full-table-scan-are-fast">Listen to Your CPU - Full-table Scans Are Fast</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/25/questdb-6.6.1-dynamic-commits">QuestDB 6.6.1 - Dynamic Commits</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/23/sql-extensions-time-series-data-questdb-part-ii">SQL Extensions for Time Series Data in QuestDB - Part II</a></li></ul></div></div><main class="col col--7"><article><header><h1 class="title_KBQu">How we built a SIMD JIT compiler for SQL in QuestDB</h1><time datetime="2022-01-12T00:00:00.000Z" class="date_A31P">January 12, 2022 · 10 min read</time><div class="avatar margin-vert--md"><a href="https://github.com/puzpuzpuz" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars.githubusercontent.com/puzpuzpuz" alt="Andrey Pechkurov"></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/puzpuzpuz" target="_blank" rel="noopener noreferrer">Andrey Pechkurov</a></h4><small class="avatar__subtitle">Co-authored by Eugene Lysyuchenko</small></div></div></header><div class="markdown"><figure><img alt="Details of the latest QuestDB version which includes a JIT compiler for the SQL engine" class="image_1-Fc" height="360" src="/img/blog/2022-01-12/banner.png" width="650"></figure><p>QuestDB 6.2.0 brings a brand new JIT (Just-in-Time) compiler as a part of the
SQL engine. The compiler aims to significantly improve execution times for
queries with simple arithmetic expressions used to filter the data. It took us
11K lines of code, 250+ commits, and plenty of coffee to ship it, and we&#x27;d like
to share the story with you.</p><p>Before we dive into the implementation details behind our JIT compiler, let&#x27;s
understand what kind of problems JIT compilation aims to solve in our SQL engine
and where exactly you should expect performance improvements.</p><p>It can often happen that analytical queries run by users end up performing a
full scan over a table or, at least, over some of its partitions. Here is an
example of such a query:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">SELECT *</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">FROM trips</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">WHERE pickup_datetime IN (&#x27;2009-01&#x27;) AND total_amount &gt; 150;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>The above query returns relatively expensive trips within one month from 10+
years of taxi data available on our <a href="https://demo.questdb.io/" target="_blank" rel="noopener noreferrer">live demo</a>. To
execute this query, QuestDB has to scan 13.5 million rows. This means that the
database has to do many sequential reads from the column files and apply the
filter expression (think, <code>WHERE</code> clause) to each value. There is a good chance
that the data is already in the page cache or the disk is fast enough not to
become the bottleneck. Thus, the execution time for such queries has all chances
to be limited by the CPU performance.</p><p>The pre-JIT implementation of filter expression evaluation in QuestDB is based
on the operator function call tree. The functions are nothing more than Java
classes you may find
<a href="https://github.com/questdb/questdb/tree/master/core/src/main/java/io/questdb/griffin/engine/functions" target="_blank" rel="noopener noreferrer">as part of the Griffin engine</a>.
This approach is quite powerful and general, but it also has some disadvantages
we will cover.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="pre-jit-filtering"></a>Pre-JIT filtering<a class="hash-link" href="#pre-jit-filtering" title="Direct link to heading">#</a></h2><p>As you may already know, QuestDB has a
<a href="https://questdb.io/docs/concept/storage-model" target="_blank" rel="noopener noreferrer">column-based storage model</a>.
Data is stored in tables, with each column stored in its own file. For read-only
queries, columns with fixed-size data types are read by translating the record
number into an offset in the column file by a simple bit shift. The offset is
then translated into an offset in a lazily mapped memory page, where the
required value is read.</p><figure><img alt="A diagram showing the data model in QuestDB" class="image_Pw1y margin_Rc0b shadow_7z-4" height="598" src="/img/blog/2022-01-12/data-model.png" width="650"></figure><p>This storage model allows queries that do a full or partial table scan to be
performed efficiently. The database interprets the filter expression during the
query evaluation, translates it into an operator function call tree, and then
executes the query in a tight loop. In the case of our example query, the loop
looks something like the following Java code:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><div tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">public boolean hasNext() {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    while (base.hasNext()) {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        if (filter.getBool(record)) {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">            return true;</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        }</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    }</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>This method is called when the database iterates through the result set to send
the query result to the client. Here, the <code>filter</code> is the top-level object from
the operator function call tree that we&#x27;ve mentioned. The <code>base</code> is the data
frame cursor responsible for the iteration through the column files, and the
<code>record</code> is the <a href="https://en.wikipedia.org/wiki/Flyweight_pattern" target="_blank" rel="noopener noreferrer">flyweight</a>
object that allows accessing column values for the current row. The call tree is
minuscule in our example and only consists of three objects.</p><figure><img alt="A diagram showing a function call tree in QuestDB" class="image_Pw1y margin_Rc0b shadow_7z-4" height="598" src="/img/blog/2022-01-12/object-tree.png" width="650"></figure><p>The top-level object called <code>LtDoubleFunction</code> is our <code>filter</code> object. This
function is a comparison operator while <code>IntConstant</code> (the <code>150</code> constant
literal) and <code>DoubleColumn</code> (the <code>total_amount</code> column) are its operand
functions. Notice that the <code>pickup_datetime IN (&#x27;2009-01&#x27;)</code> part of the query is
not present in the filter since QuestDB is smart enough to apply the predicate
for the
<a href="https://questdb.io/docs/concept/designated-timestamp/" target="_blank" rel="noopener noreferrer">designated timestamp</a>
column (<code>pickup_datetime</code>) to the underlying data frame cursor and remove it
from the filter tree.</p><p>As you might have already guessed, the <code>filter.getBool(record)</code> method call from
the Java snippet calls the filter tree hierarchy for each iterated row. When
called, <code>LtDoubleFunction</code> calls its operand function to obtain their values on
the current row, compares them, and returns the filter result to the outer loop.
The hierarchy and the number of nested calls may be arbitrarily large for
complex SQL queries. JVM&#x27;s (Java Virtual Machine) own JIT compiler does a great
job optimizing the code, but it&#x27;s possible to produce more efficient machine
code in this particular case. As we find out later, the difference between JVM&#x27;s
JIT output and our own machine code may be noticeable even for simple queries.</p><p>Another sub-optimal aspect here is that this way of filtering is &quot;scalar&quot;, i.e.
it navigates through the table row by row and applies the filter to a single row
at a time. In many cases, the execution of the filter expressions could be
accelerated by vectorized processing when
<a href="https://en.wikipedia.org/wiki/SIMD" target="_blank" rel="noopener noreferrer">SIMD instructions</a> are used to calculate
the filter result for multiple rows simultaneously.</p><p>Accordingly, we built the JIT compiler to solve the above problems and improve
CPU usage efficiency for a certain class of SQL queries.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="jit-based-filtering"></a>JIT-based filtering<a class="hash-link" href="#jit-based-filtering" title="Direct link to heading">#</a></h2><p>QuestDB&#x27;s JIT compiler consists of two major parts: the frontend and backend.
The frontend is written in Java and kicks in once an execution plan is built for
the query. Frontend&#x27;s primary goal is to analyze whether the filter is suitable
for JIT compilation and serialize the filter abstract syntax tree to an
intermediate representation (IR) along with necessary metadata. The IR is then
provided in a call to the backend, which finishes the compilation and emits
compact and efficient machine code for the filter function. When vectorized
execution is enabled, the filter from our example trips table query compiles to
58 machine instructions.</p><p>The compiler backend itself is written in C++ and uses
<a href="https://github.com/asmjit/asmjit" target="_blank" rel="noopener noreferrer">asmjit</a> library for machine code generation.
Currently, the backend works on x86-64 CPUs only and uses AVX2 instructions in
the compiled function when the CPU supports them.</p><p>The filter function is called on table page frames instead of individual rows.
When the function uses SIMD instructions, the CPU core executes the query
processes multiple rows simultaneously. For instance, for a filter on a single
INT (32-bit signed integer) column, 8 rows would be processed concurrently since
AVX2 registers are 256-bit. Once the filter result is calculated on these rows,
their row IDs are appended to an intermediate array. Later, when all rows in the
page frame are processed, the array is returned back to the Java code. This way,
we can benefit from batch processing and vectorized execution.</p><p>Apart from the supported CPUs, there are a few limitations in the first release
of the JIT compiler. Only filters with arithmetical expressions for fixed-size
columns are a subject for the compilation. We will expand the functionality of
the JIT compiler in future releases.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="how-to-use-it"></a>How to use it<a class="hash-link" href="#how-to-use-it" title="Direct link to heading">#</a></h2><p>SQL JIT compiler is a beta feature and is disabled by default. To enable it, you
should change the <code>cairo.sql.jit.mode</code> setting in your <code>server.conf</code> file.</p><div class="codeBlockContainer_J+bg"><div style="color:#f8f8f2;background-color:#262833" class="codeBlockTitle_oQzk">path/to/server.conf</div><div class="codeBlockContent_csEI ini"><div tabindex="0" class="prism-code language-ini codeBlock_rtdJ thin-scrollbar codeBlockWithTitle_ZT05"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">cairo.sql.jit.mode=on</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Embedded API users are able to enable the compiler globally by providing their
<code>CairoConfiguration</code> implementation. Alternatively, JIT compilation can be
enabled for a single query by using the <code>SqlExecutionContext#setJitMode</code> method.
The latter may look like the following:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><div tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">final CairoConfiguration configuration = new DefaultCairoConfiguration(temp.getRoot().getAbsolutePath());</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">try (CairoEngine engine = new CairoEngine(configuration)) {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    final SqlExecutionContextImpl ctx = new SqlExecutionContextImpl(engine, 1);</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    // Enable SQL JIT compiler</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    ctx.setJitMode(SqlJitMode.JIT_MODE_ENABLED);</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    // Subsequent query execution (called as usual) with have JIT enabled</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    try (SqlCompiler compiler = new SqlCompiler(engine)) {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        try (RecordCursorFactory factory = compiler.compile(&quot;abc&quot;, ctx).getRecordCursorFactory()) {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">            try (RecordCursor cursor = factory.getCursor(ctx)) {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                // ...</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">            }</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        }</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    }</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>When QuestDB starts with the enabled JIT compiler feature, the server logs will
contain messages relating to <code>SQL JIT compiler</code> like the following:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI log"><div tabindex="0" class="prism-code language-log codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">2021-12-16T09:25:34.472450Z A server-main SQL JIT compiler mode: on</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">2021-12-16T09:25:34.472475Z A server-main Note: JIT compiler mode is a beta feature.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>As already mentioned, JIT compilation won&#x27;t take place for any query you run. To
understand whether the compilation took place for a query, you should check the
server logs to contain something similar to this message:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI log"><div tabindex="0" class="prism-code language-log codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">2021-12-16T09:35:01.742777Z I i.q.g.SqlCodeGenerator JIT enabled for (sub)query [tableName=trips, fd=62]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="performance-impact"></a>Performance impact<a class="hash-link" href="#performance-impact" title="Direct link to heading">#</a></h2><p>To get an idea of the performance improvements you can expect with JIT, we can
do some benchmarking. It&#x27;s important to mention that your mileage may vary since
performance improvement provided by JIT compilation depends on many factors,
such as exact software versions, hardware, table schema, and query. The below
results were obtained on a laptop with i7-1185G7, 32GB RAM, and an NVMe SSD
drive running Ubuntu 20.04 and OpenJDK 17.0.1.</p><p>We start with the query from our example:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">SELECT *</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">FROM trips</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">WHERE pickup_datetime IN (&#x27;2009-01&#x27;) AND total_amount &gt; 150;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>These are the results of the average query execution time observed after several
runs (so-called hot query execution). In this case, a &quot;cold run&quot; stands for the
first query run, while &quot;hot run&quot; means a subsequent run where the table data is
in the page cache.</p><figure><img alt="A chart comparing query execution times in QuestDB with JIT enabled and disabled" class="image_Pw1y margin_Rc0b shadow_7z-4" height="598" src="/img/blog/2022-01-12/cold-v-hot-run.png" width="650"></figure><p>The results show that the JIT compiler doesn&#x27;t make any difference for cold
runs, i.e., I/O-bound scenarios. Once the data is in the page cache, the query
execution becomes CPU-bound, and JIT reduces the time dramatically - by 76%
compared with the Java implementation.</p><p>If we do some back-of-the-envelope calculations, the on-disk size of the
<code>total_amount</code> column file in the 2009-01 partition is 110MB. Considering that
the query takes around 35ms when JIT is enabled, this yields almost 3.3 GB/s
filtering rate. In fact, it&#x27;s even higher since the SQL engine also needs to do
other steps when executing a query, like gathering the result set. In addition,
with more fine-grained benchmarks, we saw a filtering rate of 9.4 GB/s on the
same machine, which is not far away from its peak memory bandwidth (24.9 GB/s on
a single thread).</p><p>Why don&#x27;t we make the task much harder? To do this, we can remove the time
predicate and run a query for trips with a total amount over a value for a
single passenger across all years. This means a full table scan of 1.6 billion
rows in total.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">SELECT count(), max(total_amount), avg(total_amount)</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">FROM trips</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">WHERE total_amount &gt; 150 AND passenger_count = 1;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>The measurement results for this query are the following:</p><figure><img alt="A chart comparing query execution times in QuestDB with JIT enabled and disabled" class="image_Pw1y margin_Rc0b shadow_7z-4" height="598" src="/img/blog/2022-01-12/cold-v-hot-run-two.png" width="650"></figure><p>Once again, we see a significant improvement when the JIT compiler is enabled,
and the data is in the page cache. Interestingly, due to a larger volume of the
data that has to be read from the disk, JIT also improves cold execution time.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="next-up"></a>Next up<a class="hash-link" href="#next-up" title="Direct link to heading">#</a></h2><p>This is only the beginning for QuestDB&#x27;s JIT compiler, and we have a lot of
plans for its future improvements. First of all, we&#x27;d like to support ARM64 CPUs
along with the NEON instruction set. Next, we&#x27;d like to parallelize the query
execution when suitable to improve the execution time even further. Finally, we
plan to expand the limitations on the supported filters and experiment with
potential optimizations in the JIT compiler.</p><p>We encourage our users to try out the SQL JIT compiler feature on their
development QuestDB instances and provide feedback in our
<a href="https://slack.questdb.io/" target="_blank" rel="noopener noreferrer">Slack Community</a>. JIT compiler is also enabled on
our <a href="https://demo.questdb.io/" target="_blank" rel="noopener noreferrer">live demo</a>, so you may want to run some queries
there. And, of course, open-source contributions to our
<a href="https://github.com/questdb/questdb" target="_blank" rel="noopener noreferrer">project on GitHub</a> are more than welcome.</p></div><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/engineering">engineering</a><a class="margin-horiz--sm" href="/blog/tags/story">story</a><a class="margin-horiz--sm" href="/blog/tags/performance">performance</a></div></footer></article><div></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2022/01/27/release-sql-jit-compiler"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« QuestDB 6.2 January release, SQL JIT compiler</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2022/01/03/two-year-journey-raising-15m-venture-capital"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Our two-year journey to raise $15m in venture capital »</div></a></div></nav></div></main></div></div><div class="root_0lLS"><div class="cards_xeZk"><div class="root_R798 skinPrimary_JHOH"><svg width="76" height="76" viewBox="0 0 76 76" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="38" cy="38" r="38" fill="#1E1F27"></circle><path d="M56.99 18.792a.817.817 0 00-.117-.303c-.01-.02-.02-.05-.03-.069-.01-.02-.029-.029-.048-.049a.912.912 0 00-.137-.136l-.117-.088c-.02-.01-.03-.03-.05-.04-.029-.01-.068-.029-.107-.039a.85.85 0 00-.146-.049 1.075 1.075 0 00-.176-.019h-.147a1.15 1.15 0 00-.196.049c-.029.01-.068.01-.097.02L12.59 36.67a.979.979 0 00-.509 1.29c.098.216.264.401.48.5l16.07 7.556v15.025c0 .537.44.977.978.977a.964.964 0 00.831-.469l6.794-11.046 10.499 5.533a.974.974 0 001.408-.655l7.84-36.2v-.058c.01-.058.01-.107.019-.156 0-.059 0-.117-.01-.176zM29.413 44.208L15.376 37.6l36.326-15.68-22.289 22.288zm1.174 13.363V47.004l4.917 2.59-4.917 7.977zm16.92-3.87l-9.237-4.86-1.662-1.026-.068.118-5.289-2.786 23.1-23.12L47.508 53.7z" fill="#fff"></path></svg><h3 class="title_BHe0">문의하기</h3><p class="description_Bwvi">이메일을 입력하시면 소개자료를 보내드립니다.</p><div class="content_gAr2"><form class="root_teCd"><div><div class="inputs_0wQ8"><input type="email" class="input_cjQx input_a6pP" name="email" required="" pattern="^[a-zA-Z0-9.!#$%&amp;&#x27;*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$" placeholder="Email address" title="Email address should be valid"><button class="submit_poRs button_f7Ff button--tertiary_vtfp button--uppercase_ESEN" type="submit">보내기</button></div></div></form></div></div></div></div></div><footer class="root_JnvJ"><div class="content_-gfC center_S24y"><img alt="QuestDB logo" class="logo_JrwJ" src="/img/navbar/tp_brand.png" width="108" height="27"><div class="tagline_T1tH"><p>인프라관리부터 서비스운영까지 클라우드환경에 최적화된 클라우드 네이티브 플랫폼</p></div><div class="links_1SgP"></div></div><div class="border_PW0V"><div class="bottom_wPs3 center_S24y">Copyright © 2023 Gitple. All rights are reserved.</div></div></footer></div>
<script src="/assets/js/main.185a1183.js" defer="defer"></script>
</body>
</html>
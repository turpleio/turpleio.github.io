<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3">
<meta httpequiv="x-ua-compatible" content="ie=edge">
<meta property="og:type" content="website">
<meta name="author" content="turpleio">
<meta name="generator" content="Docusaurus v2.0.0-alpha.75">
<link href="https://www.googletagmanager.com" rel="dns-prefetch">
<link href="https://www.google-analytics.com" rel="dns-prefetch">
<link rel="icon" href="/favicon.png">
<link rel="apple-touch-icon" href="/img/icons/apple-180x180.png" sizes="180x180">
<meta name="msapplication-config" content="/browserconfig.xml">
<link rel="sitemap" type="application/xml" href="/sitemap.xml">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=GTM-PVR7M2G"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","GTM-PVR7M2G",{anonymize_ip:!0})</script>
<link rel="search" type="application/opensearchdescription+xml" title="Turple: Cloud Native Platform" href="/opensearch.xml">
<link rel="manifest" href="/manifest.webmanifest">
<meta name="theme-color" content="#d14671">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#21222c">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Turple: Cloud Native Platform Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Turple: Cloud Native Platform Blog Atom Feed"><title data-react-helmet="true">4Bn rows/sec query benchmark: Clickhouse vs QuestDB vs Timescale | Turple: Cloud Native Platform</title><meta data-react-helmet="true" property="og:title" content="4Bn rows/sec query benchmark: Clickhouse vs QuestDB vs Timescale | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="description" content="QuestDB 6.3 brings parallel filter execution optimization to our SQL engine allowing us to reduce both cold and hot query execution times quite dramatically."><meta data-react-helmet="true" name="twitter:description" content="QuestDB 6.3 brings parallel filter execution optimization to our SQL engine allowing us to reduce both cold and hot query execution times quite dramatically."><meta data-react-helmet="true" property="og:description" content="QuestDB 6.3 brings parallel filter execution optimization to our SQL engine allowing us to reduce both cold and hot query execution times quite dramatically."><meta data-react-helmet="true" name="twitter:title" content="4Bn rows/sec query benchmark: Clickhouse vs QuestDB vs Timescale | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="twitter:image:alt" content="Image for &quot;4Bn rows/sec query benchmark: Clickhouse vs QuestDB vs Timescale | Turple: Cloud Native Platform&quot;"><meta data-react-helmet="true" name="keywords" content="sql,multi-threading,performance,timeseries,database,engineering"><meta data-react-helmet="true" property="og:image" content="https://turpleio.github.io/img/blog/2022-05-26/banner.png"><meta data-react-helmet="true" name="twitter:image" content="https://turpleio.github.io/img/blog/2022-05-26/banner.png"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><link rel="stylesheet" href="/assets/css/styles.4f6557e4.css">
</head>
<body itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="Turple: Cloud Native Platform">
<meta itemprop="description" content="Turple is a cloud native platform which can help you build and operate your services on cloud.">
<meta itemprop="url" content="https://turpleio.github.io">
<meta itemprop="logo" content="https://turpleio.github.io/img/favicon.png">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<nav class="navbar navbar_wBc8 navbar--light"><div class="navbar__inner inner_Y8Z6"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand brand_AtiA" href="/">QuestDB</a></div><div class="navbar__items navbar__items--right"></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand brand_AtiA" href="/">QuestDB</a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"></ul></div></div></div></nav><div class="wrapper_DIJ0 blog-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--3"><div class="sidebar_q+wC thin-scrollbar"><h3 class="sidebarItemTitle_9G5K">Recent posts</h3><ul class="sidebarItemList_6T4b"><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/19/merry-questmas-gifts-2023">Merry Questmas! Here are your gifts for 2023...</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/13/using-prometheus-loki-grafana-monitor-questdb-kubernetes">Using Prometheus, Loki, and Grafana to monitor QuestDB in Kubernetes</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/30/full-table-scan-are-fast">Listen to Your CPU - Full-table Scans Are Fast</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/25/questdb-6.6.1-dynamic-commits">QuestDB 6.6.1 - Dynamic Commits</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/23/sql-extensions-time-series-data-questdb-part-ii">SQL Extensions for Time Series Data in QuestDB - Part II</a></li></ul></div></div><main class="col col--7"><article><header><h1 class="title_KBQu">4Bn rows/sec query benchmark: Clickhouse vs QuestDB vs Timescale</h1><time datetime="2022-05-26T00:00:00.000Z" class="date_A31P">May 26, 2022 · 13 min read</time><div class="avatar margin-vert--md"><a href="https://github.com/puzpuzpuz" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars.githubusercontent.com/puzpuzpuz" alt="Andrey Pechkurov"></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/puzpuzpuz" target="_blank" rel="noopener noreferrer">Andrey Pechkurov</a></h4><small class="avatar__subtitle">QuestDB Engineering</small></div></div></header><div class="markdown"><p>QuestDB 6.2, our previous minor version release,
<a href="https://questdb.io/blog/2022/01/12/jit-sql-compiler" target="_blank" rel="noopener noreferrer">introduced</a> JIT
(Just-in-Time) compiler for SQL filters. As we mentioned last time, the next
step would be to parallelize the query execution when suitable to improve the
execution time even further and that&#x27;s what we&#x27;re going to discuss and benchmark
today. QuestDB 6.3 enables JIT compiled filters by default and, what&#x27;s even more
noticeable, includes parallel SQL filter execution optimization allowing us to
reduce both cold and hot query execution times quite dramatically.</p><p>Prior to diving into the implementation details and running some before/after
benchmarks for QuestDB, we&#x27;ll be having a friendly competition with two popular
time series and analytical databases, TimescaleDB and ClickHouse. The purpose of
the competition is nothing more but an attempt to understand whether our
parallel filter execution is worth the hassle or not.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="comparing-with-other-databases"></a>Comparing with other databases<a class="hash-link" href="#comparing-with-other-databases" title="Direct link to heading">#</a></h2><p>Our test box is a c5a.12xlarge AWS VM running Ubuntu Server 20.04 64-bit. In
practice, this means 48 vCPU and 96 GB RAM. The attached storage is a 1 TB gp3
volume configured for 1,000 MB/s throughput and 16,000 IOPS. Apart from that,
we&#x27;ll be using QuestDB 6.3.1 with the default settings which means both parallel
filter execution and JIT compilation being enabled.</p><p>In order to make the benchmark easily reproducible, we&#x27;re going to use
<a href="https://github.com/timescale/tsbs" target="_blank" rel="noopener noreferrer">TSBS</a> benchmark utilities to generate the
data. We&#x27;ll be using so-called IoT use case:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI bash"><div tabindex="0" class="prism-code language-bash codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">./tsbs_generate_data --use-case</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;iot&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     --seed</span><span class="token operator" style="color:#ff79c6">=</span><span class="token number" style="color:#50fa7b">123</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     --scale</span><span class="token operator" style="color:#ff79c6">=</span><span class="token number" style="color:#50fa7b">5000</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     --timestamp-start</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;2020-01-01T00:00:00Z&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     --timestamp-end</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;2020-07-01T00:00:00Z&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     --log-interval</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;60s&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     --format</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;influx&quot;</span><span class="token plain"> </span><span class="token operator" style="color:#ff79c6">&gt;</span><span class="token plain"> /tmp/data </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     /</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>The above command generates six months of per-minute measurements for 5,000
truck IoT devices. This yields almost 1.2 billion records stored in a table
named <code>readings</code>.</p><p>Loading the data is as simple as:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI bash"><div tabindex="0" class="prism-code language-bash codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">./tsbs_load_questdb --file /tmp/data</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Now, when we have the data in the database, we&#x27;re going to execute the following
query on the <code>readings</code> table<a name="filter-query"></a>:</p><div class="codeBlockContainer_J+bg"><div style="color:#f8f8f2;background-color:#262833" class="codeBlockTitle_oQzk">Query 1</div><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar codeBlockWithTitle_ZT05"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">SELECT *</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">FROM readings WHERE velocity &gt; 90.0</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain"> AND latitude &gt;= 7.75 AND latitude &lt;= 7.80</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain"> AND longitude &gt;= 14.90 AND longitude &lt;= 14.95;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>This (kinda synthetic) query aims to find all measurements sent from fast-moving
trucks in the given location. Apart from that, it has a filter on three DOUBLE
columns and doesn&#x27;t include analytical clauses, like GROUP BY or SAMPLE BY,
which is exactly what we need.</p><p>Our first competitor is TimescaleDB 2.6.0 running on top of PostgreSQL 14.2. As
the official installation guide suggests, we made sure to run <code>timescaledb-tune</code>
to fine-tune TimescaleDB for better performance.</p><p>We generate the test data with the following command:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI bash"><div tabindex="0" class="prism-code language-bash codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">./tsbs_generate_data --use-case</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;iot&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     --seed</span><span class="token operator" style="color:#ff79c6">=</span><span class="token number" style="color:#50fa7b">123</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     --scale</span><span class="token operator" style="color:#ff79c6">=</span><span class="token number" style="color:#50fa7b">5000</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     --timestamp-start</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;2020-01-01T00:00:00Z&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     --timestamp-end</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;2020-07-01T00:00:00Z&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     --log-interval</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;60s&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     --format</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;timescaledb&quot;</span><span class="token plain"> </span><span class="token operator" style="color:#ff79c6">&gt;</span><span class="token plain"> /tmp/data </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                     /</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>That&#x27;s the same command as before, but with the <code>format</code> argument set to
<code>timescaledb</code>. Next, we load the data:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI bash"><div tabindex="0" class="prism-code language-bash codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">./tsbs_load_timescaledb --pass your_pwd --file /tmp/data</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Be prepared to wait for quite a while for the data to get in this time. We
observed 5-8x ingestion rate difference between QuestDB and two other databases
in this particular environment. Yet, that&#x27;s nothing more but a note for anyone
who wants to repeat the benchmark. If you&#x27;d like learn more on the ingestion
performance topic, check out this
<a href="https://questdb.io/time-series-benchmark-suite/" target="_blank" rel="noopener noreferrer">blog post</a>.</p><p>Finally, we&#x27;re able to run the first query and measure the hot execution time.
Yet, if we do it, it would take more than 15 minutes for TimescaleDB to execute
this query. At this point, experienced TimescaleDB &amp; PostgreSQL users may
suggest us to add an index to speed up this concrete query. So, let&#x27;s do that:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">CREATE INDEX ON readings (velocity, latitude, longitude);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>With an index in place, TimescaleDB can execute the query much much faster, in
around 4.4 seconds. To get the full picture, let&#x27;s include one more contestant.</p><p>The third member of our competition is ClickHouse 22.4.1.752. Just like with
TimescaleDB, the command to generate the data stays the same with only the
<code>format</code> argument being set to <code>clickhouse</code>. Once the data is generated, it can
be loaded into the database:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI bash"><div tabindex="0" class="prism-code language-bash codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">./tsbs_load_clickhouse --file /tmp/data</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>We&#x27;re ready to do the benchmark run.</p><figure><img alt="A chart comparing hot query execution times of QuestDB, ClickHouse and TimescaleDB - Query 1" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="265" src="/img/blog/2022-05-26/filter-benchmark.png" width="700"><figcaption class="caption_-tGK">Hot query execution times of QuestDB, ClickHouse and TimescaleDB - Query 1</figcaption></figure><p>The above chart shows that QuestDB is an order of magnitude faster than both
TimescaleDB and ClickHouse in this specific <a href="#filter-query">query</a>.</p><p>Interestingly, an index-based scan doesn&#x27;t help TimescaleDB to win the
competition. This is a nice illustration of the fact that a specialized
parallelism-friendly storage model may save you from having to deal with indexes
and paying the additional overhead during data ingestion.</p><p>As the next step, let&#x27;s give another popular type of query a go. In the world of
time series data, it&#x27;s common to query only the latest rows based on a certain
filter. QuestDB supports that elegantly through negative LIMIT clause values. If
we were to query ten latest measurements sent from fast-moving, yet
fuel-efficient trucks it would look like the following:</p><div class="codeBlockContainer_J+bg"><div style="color:#f8f8f2;background-color:#262833" class="codeBlockTitle_oQzk">Query 2 (QuestDB)</div><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar codeBlockWithTitle_ZT05"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">SELECT *</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">FROM readings</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">WHERE velocity &gt; 75.0 AND fuel_consumption &lt; 10.0</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">LIMIT -10;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Notice the LIMIT -10 clause in our query. It basically asks the database to
return the last 10 rows that correspond to the filter. Thanks to the implicit
ascending order based on the
<a href="https://questdb.io/docs/concept/designated-timestamp/" target="_blank" rel="noopener noreferrer">designated timestamp</a>
column, we also didn&#x27;t have to specify ORDER BY clause.</p><p>In TimescaleDB this query would look more verbose:</p><div class="codeBlockContainer_J+bg"><div style="color:#f8f8f2;background-color:#262833" class="codeBlockTitle_oQzk">Query 2 (ClickHouse and TimescaleDB)</div><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar codeBlockWithTitle_ZT05"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">SELECT *</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">FROM readings</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">WHERE velocity &gt; 75.0 AND fuel_consumption &lt; 10.0</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">ORDER BY time DESC</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">LIMIT 10;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Here, we had to specify descending ORDER BY and LIMIT clauses. When it comes to
ClickHouse, the query would look just like for TimescaleDB with the exception of
another column being used to store timestamps (<code>created_at</code> instead of <code>time</code>).</p><p>How do databases from our list deal with such query? Let&#x27;s measure and find out!</p><figure><img alt="A chart comparing hot LIMIT query execution times of QuestDB, ClickHouse and TimescaleDB - Query 2" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="283" src="/img/blog/2022-05-26/filter-with-limit-benchmark.png" width="734"><figcaption class="caption_-tGK">Hot LIMIT query execution times of QuestDB, ClickHouse and TimescaleDB - Query 2</figcaption></figure><p>This time, surprisingly or not, TimescaleDB does a better job than ClickHouse.
That&#x27;s because, just like QuestDB, TimescaleDB filters the data starting with
the latest time-based partitions and stops the filtering once enough rows are
found. We could also add an index on the <code>velocity</code> and <code>fuel_consumption</code>
columns, but it won&#x27;t change the result. That&#x27;s because TimescaleDB doesn&#x27;t use
the index and does a full scan instead for this query. Thanks to such behavior,
both QuestDB and TimescaleDB are significantly faster than ClickHouse in the
exercise.</p><p>Needless to say, that both TimescaleDB and ClickHouse are great pieces of
engineering. Your mileage may vary and performance of your particular
application depends on a large number of factors. So, as with any benchmark,
take our results with a grain of salt and make sure to measure things on your
own.</p><p>That should be it for our comparison and now it&#x27;s time to discuss the design
decisions behind our parallel SQL filter execution.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="how-does-it-work"></a>How does it work?<a class="hash-link" href="#how-does-it-work" title="Direct link to heading">#</a></h2><p>First, let&#x27;s quickly recap on QuestDB&#x27;s
<a href="https://questdb.io/docs/concept/storage-model/" target="_blank" rel="noopener noreferrer">storage model</a> to understand
why it supports efficient multi-core execution. The database has a column-based
append-only storage model. Data is stored in tables, with each column stored in
its own file or multiple files in case when the table is
<a href="https://questdb.io/docs/concept/partitions" target="_blank" rel="noopener noreferrer">partitioned</a> by the designated
timestamp.</p><figure><img alt="A diagram showing column file partitioning" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="301" src="/img/blog/2022-05-26/storage-format.png" width="757"><figcaption class="caption_-tGK">Column file layout example</figcaption></figure><p>When a SQL filter (think, WHERE clause) is executed, the database needs to scan
the files for the corresponding filtered columns. As you may have already
guessed, when the column files are large enough, or the query touches multiple
partitions, filtering the records on a single thread is inefficient. Instead,
the file(s) could be split into contiguous chunks (we call them &quot;page
frames&quot;). Then, multiple threads could execute the filter on each page
frame utilizing both CPU and disk resources in a much more optimal way.</p><figure><img alt="A diagram showing how parallel page frame scanning works" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="403" src="/img/blog/2022-05-26/how-filtering-works.png" width="682"><figcaption class="caption_-tGK">Parallel page frame scanning example</figcaption></figure><p>We already had this optimization in place for some of the analytical types of
queries, but not for full or partial table scan with a filter. So, that&#x27;s
basically what we&#x27;ve added in version 6.3.</p><p>As usual, there are edge cases and hidden reefs, so the implementation is not as
simple as it may sound. Say, what if your query has a filter and a LIMIT -10
clause, just like in our recent benchmark? Then the database should execute the
query in parallel, fetch the last 10 records and cancel the remaining page frame
filtering tasks, so that there is no useless filtering done by other worker
threads. A similar cancellation should take place in the face of a closed PG
Wire or HTTP connection or a query execution timeout. So, as you already saw in
the above comparison, we made sure to handle all of these edge cases. If you&#x27;re
interested in the implementation details, go check this lengthy
<a href="https://github.com/questdb/questdb/pull/1732" target="_blank" rel="noopener noreferrer">pull request</a>.</p><p>From the end user perspective, this optimization is always enabled and applies
to non-JIT and JIT-compiled filters. But how does it improve QuestDB&#x27;s
performance? Let&#x27;s find out!</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="speed-up-measurements"></a>Speed up measurements<a class="hash-link" href="#speed-up-measurements" title="Direct link to heading">#</a></h2><p>We&#x27;ll be using the same benchmark environment as above while using a slightly
different query to keep things simple:</p><div class="codeBlockContainer_J+bg"><div style="color:#f8f8f2;background-color:#262833" class="codeBlockTitle_oQzk">Query 3</div><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar codeBlockWithTitle_ZT05"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">SELECT count(*)</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">FROM readings</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">WHERE velocity &gt; 75.0 AND fuel_consumption &lt; 10.0;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>This query counts the total number of measurements sent from fast-moving, yet
fuel-efficient trucks.</p><p>First, we focus on cold execution time, i.e. situation when the column files
data is not in the OS page cache. Multi-threaded runs use QuestDB 6.3.1 while
single-threaded ones use 6.2.0 version of the database. That&#x27;s because JIT
compilation is only available in when parallel filter execution is on starting
from 6.3. The database configuration is kept default, except for the JIT being
disabled or enabled in the corresponding measurements. Also notice while this
given query supports JIT compilation, there is a number of
<a href="https://questdb.io/docs/concept/jit-compiler/#known-limitations" target="_blank" rel="noopener noreferrer">limitations</a>
for the types of the queries supported by the JIT compiler.</p><p>The below chart shows the cold execution times.</p><figure><img alt="A chart comparing cold query execution time improvements in QuestDB 6.3 - Query 3" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="273" src="/img/blog/2022-05-26/before-and-after-cold-runs.png" width="718"><figcaption class="caption_-tGK">Cold query execution time improvements in QuestDB 6.3 - Query 3</figcaption></figure><p>What&#x27;s that? Parallel filter execution is only two times faster. More than that,
enabled JIT-compiled filters have almost no effect on the end result. The thing
is that the disk is the bottleneck here.</p><p>Let&#x27;s try to make some sense out of these results. It takes around 30.7 seconds
for QuestDB 6.3 to execute the query when the data is only on disk. The query
engine has to scan two groups of column files, 182 partitions each having two 50
MB files. This gives us around 18.2 GB of on-disk data and around 592 MB/s disk
read rate. That&#x27;s lower than the configured maximum in our EBS volume, but we
should keep in mind allowed 10% fluctuations from the maximum throughput and,
what&#x27;s even more important,
<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html" target="_blank" rel="noopener noreferrer">individual limits</a>
for EBS-optimized instances. Our instance type is c5a.12xlarge and, according to
the AWS documentation, it&#x27;s limited with 594 MB/s on 128 KiB I/O which is very
close to our back of the envelope calculation.</p><p>Long story short, we&#x27;re maxing out the disk with multi-threaded query execution
while single-threaded execution time in version 6.2 stays the same. With this in
mind, further instance type and volume improvements would lead to better
performance.</p><p>Things should get even more exciting when it comes to hot execution scenario, so
there we go. In the next and all of the subsequent benchmark runs, we measure
the average hot execution time for the same query.</p><figure><img alt="A chart comparing hot query execution time improvements in QuestDB 6.3 - Query 3" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="281" src="/img/blog/2022-05-26/before-and-after-hot-runs.png" width="768"><figcaption class="caption_-tGK">Hot query execution time improvements in QuestDB 6.3 - Query 3</figcaption></figure><p>On this particular box, default QuestDB configuration leads to 16 threads being
used for the shared worker pool. So, both 6.3 runs execute the filter on
multiple threads speeding up the query when compared with the 6.2 runs. Another
observation is almost 1x difference between JIT-compiled and non-JIT filters on
6.3. So, even with many cores available to parallel query execution, it&#x27;s a good
idea to keep JIT compilation enabled.</p><p>You might have noticed a weird proportion in the above chart. Namely, the
difference between the execution times when JIT compilation is disabled. QuestDB
6.2 takes 30 seconds to finish the query with a single thread, while it takes
only roughly 1.3 seconds on 6.3. That&#x27;s 23x improvement and it&#x27;s impossible to
explain it only with parallel processing (remember, we run the filter on 16
threads). So, what may be the reason?</p><p>The thing is that parallel filter execution uses the same batch-based model as
JIT-compiled filter functions. This means that the filter is executed in a
tight, CPU-friendly loop while the resulting identifiers for the matching rows
are stored in an intermediate array. For instance, if we restrict parallel
filter engine to run on a single thread which is as simple as adding
<code>shared.worker.count=1</code> database setting, the query under test would execute in
around 13.5 seconds. Thus, in this very scenario batch-based filter processing
done on a single thread allows us to cut down 55% of the query execution time.
Obviously, multiple threads available to the engine let it run even faster.
Refer to this
<a href="https://questdb.io/blog/2022/01/12/jit-sql-compiler/#jit-based-filtering" target="_blank" rel="noopener noreferrer">blog post</a>
for more information on how we do batch-based filter processing in our SQL JIT
compiler.</p><p>There is one more optimization opportunity around the query we used here.
Namely, in case of queries that select only simple aggregate functions, like
<code>count(*)</code> or <code>max(*)</code>, and no column values we could push down the functions
into the filter loop. As an example, the filter loop will be incrementing the
<code>count(*)</code> function&#x27;s counter in-place rather than doing a more generic
accumulation of the filtered row identifiers. You could say that such queries
are rather niche, but they could be met in various dashboard applications. Thus,
it&#x27;s something that we definitely consider adding in future.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="whats-next"></a>What&#x27;s next?<a class="hash-link" href="#whats-next" title="Direct link to heading">#</a></h2><p>Certainly, parallel SQL filter execution introduced in 6.3 is not the final
point in our quest. As we&#x27;ve mentioned already, we have multi-threading in place
for aggregate queries, like SAMPLE BY or GROUP BY, but only for certain shapes
of them. Aggregate functions push-down is another potential optimization. So
stay tuned for further improvements!</p><p>As always, we encourage our users to try out 6.3.1 release on your QuestDB
instances and provide feedback in our
<a href="https://slack.questdb.io/" target="_blank" rel="noopener noreferrer">Slack Community</a>. You can also play with our
<a href="https://demo.questdb.io/" target="_blank" rel="noopener noreferrer">live demo</a> to see how fast it executes your queries.
And, of course, open-source contributions to our
<a href="https://github.com/questdb/questdb" target="_blank" rel="noopener noreferrer">project on GitHub</a> are more than welcome.</p></div><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/benchmark">benchmark</a><a class="margin-horiz--sm" href="/blog/tags/engineering">engineering</a><a class="margin-horiz--sm" href="/blog/tags/release">release</a><a class="margin-horiz--sm" href="/blog/tags/story">story</a><a class="margin-horiz--sm" href="/blog/tags/performance">performance</a></div></footer></article><div></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2022/05/31/questdb-release-6-4"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« QuestDB 6.4 Release Highlights</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2022/05/25/how-to-build-a-real-time-crypto-tracker-with-redpanda-and-questdb"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">How to build a real-time crypto tracker with Redpanda and QuestDB »</div></a></div></nav></div></main></div></div><div class="root_0lLS"><div class="cards_xeZk"><div class="root_R798 skinPrimary_JHOH"><svg width="76" height="76" viewBox="0 0 76 76" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="38" cy="38" r="38" fill="#1E1F27"></circle><path d="M56.99 18.792a.817.817 0 00-.117-.303c-.01-.02-.02-.05-.03-.069-.01-.02-.029-.029-.048-.049a.912.912 0 00-.137-.136l-.117-.088c-.02-.01-.03-.03-.05-.04-.029-.01-.068-.029-.107-.039a.85.85 0 00-.146-.049 1.075 1.075 0 00-.176-.019h-.147a1.15 1.15 0 00-.196.049c-.029.01-.068.01-.097.02L12.59 36.67a.979.979 0 00-.509 1.29c.098.216.264.401.48.5l16.07 7.556v15.025c0 .537.44.977.978.977a.964.964 0 00.831-.469l6.794-11.046 10.499 5.533a.974.974 0 001.408-.655l7.84-36.2v-.058c.01-.058.01-.107.019-.156 0-.059 0-.117-.01-.176zM29.413 44.208L15.376 37.6l36.326-15.68-22.289 22.288zm1.174 13.363V47.004l4.917 2.59-4.917 7.977zm16.92-3.87l-9.237-4.86-1.662-1.026-.068.118-5.289-2.786 23.1-23.12L47.508 53.7z" fill="#fff"></path></svg><h3 class="title_BHe0">문의하기</h3><p class="description_Bwvi">이메일을 입력하시면 소개자료를 보내드립니다.</p><div class="content_gAr2"><form class="root_teCd"><div><div class="inputs_0wQ8"><input type="email" class="input_cjQx input_a6pP" name="email" required="" pattern="^[a-zA-Z0-9.!#$%&amp;&#x27;*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$" placeholder="Email address" title="Email address should be valid"><button class="submit_poRs button_f7Ff button--tertiary_vtfp button--uppercase_ESEN" type="submit">보내기</button></div></div></form></div></div></div></div></div><footer class="root_JnvJ"><div class="content_-gfC center_S24y"><img alt="QuestDB logo" class="logo_JrwJ" src="/img/navbar/tp_brand.png" width="108" height="27"><div class="tagline_T1tH"><p>인프라관리부터 서비스운영까지 클라우드환경에 최적화된 클라우드 네이티브 플랫폼</p></div><div class="links_1SgP"></div></div><div class="border_PW0V"><div class="bottom_wPs3 center_S24y">Copyright © 2023 Gitple. All rights are reserved.</div></div></footer></div>
<script src="/assets/js/main.e53824dd.js" defer="defer"></script>
</body>
</html>
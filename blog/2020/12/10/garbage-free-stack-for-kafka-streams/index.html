<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3">
<meta httpequiv="x-ua-compatible" content="ie=edge">
<meta property="og:type" content="website">
<meta name="author" content="turpleio">
<meta name="generator" content="Docusaurus v2.0.0-alpha.75">
<link href="https://www.googletagmanager.com" rel="dns-prefetch">
<link href="https://www.google-analytics.com" rel="dns-prefetch">
<link rel="icon" href="/favicon.png">
<link rel="apple-touch-icon" href="/img/icons/apple-180x180.png" sizes="180x180">
<meta name="msapplication-config" content="/browserconfig.xml">
<link rel="sitemap" type="application/xml" href="/sitemap.xml">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=GTM-PVR7M2G"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","GTM-PVR7M2G",{anonymize_ip:!0})</script>
<link rel="search" type="application/opensearchdescription+xml" title="Turple: Cloud Native Platform" href="/opensearch.xml">
<link rel="manifest" href="/manifest.webmanifest">
<meta name="theme-color" content="#d14671">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#21222c">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Turple: Cloud Native Platform Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Turple: Cloud Native Platform Blog Atom Feed"><title data-react-helmet="true">Building a garbage-free network stack for Kafka streams | Turple: Cloud Native Platform</title><meta data-react-helmet="true" property="og:title" content="Building a garbage-free network stack for Kafka streams | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="description" content="Our database&#x27;s network stack handles multiple TCP connections on a single thread without garbage collection for reliably ingesting time series data."><meta data-react-helmet="true" name="twitter:description" content="Our database&#x27;s network stack handles multiple TCP connections on a single thread without garbage collection for reliably ingesting time series data."><meta data-react-helmet="true" property="og:description" content="Our database&#x27;s network stack handles multiple TCP connections on a single thread without garbage collection for reliably ingesting time series data."><meta data-react-helmet="true" name="twitter:title" content="Building a garbage-free network stack for Kafka streams | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="twitter:image:alt" content="Image for &quot;Building a garbage-free network stack for Kafka streams | Turple: Cloud Native Platform&quot;"><meta data-react-helmet="true" name="keywords" content="jdbc,postgres,tcp,kafka,garbage,java,timeseries,database"><meta data-react-helmet="true" property="og:image" content="https://turpleio.github.io/img/blog/2020-12-10/banner.jpg"><meta data-react-helmet="true" name="twitter:image" content="https://turpleio.github.io/img/blog/2020-12-10/banner.jpg"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><link rel="stylesheet" href="/assets/css/styles.4f6557e4.css">
</head>
<body itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="Turple: Cloud Native Platform">
<meta itemprop="description" content="Turple is a cloud native platform which can help you build and operate your services on cloud.">
<meta itemprop="url" content="https://turpleio.github.io">
<meta itemprop="logo" content="https://turpleio.github.io/img/favicon.png">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<nav class="navbar navbar_wBc8 navbar--light"><div class="navbar__inner inner_Y8Z6"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand brand_AtiA" href="/">QuestDB</a><a class="navbar__item navbar__link" href="/docs/">Docs</a></div><div class="navbar__items navbar__items--right"></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand brand_AtiA" href="/">QuestDB</a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/">Docs</a></li></ul></div></div></div></nav><div class="wrapper_DIJ0 blog-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--3"><div class="sidebar_q+wC thin-scrollbar"><h3 class="sidebarItemTitle_9G5K">Recent posts</h3><ul class="sidebarItemList_6T4b"><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/19/merry-questmas-gifts-2023">Merry Questmas! Here are your gifts for 2023...</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/13/using-prometheus-loki-grafana-monitor-questdb-kubernetes">Using Prometheus, Loki, and Grafana to monitor QuestDB in Kubernetes</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/30/full-table-scan-are-fast">Listen to Your CPU - Full-table Scans Are Fast</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/25/questdb-6.6.1-dynamic-commits">QuestDB 6.6.1 - Dynamic Commits</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/23/sql-extensions-time-series-data-questdb-part-ii">SQL Extensions for Time Series Data in QuestDB - Part II</a></li></ul></div></div><main class="col col--7"><article><header><h1 class="title_KBQu">Building a garbage-free network stack for Kafka streams</h1><time datetime="2020-12-10T00:00:00.000Z" class="date_A31P">December 10, 2020 · 12 min read</time><div class="avatar margin-vert--md"><a href="https://github.com/bluestreak01" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars.githubusercontent.com/bluestreak01" alt="Vlad Ilyushchenko"></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/bluestreak01" target="_blank" rel="noopener noreferrer">Vlad Ilyushchenko</a></h4><small class="avatar__subtitle">QuestDB Team</small></div></div></header><div class="markdown"><figure><img alt="Steam network of a Pennsylvania coal power plant" class="image_1-Fc image--title_Z46g" height="433" src="/img/blog/2020-12-10/banner.jpg" width="650"><figcaption class="caption_VLGg"> Photo by<a href="https://unsplash.com/photos/a_PDPUPuNZ8" target="_blank" rel="noopener noreferrer">Martin Adams</a> on <a href="https://unsplash.com" target="_blank" rel="noopener noreferrer">Unsplash</a> </figcaption></figure><p>Garbage collection is a type of automatic memory management that&#x27;s used in many
modern programming languages. The point of the garbage collector is to free up
memory used by objects which are no longer being used by a program. Although
it&#x27;s convenient for developers not to think about manually deallocating memory,
it can be a poisoned chalice that comes with several hard-to-predict downsides.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="how-can-garbage-collection-cause-performance-issues"></a>How can garbage collection cause performance issues?<a class="hash-link" href="#how-can-garbage-collection-cause-performance-issues" title="Direct link to heading">#</a></h2><p>Some garbage collectors completely halt the program&#x27;s execution to make sure no
new objects are created while it cleans up. To avoid these unpredictable
<strong>stop-the-world</strong> pauses in a program, incremental and concurrent garbage
collectors were developed. Although they provide great benefit in many cases,
there&#x27;s additional design choices that wind up back into development phases
where you have to indirectly deal with memory allocation.</p><p>Another issue is that garbage collectors themselves consume resources to decide
what to free up, which can add considerable overhead. Environments dealing with
real-time data are latency-sensitive and require high performance and
efficiency. In these applications, unpredictable halting behavior combined with
excess computation time or memory usage is not acceptable.</p><p>As we&#x27;re building an open source high-performance time series database, we have
these environments in mind and use design patterns and tooling that focuses on
writing code that&#x27;s efficient and reliable. When we need additional
functionality that would introduce performance knocks through standard
libraries, we can leverage our own implementations using native methods. This is
what prompted us to add a network stack that executes garbage-free.</p><p>This component bypasses Java&#x27;s native non-blocking IO with our own notification
system. This component&#x27;s job is to delegate tasks to worker threads and use
queues for events and TCP socket connections. The result is a new generic
network stack used to handle all incoming network connections. Following our new
support for Kafka, QuestDB&#x27;s network stack now ingests time series data from
Kafka topics reliably, without garbage collection.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="tcp-flow-control"></a>TCP flow control<a class="hash-link" href="#tcp-flow-control" title="Direct link to heading">#</a></h2><p>When we have multiple nodes on a network, there are usually disparities in their
performance in computing power and network bandwidth. Some nodes can read
incoming packets at different rates than others, or conversely, some nodes may
be able to send data at a different rate.</p><p>Let&#x27;s say we have a network with two nodes; a sender and a receiver. If the
sender can produce a lot more data than the receiver can read, the receiver is
likely to be overwhelmed. We&#x27;re in luck, though, as TCP uses a built-in flow
control protocol that acts as a pressure valve to ensure the receiver is not
affected by such cases.</p><p>Control flow manifests itself in different ways, depending on whether the
network socket is blocking or non-blocking. If the receiver can process data
faster than a sender, a non-blocking socket is identical to a blocking one, and
the receiver thread would be parked while no data is read. There&#x27;s not much
concern about this situation if it happens infrequently, but the park and unpark
is a waste of resources and CPU cycles if the receiver is under heavy load.</p><p>Let&#x27;s assume the receiver gets 0-length data on a non-blocking socket,
indicating no data has arrived from the sender; there are two options:</p><ol><li>Loop over socket reads continuously, waiting for data to arrive.</li><li>Stop looping and consult our parser on two possible actions to take: park for
more reads or switch to write.</li></ol><p>The first option is quite wasteful, so we went with the second approach. To park
socket read operations without blocking the thread, we need a dedicated system
for enqueuing and notifying us when the socket has more data to read. On the OS
kernel level, IO notification utilities exist as <code>epoll</code> on Linux, <code>kqueue</code> on
FreeBSD and OSX, and <code>select</code> on Windows. In QuestDB, we&#x27;ve implemented a
dispatcher that operates exactly as these IO notification systems for enqueuing
sockets, and we named it IODispatcher.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="java-nio-and-garbage-collection"></a>Java NIO and garbage collection<a class="hash-link" href="#java-nio-and-garbage-collection" title="Direct link to heading">#</a></h2><p>As you would expect from cross-platform languages, the IO Notification system
must be abstracted away to make application code portable. In Java, this
abstraction is called <code>Selector</code>. If we were to oversimplify a typical
interaction with the IO Notification system, it would essentially be a loop.
More often than not, this is an infinite loop, or rather, it executes
continuously during the server&#x27;s uptime.</p><p>Since we are on a quest to have everything garbage-free, Selector presents a
problem right away - the output of the selector is a set of keys, coming from a
concurrent hash map via an iterator. All of this allocates objects on every
iteration of the loop. If you are not careful, this allocation continues even
when the server is idling. The behavior is intrinsic to the Java Non-blocking
I/O (NIO) implementation and cannot be changed.</p><p>To send or receive data from the network, Java mandates ByteBuffer instances.
When looked at in a vacuum, ByteBuffer may seem like a reasonable abstraction.
But if we look closer, it&#x27;s easy to see it&#x27;s a bit confused. It is a concrete
class instead of an interface, meaning that the whole NIO is stuck with the
provided implementation. The API is inconsistent as the OS requires memory
pointers for send and receive methods, but ByteBuffer does not provide an
explicit semantic for each case. So how does ByteBuffer translate to a memory
pointer?</p><p>When your data is on the heap, there is a memory copy for each socket IO. When
ByteBuffer is direct, there is no copy, but there is an issue releasing memory
and general Java paranoia about language safety.</p><div class="codeBlockContainer_J+bg"><div style="color:#f8f8f2;background-color:#262833" class="codeBlockTitle_oQzk">Native Java socket write implementation</div><div class="codeBlockContent_csEI java"><div tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar codeBlockWithTitle_ZT05"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">/**</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain"> * /java.base/share/classes/sun/nio/ch/SocketChannelImpl.java</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain"> */</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">public int write(ByteBuffer buf) throws IOException {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    Objects.requireNonNull(buf);</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    writeLock.lock();</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    try {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        boolean blocking = isBlocking();</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        int n = 0;</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        try {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">            beginWrite(blocking);</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">            if (blocking) {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                do {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                    n = IOUtil.write(fd, buf, -1, nd);</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">            } else {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                n = IOUtil.write(fd, buf, -1, nd);</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">            }</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">            endWrite(blocking, n &gt; 0);</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">            if (n &lt;= 0 &amp;&amp; isOutputClosed)</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">                throw new AsynchronousCloseException();</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        }</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        return IOStatus.normalize(n);</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    } finally {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        writeLock.unlock();</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    }</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Considering the allocating nature of the Selector, that Java NIO libraries are a
layer above the OS, and how computationally expensive the overhead is with
ByteBuffer, we decided to go out on a limb and interact directly with the OS via
the Java Native Interface (JNI). This worked for QuestDB insofar as the API is
non-allocating outside of the normal bootstrap phase and lets us work with the
memory pointers directly.</p><div class="codeBlockContainer_J+bg"><div style="color:#f8f8f2;background-color:#262833" class="codeBlockTitle_oQzk">QuestDB&#x27;s JNI call for sending data to a socket</div><div class="codeBlockContent_csEI java"><div tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar codeBlockWithTitle_ZT05"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">/**</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain"> * /core/src/main/c/share/net.c</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain"> */</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">JNIEXPORT jint JNICALL Java_io_questdb_network_Net_send</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        (JNIEnv *e, jclass cl, jlong fd, jlong ptr, jint len) {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    const ssize_t n = send((int) fd, (const void *) ptr, (size_t) len, 0);</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    if (n &gt; -1) {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        return n;</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    }</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    if (errno == EWOULDBLOCK) {</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">        return com_questdb_network_Net_ERETRY;</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    }</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    return com_questdb_network_Net_EOTHERDISCONNECT;</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="questdbs-thread-model"></a>QuestDB&#x27;s thread model<a class="hash-link" href="#questdbs-thread-model" title="Direct link to heading">#</a></h2><p>Starting threads is expensive, and they&#x27;re more often than not just wrappers for
the connection state. QuestDB operates a fixed number of threads to isolate the
database instance to specific cores and reduce the overhead of starting and
stopping threads at runtime. The actual threads are encapsulated by a WorkerPool
class.</p><p>The worker pool&#x27;s idea is to have a simple list of &quot;jobs&quot; that all workers will
run all the time. Jobs themselves encapsulate &quot;piece of work&quot; and do not have
tight loops in them. Hence a job can simply return if IO is not available or the
queue is full or empty.</p><p>We have a notion of a &quot;synchronized job.&quot; It is different from the definition of
&quot;synchronized&quot; in Java in that the QuestDB&#x27;s thread never blocks. However,
synchronized jobs guarantee that only one thread can execute a job instance at
any moment in time.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="adding-an-io-notification-loop"></a>Adding an IO notification loop<a class="hash-link" href="#adding-an-io-notification-loop" title="Direct link to heading">#</a></h2><p>IODispatcher is QuestDB&#x27;s implementation of the IO Notification loop. We have
implemented <code>epoll</code>, <code>kqueue</code>, and <code>select</code>, so this works cross-platform. The
appropriate implementation is automatically chosen at runtime based on the OS.
The IODispatched API is message-driven via QuestDB&#x27;s implementation of
non-blocking and non-allocating queues. These queues are outside of the scope of
this article, but you can read about them in our community
<a href="/blog/2020/11/16/http-server-contribution">contribution from Alex Pelagenko</a>.</p><figure><img alt="A diagram of QuestDB&#x27;s IODispatcher" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="284" src="/img/blog/2020-12-10/iodispatcher-diagram.png" width="650"><figcaption class="caption_-tGK">IODispatcher and queues for events, interest, and disconnections</figcaption></figure><p>IODispatcher is a synchronized job in context of QuestDB&#x27;s thread model. It
consumes queues on the left and publishes to the queue on the right.
IODispatcher&#x27;s main responsibility is to deliver socket handles (individual
connection identifiers), that are ready for the IO to the worker threads.
Considering that socket handles are read or written to by one thread at a time
the underlying IO notification system works in ONESHOT mode. This means socket
handle is removed from the IO notification system while there is socket activity
and re-introduced back when activity tapers off. Interacting with the IO
notification system is expensive. Worker thread will only recurse back to the
IODispatcher for enqueueing if there has been zero data from the socket for the
set period of time, which we call hysteresis.</p><p>You can find source code of the implementations of the IODispatcher for
<a href="https://github.com/questdb/questdb/blob/master/core/src/main/java/io/questdb/network/IODispatcherLinux.java" target="_blank" rel="noopener noreferrer">epoll</a>
,
<a href="https://github.com/questdb/questdb/blob/master/core/src/main/java/io/questdb/network/IODispatcherOsx.java" target="_blank" rel="noopener noreferrer">kqueue</a>
and
<a href="https://github.com/questdb/questdb/blob/master/core/src/main/java/io/questdb/network/IODispatcherWindows.java" target="_blank" rel="noopener noreferrer">select</a>
on GitHub. Let&#x27;s take a look at the components in the diagram above with an
outline of their purpose:</p><p><strong>IO Event Queue:</strong> Single publisher, multiple consumer queue. It is the
recipient of the IO events from as in epoll, kqueue, select. The events are
socket handles and the type of operation the OS has associated them with, e.g.,
read or write. The IODispatcher plays the publisher role, and any number of
worker threads are the consumers.</p><p><strong>Interest Queue:</strong> Multiple publisher, single consumer queue. Worker threads
publish socket handles and operations to this queue when IO is unavailable,
e.g., socket read or write returns zero. The IODispatcher will enqueue the
socket handle for more reads or writes as defined by the operation.</p><p><strong>Disconnect Queue:</strong> Multiple publisher, single consumer queue. Worker threads
publish socket handles to this queue destined to be disconnected from the server
and have their resources reused by other connections. The worker thread does not
disconnect the socket by itself because multiple threads may attempt to access a
data structure that is not thread-safe.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="configuring-network-io"></a>Configuring network IO<a class="hash-link" href="#configuring-network-io" title="Direct link to heading">#</a></h3><p>We disregarded ByteBuffer for not being an interface, so it would only be fair
for us to have interfaces in key places. One of these places is configuration,
which provides IODispatcher with basics such as:</p><ul><li>The IP address of the network interface</li><li>Port to bind to</li><li>Bias</li><li>Buffer sizes</li><li>Network facade</li><li>Clock facade</li><li>Connection context factory</li></ul><p>It&#x27;s necessary to explain bias here, which might not be so obvious. When the TCP
connection is first accepted, it is enqueued for IO right away. The bias
provides an expectation of the initial operation of a connection, such as read
or write. For example, most TCP protocols would have &#x27;read bias&#x27;, which means
that connecting clients will have to send data before the server replies
anything. You can probably think of a protocol that requires the server to
respond first before the client sends anything - in this case, the bias will be
&#x27;write&#x27;.</p><p>Network &amp; clock facades have static implementations for production runtime, but
for tests, they can be both spot-implemented to simulate OS failures and produce
stable timestamps.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="connection-context"></a>Connection Context<a class="hash-link" href="#connection-context" title="Direct link to heading">#</a></h3><p>Connection context is a Java object that encapsulates the connection state,
which is protocol-specific. It is stored together with the socket handle and
managed by IODispatcher via the context factory. We talked a little about the
QuestDB thread model and that workers are very likely to execute the same job
instance simultaneously unless the job is synchronized. In this scenario, the
only place a job can reliably store a state is the connection context.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="protocol-parsers"></a>Protocol Parsers<a class="hash-link" href="#protocol-parsers" title="Direct link to heading">#</a></h3><p>Protocol parsers are used by worker threads to make sense of the incoming data.
QuestDB has a convention that all protocol parsers must be streaming, e.g., they
never hold on to the entirety of the data sent over the network. These parsers
are typically state machines, with state held in connection context. This type
of parser allows fully real-time ingestion of large data segments, such as text
file import.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="worker-threads"></a>Worker Threads<a class="hash-link" href="#worker-threads" title="Direct link to heading">#</a></h3><p>Worker threads are required to consume the IO event queue. We already mentioned
that the IODispatcher neither reads nor writes connected sockets itself. This is
the responsibility of the worker threads.</p><p>Worker threads almost always use protocol parsers to interpret socket data. They
must continue to work with the socket until the socket cannot read or write
anymore. In which case, the worker threads either express &quot;interest&quot; in further
socket interaction or disconnects the socket. In this situation, IODispatcher is
not on the execution path during most of the socket interaction.</p><p>Threads will often use hysteresis, which means that they busy-spin socket read
or write operations until either the socket responds or the number of iterations
has elapsed. This is sometimes useful when a remote socket is able to respond
with minimum delay.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="take-a-look"></a>Take a look<a class="hash-link" href="#take-a-look" title="Direct link to heading">#</a></h2><p>In this article, we&#x27;ve covered our approach to implementing non-blocking IO
using what we think is a nice solution that&#x27;s garbage-free. Kafka Connect
support is now available since version 5.0.5. Our new network stack ingests time
series data from Kafka topics reliably from multiple TCP connections on a single
thread without garbage collection and the QuestDB source is open to
<a href="https://" target="_blank" rel="noopener noreferrer">browse on GitHub</a>. If you like this content and our approach to
non-blocking and garbage-free IO, or if you know of a better way to approach
what we built, we&#x27;d love to know your thoughts! Feel free to share your feedback
<a href="https://" target="_blank" rel="noopener noreferrer">in our Slack Community</a>.</p></div><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/kafka">kafka</a><a class="margin-horiz--sm" href="/blog/tags/postgres">postgres</a><a class="margin-horiz--sm" href="/blog/tags/architecture">architecture</a><a class="margin-horiz--sm" href="/blog/tags/engineering">engineering</a></div></footer></article><div></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2021/01/11/sql-extensions-for-timeseries-data"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« SQL Extensions for Time-Series Data in QuestDB</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2020/11/26/why-timeseries-data"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">What is time-series data, and why are we building a time-series database (TSDB)? »</div></a></div></nav></div></main></div></div><div class="root_0lLS"><div class="cards_xeZk"><div class="root_R798 skinPrimary_JHOH"><svg width="76" height="76" viewBox="0 0 76 76" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="38" cy="38" r="38" fill="#1E1F27"></circle><path d="M56.99 18.792a.817.817 0 00-.117-.303c-.01-.02-.02-.05-.03-.069-.01-.02-.029-.029-.048-.049a.912.912 0 00-.137-.136l-.117-.088c-.02-.01-.03-.03-.05-.04-.029-.01-.068-.029-.107-.039a.85.85 0 00-.146-.049 1.075 1.075 0 00-.176-.019h-.147a1.15 1.15 0 00-.196.049c-.029.01-.068.01-.097.02L12.59 36.67a.979.979 0 00-.509 1.29c.098.216.264.401.48.5l16.07 7.556v15.025c0 .537.44.977.978.977a.964.964 0 00.831-.469l6.794-11.046 10.499 5.533a.974.974 0 001.408-.655l7.84-36.2v-.058c.01-.058.01-.107.019-.156 0-.059 0-.117-.01-.176zM29.413 44.208L15.376 37.6l36.326-15.68-22.289 22.288zm1.174 13.363V47.004l4.917 2.59-4.917 7.977zm16.92-3.87l-9.237-4.86-1.662-1.026-.068.118-5.289-2.786 23.1-23.12L47.508 53.7z" fill="#fff"></path></svg><h3 class="title_BHe0">문의하기</h3><p class="description_Bwvi">이메일을 입력하시면 소개자료를 보내드립니다.</p><div class="content_gAr2"><form class="root_teCd"><div><div class="inputs_0wQ8"><input type="email" class="input_cjQx input_a6pP" name="email" required="" pattern="^[a-zA-Z0-9.!#$%&amp;&#x27;*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$" placeholder="Email address" title="Email address should be valid"><button class="submit_poRs button_f7Ff button--tertiary_vtfp button--uppercase_ESEN" type="submit">보내기</button></div></div></form></div></div></div></div></div><footer class="root_JnvJ"><div class="content_-gfC center_S24y"><img alt="QuestDB logo" class="logo_JrwJ" src="/img/navbar/tp_brand.png" width="108" height="27"><div class="tagline_T1tH"><p>인프라관리부터 서비스운영까지 클라우드환경에 최적화된 클라우드 네이티브 플랫폼</p></div><div class="links_1SgP"><div class="category_Ptbh"><span class="title_HpoE">Product</span><ul class="items_Lw7J"><li><a class="link_vx7p" href="/cloud/">Cloud</a></li><li><a class="link_vx7p" href="/enterprise/">Enterprise</a></li><li><a class="link_vx7p" href="/pricing/">Pricing</a></li><li><a class="link_vx7p" href="/use-cases/">Use Cases</a></li><li><a class="link_vx7p" href="/customers/">Customers</a></li><li><a class="link_vx7p" href="https://github.com/orgs/questdb/projects/1/views/5" rel="noopener noreferrer" target="_blank">Roadmap</a></li></ul></div><div class="category_Ptbh"><span class="title_HpoE">Developers</span><ul class="items_Lw7J"><li><a class="link_vx7p" href="/docs/">Docs</a></li><li><a class="link_vx7p" href="/blog/tags/tutorial/">Tutorials</a></li><li><a class="link_vx7p" href="/blog/">Blog</a></li><li><a class="link_vx7p" href="https://">Discussions</a></li><li><a class="link_vx7p" href="https://">Join Slack</a></li><li><a class="link_vx7p" href="/community/">Swag</a></li></ul></div><div class="category_Ptbh"><span class="title_HpoE">Company</span><ul class="items_Lw7J"><li><a class="link_vx7p" href="/about-us/">About us</a></li><li><a class="link_vx7p" href="/careers/">Careers</a></li></ul></div></div></div><div class="border_PW0V"><div class="bottom_wPs3 center_S24y">Copyright © 2023 Gitple. All rights are reserved.</div></div></footer></div>
<script src="/assets/js/main.db1fdb94.js" defer="defer"></script>
</body>
</html>
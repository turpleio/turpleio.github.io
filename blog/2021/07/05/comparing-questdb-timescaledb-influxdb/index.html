<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3">
<meta httpequiv="x-ua-compatible" content="ie=edge">
<meta property="og:type" content="website">
<meta name="author" content="turpleio">
<meta name="generator" content="Docusaurus v2.0.0-alpha.75">
<link href="https://www.googletagmanager.com" rel="dns-prefetch">
<link href="https://www.google-analytics.com" rel="dns-prefetch">
<link rel="icon" href="/favicon.png">
<link rel="apple-touch-icon" href="/img/icons/apple-180x180.png" sizes="180x180">
<meta name="msapplication-config" content="/browserconfig.xml">
<link rel="sitemap" type="application/xml" href="/sitemap.xml">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=GTM-PVR7M2G"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","GTM-PVR7M2G",{anonymize_ip:!0})</script>
<link rel="search" type="application/opensearchdescription+xml" title="Turple: Cloud Native Platform" href="/opensearch.xml">
<link rel="manifest" href="/manifest.webmanifest">
<meta name="theme-color" content="#d14671">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#21222c">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Turple: Cloud Native Platform Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Turple: Cloud Native Platform Blog Atom Feed"><title data-react-helmet="true">Comparing InfluxDB, TimescaleDB, and QuestDB timeseries databases | Turple: Cloud Native Platform</title><meta data-react-helmet="true" property="og:title" content="Comparing InfluxDB, TimescaleDB, and QuestDB timeseries databases | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="description" content="A high-level overview of timeseries databases to compare features, functionality, maturity, and performance."><meta data-react-helmet="true" name="twitter:description" content="A high-level overview of timeseries databases to compare features, functionality, maturity, and performance."><meta data-react-helmet="true" property="og:description" content="A high-level overview of timeseries databases to compare features, functionality, maturity, and performance."><meta data-react-helmet="true" name="twitter:title" content="Comparing InfluxDB, TimescaleDB, and QuestDB timeseries databases | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="twitter:image:alt" content="Image for &quot;Comparing InfluxDB, TimescaleDB, and QuestDB timeseries databases | Turple: Cloud Native Platform&quot;"><meta data-react-helmet="true" name="keywords" content="timeseries,influxdb,timescale,questdb,comparison"><meta data-react-helmet="true" property="og:image" content="https://turpleio.github.io/img/blog/shared/og-influxdb-timescaledb.png"><meta data-react-helmet="true" name="twitter:image" content="https://turpleio.github.io/img/blog/shared/og-influxdb-timescaledb.png"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><link rel="stylesheet" href="/assets/css/styles.4f6557e4.css">
</head>
<body itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="Turple: Cloud Native Platform">
<meta itemprop="description" content="Turple is a cloud native platform which can help you build and operate your services on cloud.">
<meta itemprop="url" content="https://turpleio.github.io">
<meta itemprop="logo" content="https://turpleio.github.io/img/favicon.png">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<nav class="navbar navbar_wBc8 navbar--light"><div class="navbar__inner inner_Y8Z6"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand brand_AtiA" href="/">QuestDB</a></div><div class="navbar__items navbar__items--right"></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand brand_AtiA" href="/">QuestDB</a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"></ul></div></div></div></nav><div class="wrapper_DIJ0 blog-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--3"><div class="sidebar_q+wC thin-scrollbar"><h3 class="sidebarItemTitle_9G5K">Recent posts</h3><ul class="sidebarItemList_6T4b"><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/19/merry-questmas-gifts-2023">Merry Questmas! Here are your gifts for 2023...</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/13/using-prometheus-loki-grafana-monitor-questdb-kubernetes">Using Prometheus, Loki, and Grafana to monitor QuestDB in Kubernetes</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/30/full-table-scan-are-fast">Listen to Your CPU - Full-table Scans Are Fast</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/25/questdb-6.6.1-dynamic-commits">QuestDB 6.6.1 - Dynamic Commits</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/23/sql-extensions-time-series-data-questdb-part-ii">SQL Extensions for Time Series Data in QuestDB - Part II</a></li></ul></div></div><main class="col col--7"><article><header><h1 class="title_KBQu">Comparing InfluxDB, TimescaleDB, and QuestDB timeseries databases</h1><time datetime="2021-07-05T00:00:00.000Z" class="date_A31P">July 5, 2021 · 14 min read</time><div class="avatar margin-vert--md"><a href="https://github.com/Yitaek" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars.githubusercontent.com/Yitaek" alt="Yitaek Hwang"></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/Yitaek" target="_blank" rel="noopener noreferrer">Yitaek Hwang</a></h4><small class="avatar__subtitle">Guest</small></div></div></header><div class="markdown"><figure><img alt="TimescaleDB logo, QuestDB logo, InfluxDB logo" class="image_1-Fc" height="467" src="/img/blog/2021-07-05/banner.png" width="650"></figure><p>This comparison comes from <a href="https://yitaek.medium.com/" target="_blank" rel="noopener noreferrer">Yitaek Hwang</a>, who has
put together his thoughts on the features and functionality you should look out
for when evaluating timeseries databases. This overview takes a look at QuestDB,
TimescaleDB, and InfluxDB for features, functionality, maturity, and
performance.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="why-timeseries-databases-are-popular"></a>Why timeseries databases are popular<a class="hash-link" href="#why-timeseries-databases-are-popular" title="Direct link to heading">#</a></h2><p>We&#x27;re living in
<a href="https://www.protocol.com/manuals/the-new-database/golden-age-databases-last" target="_blank" rel="noopener noreferrer">the golden age of databases</a>,
as money flows into the industry at historical rates (e.g.,
<a href="https://www.snowflake.com/" target="_blank" rel="noopener noreferrer">Snowflake</a>, <a href="https://www.mongodb.com/" target="_blank" rel="noopener noreferrer">MongoDB</a>,
<a href="https://www.cockroachlabs.com/" target="_blank" rel="noopener noreferrer">Cockroach Labs</a>, <a href="https://neo4j.com/" target="_blank" rel="noopener noreferrer">Neo4j</a>).
If the debate between relational vs. non-relational or online analytical
processing (OLAP) vs. online transaction processing (OLTP) ruled the past
decade, a new type of database has been steadily growing in popularity.
According to <a href="https://db-engines.com/en/" target="_blank" rel="noopener noreferrer">DB-Engines</a>, an initiative to collect
and present information on database management systems, timeseries databases are
the fastest growing sector since 2020:</p><figure><img alt="A chart ranking database type by popularity with timeseries databases shown as a clear leader" class="image_Pw1y margin_Rc0b shadow_7z-4" height="591" src="/img/blog/2021-07-05/timeseries-popularity.png" width="770"></figure><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="why-use-a-timeseries-database"></a>Why use a timeseries database?<a class="hash-link" href="#why-use-a-timeseries-database" title="Direct link to heading">#</a></h3><p>Timeseries databases (TSDB) are databases optimized to ingest, process, and
store timestamped data. Such data may include metrics from servers and
applications, readings from IoT sensors, user interaction on a website or an
app, or trading activity on financial markets.</p><p>The following properties usually characterize timeseries workloads:</p><ul><li>Each data point includes a timestamp used to index, aggregate, and sample.
This data can also be multi-dimensional and correlated.</li><li>High write speed (ingestion) is preferred to capture data at high frequencies.</li><li>Summarized view of the data (e.g., downsampled or aggregated view, trend
lines) may provide more insight than a single data point. For example, given
network unreliability or outliers in sensor readings, we may set alerts when
some average value over time exceeds a threshold rather than doing so on a
single data point.</li><li>Analyzing the data usually requires accessing it over some window of time
(e.g., give me the click rate data over the past week).</li></ul><p>While other databases can also handle time-series data to a certain extent,
TSDBs are designed with the above properties to handle data ingestion,
compression, and aggregation over time more efficiently. So as the demand for
time series data continues to explode on the heels of cloud computing, IoT, and
machine learning, how should architects go about choosing a TSDB? This article
will compare popular TSDBs and new players in the market to help you decide.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="influxdb-details"></a>InfluxDB details<a class="hash-link" href="#influxdb-details" title="Direct link to heading">#</a></h2><p>First released in 2013, InfluxDB is the market leader in the TSDB space,
overtaking Graphite and OpenTSDB that came before. As with many OSS database
companies, <a href="https://www.influxdata.com/" target="_blank" rel="noopener noreferrer">InfluxDB</a> licensed with MIT License for
a single node, with paid-plans available for InfluxDB Cloud and InfluxDB
enterprise that provide clustering and other production-ready features.</p><figure><img alt="A table showing the current popularity of timeseries databases as shown by db-engines.com" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="591" src="/img/blog/2021-07-05/db-engines-ranking.png" width="770"><figcaption class="caption_-tGK">Image Credit: DB-engines</figcaption></figure><p>Before the InfluxDB 2.x release in 2019, the InfluxDB Platform consisted of the
TICK stack: Telegraf (agent for collecting and reporting metrics), InfluxDB,
Chronograf (interface to query data from InfluxDB), and Kapacitor (real-time
streaming data processing engine). As seen in the diagram below, InfluxDB 1.x
primarily focused on time series data from servers and web applications. Before
Prometheus came along to take market share in this space, InfluxDB had the most
significant community and integrations to collect, store, and view application
metrics.</p><figure><img alt="A diagram describing IndluxDB architecture including Telegraf, Chronograf, and Kapacitor." class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="591" src="/img/blog/2021-07-05/influx-architecture.png" width="770"><figcaption class="caption_-tGK">Image Credit: Influxdata</figcaption></figure><p>InfluxDB 2.x essentially simplified the architecture to bundle the TICK stack to
a single binary as well as introducing new features to make collecting (e.g.
native Prometheus plugin), organizing (e.g., organizations and buckets), and
visualizing (e.g., Data Explorer) data with its Flux language.</p><p>To understand how InfluxDB works, we need to grasp the following key concepts:</p><ul><li><strong>Data model (tagset model)</strong>: Besides the timestamp field, each data element
consists of various tags (optional, indexed metadata fields), fields (key and
value), and measurement (container for tags, fields, and timestamps). The
example below takes census data from bees and ants, collected in Klamath and
Portland by scientists Anderson and Mullen. Here location and scientist are
tags, falling under the census measurement with field/value pair for bees and
ants.</li></ul><figure><img alt="An example table created from ingesting data in InfluxDB line protocol" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="591" src="/img/blog/2021-07-05/influx-schema.png" width="770"><figcaption class="caption_-tGK">Image Credit: Influxdata</figcaption></figure><ul><li><strong>Data schema (TSM &amp; TSI):</strong> are data elements stored in time-structured merge
tree (TSM) and time series index (TSI) files. TSM can be thought of a
<a href="https://docs.influxdata.com/influxdb/v1.8/concepts/storage_engine/" target="_blank" rel="noopener noreferrer">LSM tree with write-ahead log (WAL) and read-only files similar to SSTables</a>
that are sorted and compressed. TSI is an index on files on disk that InfluxDB
memory maps to take advantage of the
<a href="https://docs.influxdata.com/influxdb/v1.8/concepts/time-series-index/" target="_blank" rel="noopener noreferrer">Least Recently Used (LRU)</a>
the memory of the operating system to help with datasets with high cardinality
(i.e., large elements in a set).</li><li><strong>Flux scripting language:</strong> a domain-specific language developed by InfluxDB
to help with querying data. Flux has an SQL package to help query from SQL
data sources as well.</li></ul><p>Most notably, InfluxDB does not enforce a schema before ingesting data. Instead,
the schema automatically created from the input data, inferred from the tags and
fields. This NoSQL-like experience is both InfluxDB&#x27;s strength and weakness. For
datasets with relatively low cardinality that naturally fit this tagset model
(e.g., most infrastructure and application metrics, some IoT data, some
financial data), InfluxDB is extremely easy to get started without worrying
about designing schemas or indexes. It also shines in use cases where the goal
is to create digital models of physical assets. For example, in IoT, one may
need to create a digital twin to represent a collection of sensors and ingest
organized data.</p><figure><img alt="An illustration showing the indexed and non-indexed parts of an InfluxDB line protocol message" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="591" src="/img/tutorial/2021-07-05/tagset-model.jpeg" width="770"><figcaption class="caption_-tGK">Image Credit: Influxdata</figcaption></figure><p>On the other hand, being &quot;schemaless&quot; can be a disadvantage when the dataset
requires indexes on continuous fields (i.e., numerics are not supported by
InfluxDB as tags must be strings) or data validation. Also, since tags are
indexed, if tags are frequently changing (e.g., use cases where metadata may
change after initial ingestion), relying on InfluxDB to infer the schema may be
costly.</p><p>Finally, InfluxDB&#x27;s decision to create its custom functional data scripting
language (Flux) presents another layer of complexity to mastering this
ecosystem. The team at InfluxDB
<a href="https://www.influxdata.com/blog/why-were-building-flux-a-new-data-scripting-and-query-language/" target="_blank" rel="noopener noreferrer">points to two motivations</a>
to move away from SQL-like InfluxQL to Flux:</p><ul><li>Timeseries data line up with a flow-based functional processing model where a
stream of data is transformed from one output to the next. The relational
algebra model that SQL supports does not handle such chaining of operations
and functions as well.</li><li>InfluxDB wanted first-class support for common operations with time series
data (e.g., exponential moving average) that is not part of the SQL standard.</li></ul><p>Flux syntax requires some effort to adapt, especially if you&#x27;re looking for
simple SQL queries or not looking to learn yet another new language. Still
considering the large community and
<a href="https://www.influxdata.com/products/integrations/" target="_blank" rel="noopener noreferrer">integrations</a> that InfluxDB
has assembled, some of the advantages of Flux start to materialize, especially
when combined with built-in dashboards.</p><figure><img alt="A screenshot showing the InfluxDB data explorer" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="591" src="/img/blog/2021-07-05/influx-schema-explorer.png" width="770"><figcaption class="caption_-tGK">Image Credit: Influxdata</figcaption></figure><p>Overall, InfluxDB is a great choice if the time series data fit nicely with the
tagset model. The main use case seems to be geared towards
infrastructure/application monitoring, but as the clear market leader in this
space, InfluxDB also seamlessly integrates with popular data sources.</p><ul><li><strong>Pros:</strong> schemaless ingestion, huge community, integrations with popular
tools</li><li><strong>Cons:</strong> datasets with high-cardinality, custom querying/processing language</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="timescaledb-details"></a>TimescaleDB details<a class="hash-link" href="#timescaledb-details" title="Direct link to heading">#</a></h2><p>Whereas InfluxDB opted to build a new database and custom language from scratch,
on the other end of the spectrum is <a href="https://www.timescale.com/" target="_blank" rel="noopener noreferrer">TimescaleDB</a>.
TimescaleDB is built on top of PostgreSQL and adds an intermediary layer called
<a href="https://docs.timescale.com/timescaledb/latest/overview/core-concepts/hypertables-and-chunks/" target="_blank" rel="noopener noreferrer">hypertables</a>
that chunks data into multiple underlying tables while abstracting it as a
single, large table for interacting with the data.</p><figure><img alt="A diagram showing TimescaleDB and InfluxDB on two ends of the SQL vs NoSQL spectrum." class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="591" src="/img/blog/2021-07-05/sql-v-nosql.jpeg" width="770"><figcaption class="caption_-tGK">Image Credit: TimescaleDB</figcaption></figure><p>PostgreSQL compatibility is TimescaleDB&#x27;s biggest selling point. TimescaleDB
fully supports all of the SQL features (e.g., joins, secondary and partial
indexes) as well as popular extensions like <a href="https://postgis.net/" target="_blank" rel="noopener noreferrer">PostGIS</a>.
More importantly, TimescaleDB inherits decades of knowledge from both developers
running SQL queries as well as database and sysadmins running PostgreSQL at
scale. Since TimescaleDB can be treated as a PostgreSQL extension, cloud-managed
options (e.g.
<a href="https://azure.microsoft.com/en-us/updates/timescaledb-for-azure-database-for-postgresql-to-power-iot-and-time-series-workloads/" target="_blank" rel="noopener noreferrer">Azure Database for PostgreSQL</a>,
<a href="https://help.aiven.io/en/articles/1752157-getting-started-with-timescaledb-in-aiven-for-postgresql" target="_blank" rel="noopener noreferrer">Aiven</a>)
aside from TimescaleDB&#x27;s own managed offering are readily available, not to
mention the myriad of self-managed options on VMs or containers.</p><figure><img alt="A list of the most popular programming languages as reported by the Stack Overflow Developer Survey 2020" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="591" src="/img/blog/2021-07-05/popular-languages.png" width="770"><figcaption class="caption_-tGK">Image Credit: Stack Overflow</figcaption></figure><p>Because TimescaleDB began as an IoT platform, where they used InfluxDB at first,
to store their sensor data, its features bode well for IoT time series data
which is often &#x27;bursty&#x27;, frequently out of order due to network unreliability,
and characterized by high cardinality:</p><ul><li><p><strong>Hypertables:</strong> TimescaleDB
<a href="https://docs.timescale.com/timescaledb/latest/overview/core-concepts/hypertables-and-chunks/#partitioning-in-hypertables-with-chunks" target="_blank" rel="noopener noreferrer">partitions its hypertables into chunks</a>
based on a time column as well as other &quot;spatial&quot; values such as a device uid,
location identifier, or a stock symbol. Users can configure these chunks to
hold the most recent data in memory, asynchronously compress and re-order data
by the time column to disk (instead of ingestion time), and replicate or
migrate transactionally across nodes.</p></li><li><p><strong>Continuous Aggregation:</strong> TimescaleDB also supports
<a href="https://docs.timescale.com/timescaledb/latest/overview/core-concepts/continuous-aggregates/" target="_blank" rel="noopener noreferrer">continuous aggregation of data</a>
to make computing key metrics like hourly average, minimum, and maximum values
fast. IoT data is often more useful in aggregate (e.g., give me the average
temperature between 3 pm and 4 pm vs. what was the exact temperature at 3 pm),
so not needing to scan a huge amount of data on every aggregate query can help
create performant dashboards or analyses.</p></li><li><p><strong>Data Retention:</strong> Large deletes are a costly operation in traditional
relational databases. However, since TimescaleDB stores data in chunks, it
<a href="https://docs.timescale.com/timescaledb/latest/overview/core-concepts/data-retention/#data-retention" target="_blank" rel="noopener noreferrer">provides a <code>drop_chunks</code> feature</a>
to quickly drop old data without the same overhead. Since the relevance of old
data diminishes over time, TimescaleDB can be used with a longer-term storage
(e.g., OLAP or blob storage) to move older data to save disk space and keep
performance high on newer data.</p></li></ul><p>As for performance, TimescaleDB has a comprehensive post detailing insert and
read latency metrics comparing TimescaleDB version 1.7.1 and InfluxDB 1.8.0
(both OSS versions) using the
<a href="https://github.com/timescale/tsbs" target="_blank" rel="noopener noreferrer">Time Series Benchmark Suite</a> (TSBS). Both
databases now have 2.x versions, so this analysis may be a bit outdated, but the
results show superior performance for TimescaleDB as data cardinality grows
(~3.5x performance).</p><figure><img alt="Benchmark results showing TimescaleDB performance versus InfluxDB on ingestion rates." class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="591" src="/img/blog/2021-07-05/influx-versus-timescale.png" width="770"><figcaption class="caption_-tGK">Image Credit: TimescaleDB</figcaption></figure><p>TimescaleDB team points to InfluxDB&#x27;s log-structured merge tree-based system
(TSI) versus TimescaleDB&#x27;s B-tree indexing method for the root cause. However,
the takeaway here isn&#x27;t necessarily that TimescaleDB is superior to InfluxDB in
terms of performance. Performance benchmarks are opinionated and heavily
influenced by the data model, hardware, and configuration. Instead, this result
shows that TimescaleDB may be better suited for IoT use cases where data
cardinality is high (e.g., give me average power usage for device X out of the
fleet of 10 million devices).</p><p>For an in-depth comparison between the two DBs, have a look at Timescale&#x27;s own
<a href="https://blog.timescale.com/blog/timescaledb-vs-influxdb-for-time-series-data-timescale-influx-sql-nosql-36489299877/" target="_blank" rel="noopener noreferrer">TimescaleDB vs. InfluxDB comparison</a>.</p><p>Overall, TimescaleDB is an excellent fit for teams looking for a significant
performance boost without heavy refactoring to migrate off their existing SQL
databases. Even though TimescaleDB is still relatively new (first release in
2017), the decision to build on top of PostgreSQL has boosted its adoption
numbers to reach the top 5 TSDBs. Anecdotally, my previous IoT startup also used
TimescaleDB is an intermediate data store to quickly pull aggregate metrics
spanning several months and move old data to long-term storage. Since we were
already running PostgreSQL on our Kubernetes cluster, installing TimescaleDB and
migrating our workload was a simple task.</p><ul><li><strong>Pros:</strong> PostgreSQL-compatibility, scales well with data cardinality, various
deployment models available</li><li><strong>Cons:</strong> fixed schema (adds a bit of complexity and data transformation
effort before ingestion)</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="questdb-details"></a>QuestDB details<a class="hash-link" href="#questdb-details" title="Direct link to heading">#</a></h2><p>For those looking to take advantage of the flexibility of InfluxDB line protocol
and the familiarity of PostgreSQL, a newer time series database may satisfy both
requirements without sacrificing performance. QuestDB (YC S20) is an open-source
TSDB written in Java and C++ that now ranks in the top 15
<a href="https://news.ycombinator.com/item?id=23975807" target="_blank" rel="noopener noreferrer">although it launched less than a year ago</a>.
Underneath the hood,
<a href="/docs/concept/storage-model">QuestDB utilizes memory-mapped files</a> to support
fast read and writes before data is committed to disk.</p><figure><img alt="A diagram showing how QuestDB ingesting schema-agnostic InfluxDB line protocol and relational data" class="image_Pw1y margin_Rc0b shadow_7z-4" height="591" src="/img/blog/2021-07-05/questdb-influxdb-postgres-join.png" width="770"></figure><p>By building the database from scratch with Java and C++, the QuestDB team
focused on three things:</p><ul><li><strong>Performance:</strong> Solving the ingestion bottleneck, especially around high
cardinality datasets. It also supports fast data retrieval by storing
time-partitioned data always in order (via shuffling in memory) and only
analyzing requested columns/partitions instead of the entire table. Finally,
QuestDB applies SIMD instructions to parallelize operations.</li><li><strong>Compatibility:</strong> QuestDB supports InfluxDB line protocol, PostgreSQL wire,
REST API and CSV upload to ingest data. Users accustomed to other TSDBs can
easily port over their existing applications without a significant rewrite.</li><li><strong>Querying via SQL:</strong> Despite supporting multiple ingestion mechanisms,
QuestDB uses SQL as the query language, so there&#x27;s no need to learn a
domain-specific language like Flux.</li></ul><p>In terms of performance, QuestDB
<a href="/blog/2021/05/10/questdb-release-6-0-tsbs-benchmark">recently posted a blog post showing benchmark results</a>
that achieved write speeds up to 1.4 million rows per second. QuestDB team used
the TSBS benchmark with the <code>cpu-only</code> use case using up to 14 works on
<code>m5.8xlarge</code> instance on AWS (<strong>NOTE:</strong> the 1.4 million number is from using AMD
Ryzen5 processor).</p><p>For datasets with high cardinality (&gt;10 million), QuestDB also outperformed
other TSDBs with peak ingestion throughput of 904k rows/sec and sustaining about
640k row/secs at 10 million devices using four threads on <code>m5.8xlarge</code> instance
with Intel Xeon CPUs. When QuestDB ran the same benchmark on AMD Ryzen 3970X,
QuestDB showed over a million rows/sec ingestion throughput.</p><figure><img alt="A chart showing high-cardinality ingestion performance of InfluxDB, TimescaleDB, and ClickHouse versus QuestDB" class="image_Pw1y margin_Rc0b shadow_7z-4" height="591" src="/img/blog/2021-07-05/maximum-throughput.png" width="770"></figure><p>Again, performance benchmarks can be subjective based on the data model and
tuning of the DBs, but it nevertheless paints a compelling comparison point for
QuestDB. It will be interesting to see how the results shake out with DevOps or
iot modes as both InfluxDB and TimescaleDB support those use cases out of the
box with TSBS.</p><p>The other interesting component of QuestDB is support for both InfluxDB inline
protocol and PostgreSQL wire for ingestion. For existing InfluxDB users, you can
configure Telegraf to point to QuestDB&#x27;s address and port. Likewise for
PostgreSQL users use the existing client library or JDBC to write data into
QuestDB. Regardless of the ingestion method, data can be queried using standard
SQL with notable exceptions listed on the API reference page.</p><p>As a newer entrant in this space, the most apparent downside to QuestDB is the
lack of features such as replication (this is in the works). It does integrate with some of the most popular tools already
(e.g., PostgreSQL, Grafana, Kafka, Telegraf, Tableau), but it will need some
time to reach the level of the other TSDBs mentioned above.</p><p>Still, QuestDB is a promising project that can balance the positives of InfluxDB
and TimescaleDB:</p><ul><li><strong>Pros:</strong> fast ingestion (especially for datasets with high cardinality),
support for both InfluxDB protocol and PostgreSQL wire, querying via standard
SQL</li><li><strong>Cons:</strong> smaller community, available integrations, lack of some features</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="conclusion"></a>Conclusion<a class="hash-link" href="#conclusion" title="Direct link to heading">#</a></h2><p>As the demand for time series data continues to grow, TSDBs specialized to deal
with this data will see massive adoption and fierce competition. Besides the
three open-source TSDBs covered in this article, there are also public cloud
offerings from AWS (AWS Timestream) and Azure (Azure Series Insights).</p><p>As with all databases, choosing the &quot;perfect&quot; TSDB will primarily depend on your
business needs, data model, and use case. InfluxDB works well if your data fits
the tagset model with a rich ecosystem of integrations readily available.
TimescaleDB is a natural fit for existing PostgreSQL users. Finally, if
performance is the primary concern, QuestDB is a promising project that is
growing quickly.</p><p>If you like this content, we&#x27;d love to know your thoughts! Feel free to share
your feedback or come and say hello in the
<a href="https://" target="_blank" rel="noopener noreferrer">QuestDB Community Slack</a>.</p></div><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/benchmark">benchmark</a><a class="margin-horiz--sm" href="/blog/tags/influxdb">influxdb</a><a class="margin-horiz--sm" href="/blog/tags/timescale">timescale</a><a class="margin-horiz--sm" href="/blog/tags/questdb">questdb</a><a class="margin-horiz--sm" href="/blog/tags/timeseries">timeseries</a></div></footer></article><div></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2021/07/09/telegraf-and-questdb-for-storing-metrics-in-a-timeseries-database"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« Using Telegraf and QuestDB to store metrics in a time series database</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2021/06/18/tracking-multiple-cryptocurrency-exchanges"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Tracking multiple cryptocurrency exchanges using a time series database »</div></a></div></nav></div></main></div></div><div class="root_0lLS"><div class="cards_xeZk"><div class="root_R798 skinPrimary_JHOH"><svg width="76" height="76" viewBox="0 0 76 76" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="38" cy="38" r="38" fill="#1E1F27"></circle><path d="M56.99 18.792a.817.817 0 00-.117-.303c-.01-.02-.02-.05-.03-.069-.01-.02-.029-.029-.048-.049a.912.912 0 00-.137-.136l-.117-.088c-.02-.01-.03-.03-.05-.04-.029-.01-.068-.029-.107-.039a.85.85 0 00-.146-.049 1.075 1.075 0 00-.176-.019h-.147a1.15 1.15 0 00-.196.049c-.029.01-.068.01-.097.02L12.59 36.67a.979.979 0 00-.509 1.29c.098.216.264.401.48.5l16.07 7.556v15.025c0 .537.44.977.978.977a.964.964 0 00.831-.469l6.794-11.046 10.499 5.533a.974.974 0 001.408-.655l7.84-36.2v-.058c.01-.058.01-.107.019-.156 0-.059 0-.117-.01-.176zM29.413 44.208L15.376 37.6l36.326-15.68-22.289 22.288zm1.174 13.363V47.004l4.917 2.59-4.917 7.977zm16.92-3.87l-9.237-4.86-1.662-1.026-.068.118-5.289-2.786 23.1-23.12L47.508 53.7z" fill="#fff"></path></svg><h3 class="title_BHe0">문의하기</h3><p class="description_Bwvi">이메일을 입력하시면 소개자료를 보내드립니다.</p><div class="content_gAr2"><form class="root_teCd"><div><div class="inputs_0wQ8"><input type="email" class="input_cjQx input_a6pP" name="email" required="" pattern="^[a-zA-Z0-9.!#$%&amp;&#x27;*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$" placeholder="Email address" title="Email address should be valid"><button class="submit_poRs button_f7Ff button--tertiary_vtfp button--uppercase_ESEN" type="submit">보내기</button></div></div></form></div></div></div></div></div><footer class="root_JnvJ"><div class="content_-gfC center_S24y"><img alt="QuestDB logo" class="logo_JrwJ" src="/img/navbar/tp_brand.png" width="108" height="27"><div class="tagline_T1tH"><p>인프라관리부터 서비스운영까지 클라우드환경에 최적화된 클라우드 네이티브 플랫폼</p></div><div class="links_1SgP"></div></div><div class="border_PW0V"><div class="bottom_wPs3 center_S24y">Copyright © 2023 Gitple. All rights are reserved.</div></div></footer></div>
<script src="/assets/js/main.3e047ba9.js" defer="defer"></script>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3">
<meta httpequiv="x-ua-compatible" content="ie=edge">
<meta property="og:type" content="website">
<meta name="author" content="turpleio">
<meta name="generator" content="Docusaurus v2.0.0-alpha.75">
<link href="https://www.googletagmanager.com" rel="dns-prefetch">
<link href="https://www.google-analytics.com" rel="dns-prefetch">
<link rel="icon" href="/favicon.png">
<link rel="apple-touch-icon" href="/img/icons/apple-180x180.png" sizes="180x180">
<meta name="msapplication-config" content="/browserconfig.xml">
<link rel="sitemap" type="application/xml" href="/sitemap.xml">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=GTM-PVR7M2G"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","GTM-PVR7M2G",{anonymize_ip:!0})</script>
<link rel="search" type="application/opensearchdescription+xml" title="Turple: Cloud Native Platform" href="/opensearch.xml">
<link rel="manifest" href="/manifest.webmanifest">
<meta name="theme-color" content="#d14671">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#21222c">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Turple: Cloud Native Platform Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Turple: Cloud Native Platform Blog Atom Feed"><title data-react-helmet="true">Comparing InfluxDB and QuestDB databases | Turple: Cloud Native Platform</title><meta data-react-helmet="true" property="og:title" content="Comparing InfluxDB and QuestDB databases | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="description" content="An overview of InfluxDB versus QuestDB to compare features, functionality, performance, and ease of use."><meta data-react-helmet="true" name="twitter:description" content="An overview of InfluxDB versus QuestDB to compare features, functionality, performance, and ease of use."><meta data-react-helmet="true" property="og:description" content="An overview of InfluxDB versus QuestDB to compare features, functionality, performance, and ease of use."><meta data-react-helmet="true" name="twitter:title" content="Comparing InfluxDB and QuestDB databases | Turple: Cloud Native Platform"><meta data-react-helmet="true" name="twitter:image:alt" content="Image for &quot;Comparing InfluxDB and QuestDB databases | Turple: Cloud Native Platform&quot;"><meta data-react-helmet="true" name="keywords" content="timeseries,influxdb,questdb,comparison,database"><meta data-react-helmet="true" property="og:image" content="https://turpleio.github.io/img/blog/shared/og-influxdb.png"><meta data-react-helmet="true" name="twitter:image" content="https://turpleio.github.io/img/blog/shared/og-influxdb.png"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><link rel="stylesheet" href="/assets/css/styles.4f6557e4.css">
</head>
<body itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="Turple: Cloud Native Platform">
<meta itemprop="description" content="Turple is a cloud native platform which can help you build and operate your services on cloud.">
<meta itemprop="url" content="https://turpleio.github.io">
<meta itemprop="logo" content="https://turpleio.github.io/img/favicon.png">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<nav class="navbar navbar_wBc8 navbar--light"><div class="navbar__inner inner_Y8Z6"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand brand_AtiA" href="/">QuestDB</a></div><div class="navbar__items navbar__items--right"></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand brand_AtiA" href="/">QuestDB</a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"></ul></div></div></div></nav><div class="wrapper_DIJ0 blog-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--3"><div class="sidebar_q+wC thin-scrollbar"><h3 class="sidebarItemTitle_9G5K">Recent posts</h3><ul class="sidebarItemList_6T4b"><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/19/merry-questmas-gifts-2023">Merry Questmas! Here are your gifts for 2023...</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/12/13/using-prometheus-loki-grafana-monitor-questdb-kubernetes">Using Prometheus, Loki, and Grafana to monitor QuestDB in Kubernetes</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/30/full-table-scan-are-fast">Listen to Your CPU - Full-table Scans Are Fast</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/25/questdb-6.6.1-dynamic-commits">QuestDB 6.6.1 - Dynamic Commits</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/2022/11/23/sql-extensions-time-series-data-questdb-part-ii">SQL Extensions for Time Series Data in QuestDB - Part II</a></li></ul></div></div><main class="col col--7"><article><header><h1 class="title_KBQu">Comparing InfluxDB and QuestDB databases</h1><time datetime="2021-11-29T00:00:00.000Z" class="date_A31P">November 29, 2021 · 10 min read</time><div class="avatar margin-vert--md"><a href="https://github.com/bsmth" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars.githubusercontent.com/bsmth"></a><div class="avatar__intro"></div></div></header><div class="markdown"><figure><img alt="Summary of benchmarking results of InfluxDB compared to QuestDB" class="image_Pw1y margin_Rc0b shadow_7z-4" height="385" src="/img/blog/2021-11-29/banner.png" width="850"></figure><p>Time-series data is emerging as the dominant type of data produced in IoT,
Financial Services, Manufacturing, DevOps, monitoring, machine learning, and AI.
Time series databases are specialized for storing and analyzing this kind of
data efficiently and quickly. This article compares QuestDB with InfluxDB to
help understand the key differences so you can choose a time series database
that fits your use case.</p><p>The typical uses of time series databases are for:</p><ul><li>Application performance, uptime, and response times</li><li>Analyzing financial transactions and trades</li><li>Monitoring network logs</li><li>Asset tracking</li><li>E-commerce transaction data, sales insights, BI reports</li><li>Sensor data from IoT devices</li></ul><p>While the traditional use of databases was to store the last-known state of a
system, this only shows a snapshot of a point in time. In contrast, time series
data adds a historical dimension to help understand how information changes.</p><p>Understanding how information changes over time help make predictions about your
data, gain deeper insights into trends, and be better prepared for future
variations. For this reason, developers need a time-series database that&#x27;s
robust, easy to use, and powerful. Importantly, it must be flexible enough to be
used across different scenarios, industries, and use cases.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="what-are-the-data-models-used-in-influxdb-and-questdb"></a>What are the data models used in InfluxDB and QuestDB<a class="hash-link" href="#what-are-the-data-models-used-in-influxdb-and-questdb" title="Direct link to heading">#</a></h2><p>One of the first places to begin comparing QuestDB and InfluxDB is how data is
handled and stored in each database. InfluxDB has a dedicated <strong>line protocol</strong>
message format for ingesting measurements. Each measurement has a timestamp, a
set of tags (a tagset), and a set of fields (a fieldset).</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI txt"><div tabindex="0" class="prism-code language-txt codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">measurementName,tagKey=tagValue fieldKey=&quot;fieldValue&quot; 1465839830100399000</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">--------------- --------------- --------------------- -------------------</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">       |               |                  |                    |</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  Measurement         Tags              Fields             Timestamp</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>In InfluxDB, tagset values are strings and are indexed, while fieldset values
are not indexed. The data types that fields may use are limited to floats, ints,
strings, and booleans. The following snippet is an example message in InfluxDB
line protocol for illustration:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">sensors,location=london,version=REV-2.1 temperature=22,humidity=50 1465839830100399000\n</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>QuestDB supports InfluxDB line protocol for compatibility purposes, so inserts
using InfluxDB line protocol match the data types available. QuestDB supports
additional numeric types, such as bytes for 8-bit integers, shorts for 16-bit
integers, float for 32-bit floats, and long256 for larger integers. Additional
types can be used while ingesting InfluxDB line protocol by creating a table
with a desired schema before starting to write data.</p><p>QuestDB also exposes PostgreSQL wire protocol and a REST API for inserts,
allowing for more control over the data types that the system can handle,
including additional types such as date, char, and binary. In QuestDB, it&#x27;s also
possible to add indexes and to existing columns in tables, which can be done
directly through SQL:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">ALTER TABLE sensors ALTER COLUMN firmware ADD INDEX;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>QuestDB has full support for relational queries, whereas InfluxDB is a NoSQL,
non-relational database with a custom data model. QuestDB supports both
schema-agnostic ingestion over InfluxDB line protocol and a relational data
model. Users can leverage both paradigms and perform SQL JOINs to correlate
&quot;schemaless&quot; data with relational data by timestamp.</p><figure><img alt="A combination of schema-agnostic ingestion and relational data stored and queried in QuestDB" class="image_Pw1y margin_Rc0b shadow_7z-4" height="385" src="/img/blog/2021-11-29/relational-and-schema-agnostic.png" width="850"></figure><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="comparing-database-storage-models"></a>Comparing database storage models<a class="hash-link" href="#comparing-database-storage-models" title="Direct link to heading">#</a></h2><p>For storage, InfluxDB uses Time-Structured Merge Trees (TSM) where data is
stored in a columnar format, and the storage engine stores differences (or
<em>deltas</em>) between values in a series. For indexing, InfluxDB uses a Time Series
Index intended to keep queries fast as cardinality grows. Still, the efficiency
of this index has its limitations, explored in more detail in the
High-Cardinality section below.</p><p>QuestDB also uses columnar data structures but indexes data in vector-based
append-only column files. As of QuestDB version 6.0, sorting out-of-order data
occurs in a staging area in-memory, merging sorted and persisted data at commit
time using an append model. The reason for sorting in-memory and merging with
persisted data in this way is to keep the storage engine performant on both read
and write operations.</p><p>InfluxDB has a shard group concept as a strategy for partitioning, which allows
for grouping data by time. Users can provide a
<a href="https://docs.influxdata.com/influxdb/v2.0/reference/internals/shards/#shard-group-duration" target="_blank" rel="noopener noreferrer">shard group duration</a>
which defines how large a shard will be and can enable common operations such as
retention periods for data (deleting data older than X days, for example):</p><figure><img alt="An illystration of shard groups in InfluxDB" class="image_Pw1y margin_Rc0b shadow_7z-4" height="385" src="/img/blog/2021-11-29/shard-groups.png" width="850"></figure><p>QuestDB has similar functionality to partition tables by time, and users may
specify a partition size for tables based on days, months, or years. When tables
are partitioned by time, table metadata table is defined once per table, and
column files are partitioned at the filesystem level into directories per
partition:</p><figure><img alt="A diagram showing the column-based storage model of QuestDB" class="image_Pw1y margin_Rc0b shadow_7z-4" height="385" src="/img/blog/2021-11-29/questdb-storage-model.png" width="850"></figure><p>Both QuestDB and InfluxDB have ways to partition data by time and employ a
retention strategy. The difference in partitioning for each system is the
broader terminology, and the fact that QuestDB does not need to create
<a href="https://docs.influxdata.com/influxdb/v2.0/reference/internals/shards/#shards" target="_blank" rel="noopener noreferrer">separate TSM files on disk</a>
per partition.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ease-of-use-of-sql-compared-to-custom-query-languages"></a>Ease of use of SQL compared to custom query languages<a class="hash-link" href="#ease-of-use-of-sql-compared-to-custom-query-languages" title="Direct link to heading">#</a></h2><p>The emergence of NoSQL as a popular paradigm has effectively split databases
into two categories: SQL and NoSQL. InfluxDB originally started with a language
similar to SQL called InfluxQL, which balanced some aspects of SQL with custom
syntax. InfluxDB eventually adopted Flux as a query language to interact with
data.</p><p>QuestDB embraces SQL as the primary query language so that there is no need for
learning custom query languages. SQL is a good choice for time-series databases;
it&#x27;s easy to understand, most developers are familiar with it already, and SQL
skills are simple to apply across different systems. As reported by the Stack
Overflow developer survey of 2020, it&#x27;s the third most popular language used by
developers. It proves to be a long-standing choice for quickly asking questions
about the characteristics of your data.</p><p>Flux enables you to work with InfluxDB more efficiently, but it&#x27;s difficult to
read, and it&#x27;s harder to learn and onboard new users. From users&#x27; perspective,
learning a new custom query language is inconvenient for accessibility
regardless of their engineering background.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI javascript"><div tabindex="0" class="prism-code language-javascript codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token keyword module" style="color:#ff79c6">from</span><span class="token punctuation" style="color:#f8f8f2">(</span><span class="token plain">bucket</span><span class="token operator" style="color:#ff79c6">:</span><span class="token string" style="color:#f1fa8c">&quot;example-bucket&quot;</span><span class="token punctuation" style="color:#f8f8f2">)</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  </span><span class="token operator" style="color:#ff79c6">|</span><span class="token operator" style="color:#ff79c6">&gt;</span><span class="token plain"> </span><span class="token function" style="color:#8be9fd">range</span><span class="token punctuation" style="color:#f8f8f2">(</span><span class="token plain">start</span><span class="token operator" style="color:#ff79c6">:</span><span class="token operator" style="color:#ff79c6">-</span><span class="token number" style="color:#50fa7b">1</span><span class="token plain">h</span><span class="token punctuation" style="color:#f8f8f2">)</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  </span><span class="token operator" style="color:#ff79c6">|</span><span class="token operator" style="color:#ff79c6">&gt;</span><span class="token plain"> </span><span class="token function" style="color:#8be9fd">filter</span><span class="token punctuation" style="color:#f8f8f2">(</span><span class="token function-variable function" style="color:#8be9fd">fn</span><span class="token operator" style="color:#ff79c6">:</span><span class="token punctuation" style="color:#f8f8f2">(</span><span class="token parameter">r</span><span class="token punctuation" style="color:#f8f8f2">)</span><span class="token plain"> </span><span class="token arrow operator" style="color:#ff79c6">=&gt;</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    r</span><span class="token punctuation" style="color:#f8f8f2">.</span><span class="token property-access">_measurement</span><span class="token plain"> </span><span class="token operator" style="color:#ff79c6">==</span><span class="token plain"> </span><span class="token string" style="color:#f1fa8c">&quot;cpu&quot;</span><span class="token plain"> and</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">    r</span><span class="token punctuation" style="color:#f8f8f2">.</span><span class="token property-access">cpu</span><span class="token plain"> </span><span class="token operator" style="color:#ff79c6">==</span><span class="token plain"> </span><span class="token string" style="color:#f1fa8c">&quot;cpu-total&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  </span><span class="token punctuation" style="color:#f8f8f2">)</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  </span><span class="token operator" style="color:#ff79c6">|</span><span class="token operator" style="color:#ff79c6">&gt;</span><span class="token plain"> </span><span class="token function" style="color:#8be9fd">aggregateWindow</span><span class="token punctuation" style="color:#f8f8f2">(</span><span class="token plain">every</span><span class="token operator" style="color:#ff79c6">:</span><span class="token plain"> </span><span class="token number" style="color:#50fa7b">1</span><span class="token plain">m</span><span class="token punctuation" style="color:#f8f8f2">,</span><span class="token plain"> fn</span><span class="token operator" style="color:#ff79c6">:</span><span class="token plain"> mean</span><span class="token punctuation" style="color:#f8f8f2">)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Consider that the Flux query above can be written in SQL as follows:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI questdb-sql"><div tabindex="0" class="prism-code language-questdb-sql codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">SELECT avg(cpu), avg(cpu-total) FROM &#x27;example-bucket&#x27;</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">WHERE timestamp &gt; dateadd(&#x27;h&#x27;, -1, now())</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">SAMPLE BY 1m</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Users who have no developer background will have a barrier of entry, making it
difficult to use standard BI tools to gain insights on time series data. SQL is
a time-tested language that those without engineering backgrounds can pick up
quickly.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="measuring-time-series-database-performance"></a>Measuring time series database performance<a class="hash-link" href="#measuring-time-series-database-performance" title="Direct link to heading">#</a></h2><p>Let&#x27;s compare how QuestDB and InfluxDB operate in terms of performance. The
<a href="https://github.com/timescale/tsbs" target="_blank" rel="noopener noreferrer">Time Series Benchmark Suite</a> (TSBS)
regularly appears in discussions about database performance. The TSBS is a
collection of Go programs to generate datasets and then benchmark read and write
performance. The suite is extensible so that different use cases and query types
can be included and compared across systems. To generate data for these
benchmarks, commands look like the following:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI bash"><div tabindex="0" class="prism-code language-bash codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token comment" style="color:#6272a4"># Generating the dataset</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">tsbs_generate_data --seed</span><span class="token operator" style="color:#ff79c6">=</span><span class="token number" style="color:#50fa7b">123</span><span class="token plain"> --scale</span><span class="token operator" style="color:#ff79c6">=</span><span class="token number" style="color:#50fa7b">4000</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  --timestamp-start</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;2016-01-01T00:00:00Z&quot;</span><span class="token plain"> --timestamp-end</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;2016-01-02T00:00:00Z&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:#f8f8f2">\</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">  --log-interval</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;10s&quot;</span><span class="token plain"> --use-case</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;cpu-only&quot;</span><span class="token plain"> --format</span><span class="token operator" style="color:#ff79c6">=</span><span class="token string" style="color:#f1fa8c">&quot;influx&quot;</span><span class="token plain"> </span><span class="token operator" style="color:#ff79c6">&gt;</span><span class="token plain"> /tmp/bigcpu</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain"></span><span class="token comment" style="color:#6272a4"># Loading the data</span><span class="token plain"></span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">tsbs_load_questdb --file /tmp/bigcpu --workers </span><span class="token number" style="color:#50fa7b">4</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>The data produced from <code>tsbs_generate_data</code> above has the following features:</p><ul><li>4000 unique devices (scale)</li><li>500MB data set</li><li>24 hours worth of simulated data</li><li>InfluxDB line protocol</li></ul><p>This is an example of the first few lines from the generated data set:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI txt"><div tabindex="0" class="prism-code language-txt codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#f8f8f2;background-color:#262833"><div class="token-line" style="color:#f8f8f2"><span class="token plain">&quot;hostname&quot;,&quot;region&quot;,&quot;datacenter&quot;,&quot;rack&quot;,&quot;os&quot;,&quot;arch&quot;,&quot;team&quot;,&quot;service&quot;,&quot;service_version&quot;,&quot;service_environment&quot;,&quot;usage_user&quot;,&quot;usage_system&quot;,&quot;usage_idle&quot;,&quot;usage_nice&quot;,&quot;usage_iowait&quot;,&quot;usage_irq&quot;,&quot;usage_softirq&quot;,&quot;usage_steal&quot;,&quot;usage_guest&quot;,&quot;usage_guest_nice&quot;,&quot;timestamp&quot;</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">&quot;host_0&quot;,&quot;eu-central-1&quot;,&quot;eu-central-1a&quot;,&quot;6&quot;,&quot;Ubuntu15.10&quot;,&quot;x86&quot;,&quot;SF&quot;,&quot;19&quot;,&quot;1&quot;,&quot;test&quot;,58,2,24,61,22,63,6,44,80,38,&quot;2016-01-01T00:00:00.000000Z&quot;</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">&quot;host_1&quot;,&quot;us-west-1&quot;,&quot;us-west-1a&quot;,&quot;41&quot;,&quot;Ubuntu15.10&quot;,&quot;x64&quot;,&quot;NYC&quot;,&quot;9&quot;,&quot;1&quot;,&quot;staging&quot;,84,11,53,87,29,20,54,77,53,74,&quot;2016-01-01T00:00:00.000000Z&quot;</span></div><div class="token-line" style="color:#f8f8f2"><span class="token plain">&quot;host_2&quot;,&quot;sa-east-1&quot;,&quot;sa-east-1a&quot;,&quot;89&quot;,&quot;Ubuntu16.04LTS&quot;,&quot;x86&quot;,&quot;LON&quot;,&quot;13&quot;,&quot;0&quot;,&quot;staging&quot;,29,48,5,63,17,52,60,49,93,1,&quot;2016-01-01T00:00:00.000000Z&quot;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>QuestDB reaches maximum ingestion performance using four threads, whereas
InfluxDB requires more workers to hit maximum throughput. QuestDB achieves 959k
rows/sec with four threads, whereas InfluxDB needs 14 threads to reach its max
ingestion rate (334k rows/sec).</p><figure><img alt="Ingestion results comparing QuestDB and InfluxDB using the time series benchmark suite" class="image_Pw1y margin_Rc0b shadow_7z-4" height="385" src="/img/blog/2021-11-29/timeseries-benchmark-suite-results.png" width="650"></figure><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="how-high-cardinality-impacts-ingestion-rates"></a>How high-cardinality impacts ingestion rates<a class="hash-link" href="#how-high-cardinality-impacts-ingestion-rates" title="Direct link to heading">#</a></h2><p>Cardinality typically refers to the number of elements in a set&#x27;s size. In the
context of a time series database (TSDB), high-cardinality boils down to many
indexed columns in a table and each indexed column containing many unique
values.</p><p>High-cardinality is a known problem area for InfluxDB, and this is likely
because of the system architecture and storage engine. InfluxDB uses data
structures based on LSM-trees which are known to perform poorly in
high-cardinality scenarios. In QuestDB, the storage model is radically different
from LSM trees or B-trees and instead uses data stored in densely ordered
vectors on disk.</p><p>We ran the TSBS benchmark specifying different scale values for multiple data
sets and tested ingestion using up to sixteen threads to determine the maximum
throughput of each system and to get an idea of how ingestion rates change over
time:</p><figure><img alt="High-cardinality results comparing QuestDB and InfluxDB using the time series benchmark suite" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="385" src="/img/blog/2021-11-29/timeseries-benchmark-high-cardinality.png" width="850"><figcaption class="caption_-tGK">TSBS load benchmark maximum throughput results on AWS m5.8xlarge instance (4 threads)</figcaption></figure><p>With low cardinality data sets, QuestDB hits maximum ingestion throughput of
904k rows/sec, and at 10 million unique devices, QuestDB sustains 640k rows/sec.
InfluxDB ingestion starts at 220k rows/sec on 100 devices and reached 38k
rows/sec on the 10M device dataset.</p><p>As we ran high-cardinality data sets, InfluxDB struggled to keep up with
inserts. The bottleneck is likely due to the use of Time-Structured Merge Trees.
The issues manifested at first in degraded ingestion rates, but eventually,
out-of-memory errors begin to appear at runtime. We provided more workers to the
systems under test to investigate if adding more threads would offer more
stability, however InfluxDB was unable to finish the tests with 10M devices:</p><figure><img alt="High-cardinality results comparing QuestDB and InfluxDB using the time series benchmark suite" class="image_Pw1y margin_Rc0b shadow_7z-4 title_f-p+" height="385" src="/img/blog/2021-11-29/timeseries-benchmark-suite-throughput.png" width="850"><figcaption class="caption_-tGK">TSBS load benchmark maximum throughput results on AWS m5.8xlarge instance (16 threads)</figcaption></figure><p>InfluxDB requires a lot more threads to be able to handle high-cardinality data,
but there are diminishing returns on adding more workers, revealing that there
are underlying barriers which are not overcome by providing more threads to the
system.</p><p>QuestDB handles high-cardinality better with more threads. When cardinality is
low, fewer workers lead to an overall higher maximum throughput, but a steeper
drop in ingestion rates when going from 1M devices to 10M.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="support-and-community"></a>Support and community<a class="hash-link" href="#support-and-community" title="Direct link to heading">#</a></h2><p>The community is vital to QuestDB so that beginners have an environment that
encourages getting up and running quickly. Experienced users have channels for
raising technical questions or bugs with the engineering team or other power
users. We have a growing Slack workspace with over 900 members who discuss how
they are using QuestDB daily to power their businesses. Our mission is to solve
the problems users have with time series data. To achieve that, we are driven to
understand the pain points that arise from practical scenarios, and we have the
community as a force that informs our product roadmap.</p><p>We designed QuestDB to sidestep custom query languages that require specialist
knowledge to understand. We believe that it should be easy to ask questions
about how your own data looks and changes. Support, community forums, and online
resources are a treasure trove of many decades of knowledge working with SQL
which directly transfers to using QuestDB. If you are new to QuestDB (or SQL),
it&#x27;s easy to get started by means of online resources, tutorials, and the
expertise shared by our community. For seasoned SQL experts, there is no
learning curve except for time-based calculations and analysis specific for time
series.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="choosing-a-database-that-fits"></a>Choosing a database that fits<a class="hash-link" href="#choosing-a-database-that-fits" title="Direct link to heading">#</a></h2><p>We want to make sure engineers can pick the right tool for the job and have
highlighted some key differentiators between QuestDB and InfluxDB. If there are
suggestions for improving this comparison, we&#x27;d be happy to include this in our
analysis.</p></div><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/tutorial">tutorial</a><a class="margin-horiz--sm" href="/blog/tags/benchmark">benchmark</a><a class="margin-horiz--sm" href="/blog/tags/influxdb">influxdb</a><a class="margin-horiz--sm" href="/blog/tags/comparison">comparison</a></div></footer></article><div></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2021/12/20/release-prometheus-alertmanager"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« QuestDB 6.1.3 December release, Prometheus improvements</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2021/11/22/high-frequency-finance-introduction-julia-lang"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">A tour of high-frequency finance via the Julia language and QuestDB »</div></a></div></nav></div></main></div></div><div class="root_0lLS"><div class="cards_xeZk"><div class="root_R798 skinPrimary_JHOH"><svg width="76" height="76" viewBox="0 0 76 76" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="38" cy="38" r="38" fill="#1E1F27"></circle><path d="M56.99 18.792a.817.817 0 00-.117-.303c-.01-.02-.02-.05-.03-.069-.01-.02-.029-.029-.048-.049a.912.912 0 00-.137-.136l-.117-.088c-.02-.01-.03-.03-.05-.04-.029-.01-.068-.029-.107-.039a.85.85 0 00-.146-.049 1.075 1.075 0 00-.176-.019h-.147a1.15 1.15 0 00-.196.049c-.029.01-.068.01-.097.02L12.59 36.67a.979.979 0 00-.509 1.29c.098.216.264.401.48.5l16.07 7.556v15.025c0 .537.44.977.978.977a.964.964 0 00.831-.469l6.794-11.046 10.499 5.533a.974.974 0 001.408-.655l7.84-36.2v-.058c.01-.058.01-.107.019-.156 0-.059 0-.117-.01-.176zM29.413 44.208L15.376 37.6l36.326-15.68-22.289 22.288zm1.174 13.363V47.004l4.917 2.59-4.917 7.977zm16.92-3.87l-9.237-4.86-1.662-1.026-.068.118-5.289-2.786 23.1-23.12L47.508 53.7z" fill="#fff"></path></svg><h3 class="title_BHe0">문의하기</h3><p class="description_Bwvi">이메일을 입력하시면 소개자료를 보내드립니다.</p><div class="content_gAr2"><form class="root_teCd"><div><div class="inputs_0wQ8"><input type="email" class="input_cjQx input_a6pP" name="email" required="" pattern="^[a-zA-Z0-9.!#$%&amp;&#x27;*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$" placeholder="Email address" title="Email address should be valid"><button class="submit_poRs button_f7Ff button--tertiary_vtfp button--uppercase_ESEN" type="submit">보내기</button></div></div></form></div></div></div></div></div><footer class="root_JnvJ"><div class="content_-gfC center_S24y"><img alt="QuestDB logo" class="logo_JrwJ" src="/img/navbar/tp_brand.png" width="108" height="27"><div class="tagline_T1tH"><p>인프라관리부터 서비스운영까지 클라우드환경에 최적화된 클라우드 네이티브 플랫폼</p></div><div class="links_1SgP"></div></div><div class="border_PW0V"><div class="bottom_wPs3 center_S24y">Copyright © 2023 Gitple. All rights are reserved.</div></div></footer></div>
<script src="/assets/js/main.e53824dd.js" defer="defer"></script>
</body>
</html>
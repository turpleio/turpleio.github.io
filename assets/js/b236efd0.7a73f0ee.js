"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[6926],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return g}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(a),g=r,c=u["".concat(s,".").concat(g)]||u[g]||d[g]||i;return a?n.createElement(c,l(l({ref:t},m),{},{components:a})):n.createElement(c,l({ref:t},m))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},66851:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return o},metadata:function(){return s},toc:function(){return p},default:function(){return d}});var n=a(83117),r=a(80102),i=(a(67294),a(3905)),l=["components"],o={title:"Version 6.0 migration",description:"This document describes details about automatic upgrades with QuestDB version 6.0 and instructions for manually reverting tables for compatibility with earlier QuestDB versions."},s={unversionedId:"guides/v6-migration",id:"guides/v6-migration",isDocsHomePage:!1,title:"Version 6.0 migration",description:"This document describes details about automatic upgrades with QuestDB version 6.0 and instructions for manually reverting tables for compatibility with earlier QuestDB versions.",source:"@site/docs/guides/v6-migration.md",sourceDirName:"guides",slug:"/guides/v6-migration",permalink:"/docs/guides/v6-migration",editUrl:"https://github.com/turpleio/homepage/edit/main/docs/guides/v6-migration.md",version:"current",frontMatter:{title:"Version 6.0 migration",description:"This document describes details about automatic upgrades with QuestDB version 6.0 and instructions for manually reverting tables for compatibility with earlier QuestDB versions."}},p=[{value:"Upgrading QuestDB",id:"upgrading-questdb",children:[]},{value:"Reverting transaction files",id:"reverting-transaction-files",children:[{value:"Table downgrade example",id:"table-downgrade-example",children:[]}]},{value:"Breaking SQL changes",id:"breaking-sql-changes",children:[{value:"Timestamp string equality",id:"timestamp-string-equality",children:[]},{value:"Timestamp string comparison",id:"timestamp-string-comparison",children:[]},{value:"Timestamp IN list",id:"timestamp-in-list",children:[]}]}],m={toc:p};function d(e){var t=e.components,a=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Release 6.0 introduces breaking changes in table transaction files. An automated\nconversion process has been included in the release which will migrate table\ntransaction files to use the new format. The following sections describe the\nautomated upgrade process with notes for manually downgrading tables for\ncompatibility with older versions."),(0,i.kt)("h2",{id:"upgrading-questdb"},"Upgrading QuestDB"),(0,i.kt)("p",null,"When QuestDB v6.0 starts up, and tables from older QuestDB versions are\ndetected, a migration to the new transaction file format will run automatically.\nThe migration scans for the existence of tables within the QuestDB storage\ndirectory and upgrades transaction (",(0,i.kt)("inlineCode",{parentName:"p"},"_txn"),") files for each table. All other\ntable data is untouched by the upgrade."),(0,i.kt)("p",null,"If the migration fails for a table, an error message will be printed in the\nQuestDB logs on startup. QuestDB will not terminate, but tables which have not\nbeen successfully upgraded cannot be used for querying or writing."),(0,i.kt)("p",null,"Starting QuestDB again will trigger another attempt to migrate tables using an\nolder transaction file format."),(0,i.kt)("h2",{id:"reverting-transaction-files"},"Reverting transaction files"),(0,i.kt)("p",null,"During the upgrade process, ",(0,i.kt)("inlineCode",{parentName:"p"},"_txn")," files are backed up and renamed using the\nformat ",(0,i.kt)("inlineCode",{parentName:"p"},"_txn.v417"),". Users who wish to revert the table migration can downgrade\ntables by following these steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"delete the folder ",(0,i.kt)("inlineCode",{parentName:"li"},"/path/to/questdb/db/_upgrade.d")),(0,i.kt)("li",{parentName:"ol"},"for each table, rename ",(0,i.kt)("inlineCode",{parentName:"li"},"_txn.v417")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"_txn"))),(0,i.kt)("h3",{id:"table-downgrade-example"},"Table downgrade example"),(0,i.kt)("p",null,"This section illustrates how to revert transaction files to a format used by\nQuestDB versions earlier than 6.0. Given storage directories for two table\n",(0,i.kt)("inlineCode",{parentName:"p"},"example_table")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"sensors"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="path/to/qdb"',title:'"path/to/qdb"'},"\u251c\u2500\u2500 conf\n\u251c\u2500\u2500 db\n\u2502\xa0\xa0 \u251c\u2500\u2500 _tab_index.d\n\u2502\xa0\xa0 \u251c\u2500\u2500 _upgrade.d\n\u2502\xa0\xa0 \u251c\u2500\u2500 example_table\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 2021\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 tempF.d\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 ...\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 visMiles.d\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 _meta\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 _txn\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 _txn.v417\n\u2502\xa0\xa0 \u2514\u2500\u2500 sensors\n\u2502\xa0\xa0     \u251c\u2500\u2500 2021\n\u2502\xa0\xa0     \u2502\xa0\xa0 \u251c\u2500\u2500 device_id.d\n\u2502\xa0\xa0     \u2502\xa0\xa0 \u251c\u2500\u2500 ...\n\u2502\xa0\xa0     \u2502\xa0\xa0 \u2514\u2500\u2500 temperature.d\n\u2502\xa0\xa0     \u251c\u2500\u2500 _meta\n\u2502\xa0\xa0     \u251c\u2500\u2500 _txn\n\u2502\xa0\xa0     \u2514\u2500\u2500 _txn.v417\n\u2514\u2500\u2500 public\n")),(0,i.kt)("p",null,"The tables may be downgraded in the following manner:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"rm db/_upgrade.d\nmv db/example_table/_txn.v417 db/example_table/_txn\nmv db/sensors/_txn.v417 db/sensors/_txn\n")),(0,i.kt)("p",null,"After these steps have been completed, QuestDB v5.x may be started and the table\ndata will be loaded as usual."),(0,i.kt)("h2",{id:"breaking-sql-changes"},"Breaking SQL changes"),(0,i.kt)("p",null,"Release 6.0.1 contains breaking changes relating to SQL syntax to simplify\nworking with ",(0,i.kt)("inlineCode",{parentName:"p"},"TIMESTAMP")," types and for improved compatibility with ANSI SQL\nexpectations."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"For more information on these changes, see the 6.0.1 software version\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/questdb/questdb/releases/tag/6.0.1"},"release notes on GitHub"),"."))),(0,i.kt)("p",null,"To illustrate how timestamps are handled, a table ",(0,i.kt)("inlineCode",{parentName:"p"},"my_table")," containing 48\nrecords with timestamps every hour beginning at ",(0,i.kt)("inlineCode",{parentName:"p"},"00:00:00")," on ",(0,i.kt)("inlineCode",{parentName:"p"},"2020-01-01")," will\nbe used in the following examples:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"timestamp"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-01T00:00:00.000000Z")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-01T01:00:00.000000Z")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-01T02:00:00.000000Z")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"...")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-01T23:00:00.000000Z")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-02T00:00:00.000000Z")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-02T01:00:00.000000Z")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"...")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-02T23:00:00.000000Z")))),(0,i.kt)("h3",{id:"timestamp-string-equality"},"Timestamp string equality"),(0,i.kt)("p",null,"The following example SQL uses a ",(0,i.kt)("inlineCode",{parentName:"p"},"WHERE")," clause to evaluate if records match\nusing string equality."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-questdb-sql",metastring:'title="Timestamp string equality"',title:'"Timestamp',string:!0,'equality"':!0},"SELECT * FROM my_table\nWHERE timestamp = '2020-01-01'\n")),(0,i.kt)("p",null,"The result will be 1 record with exact match of ",(0,i.kt)("inlineCode",{parentName:"p"},"2020-01-01T00:00:00.000000Z"),".\nIn other words, the string ",(0,i.kt)("inlineCode",{parentName:"p"},"2020-01-01")," does not represent an interval, but a\nsingle ",(0,i.kt)("inlineCode",{parentName:"p"},"TIMESTAMP")," data point of ",(0,i.kt)("inlineCode",{parentName:"p"},"2020-01-01T00:00:00.000000Z")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"timestamp"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-01T00:00:00.000000Z")))),(0,i.kt)("p",null,"Before software version ",(0,i.kt)("inlineCode",{parentName:"p"},"6.0.1"),", this would result in 24 records of all hours\nduring date '2020-01-01'"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"timestamp"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-01T00:00:00.000000Z")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-01T01:00:00.000000Z")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-01T02:00:00.000000Z")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"...")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-01T23:00:00.000000Z")))),(0,i.kt)("p",null,"In order to use the old semantics, the query must use the ",(0,i.kt)("inlineCode",{parentName:"p"},"IN")," keyword instead\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"="),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-questdb-sql",metastring:'title="Timestamp string equality using IN"',title:'"Timestamp',string:!0,equality:!0,using:!0,'IN"':!0},"SELECT * FROM my_table\nWHERE timestamp IN '2020-01-01'\n")),(0,i.kt)("h3",{id:"timestamp-string-comparison"},"Timestamp string comparison"),(0,i.kt)("p",null,"Timestamps may also be compared using ",(0,i.kt)("inlineCode",{parentName:"p"},">")," greater-than and ",(0,i.kt)("inlineCode",{parentName:"p"},"<")," less-than\noperators. The following example SQL uses a ",(0,i.kt)("inlineCode",{parentName:"p"},">")," greater-than operator to\nevaluate if records occur later than a timestamp provided as a string:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-questdb-sql",metastring:'title="Timestamp string equality"',title:'"Timestamp',string:!0,'equality"':!0},"SELECT * FROM my_table\nWHERE timestamp > '2020-01-01'\n")),(0,i.kt)("p",null,"The results are 47 records which have timestamps strictly greater than\n",(0,i.kt)("inlineCode",{parentName:"p"},"2020-01-01T00:00:00.000000Z"),". The string ",(0,i.kt)("inlineCode",{parentName:"p"},"2020-01-01")," does not represent an\ninterval, but a single ",(0,i.kt)("inlineCode",{parentName:"p"},"TIMESTAMP")," data point of ",(0,i.kt)("inlineCode",{parentName:"p"},"2020-01-01T00:00:00.000000Z"),":"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"timestamp"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-01T01:00:00.000000Z")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"...")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-02T23:00:00.000000Z")))),(0,i.kt)("p",null,"Before software version ",(0,i.kt)("inlineCode",{parentName:"p"},"6.0.1"),", this would result in 24 records, one for each\nhour during the date ",(0,i.kt)("inlineCode",{parentName:"p"},"2020-01-02"),":"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"timestamp"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-02T00:00:00.000000Z")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"...")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-02T23:00:00.000000Z")))),(0,i.kt)("p",null,"In order to use the old semantics, the query must use ",(0,i.kt)("inlineCode",{parentName:"p"},">=")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},">"),", and\n",(0,i.kt)("inlineCode",{parentName:"p"},"<=")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"<"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-questdb-sql",metastring:'title="Greater than or equal to a string timestamp"',title:'"Greater',than:!0,or:!0,equal:!0,to:!0,a:!0,string:!0,'timestamp"':!0},"SELECT * FROM my_table\nWHERE timestamp >= '2020-01-02'\n")),(0,i.kt)("h3",{id:"timestamp-in-list"},"Timestamp IN list"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"IN")," keyword is used to check equality with a list of 2 elements:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-questdb-sql",metastring:'title="Timestamp IN string list"',title:'"Timestamp',IN:!0,string:!0,'list"':!0},"SELECT * FROM my_table\nWHERE timestamp IN ('2020-01-01T00:00:00.000000Z', '2020-01-02T00:00:00.000000Z')\n")),(0,i.kt)("p",null,"The result is two records matching exactly ",(0,i.kt)("inlineCode",{parentName:"p"},"2020-01-01T00:00:00.000000Z")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"2020-01-02T00:00:00.000000Z")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"timestamp"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-02T00:00:00.000000Z")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-02T00:00:00.000000Z")))),(0,i.kt)("p",null,"Before software version ",(0,i.kt)("inlineCode",{parentName:"p"},"6.0.1"),", this would result in 25 records, one for each\nhour during the date ",(0,i.kt)("inlineCode",{parentName:"p"},"2020-01-01")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"00:00:00")," data point on ",(0,i.kt)("inlineCode",{parentName:"p"},"2020-01-02"),":"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"timestamp"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-02T00:00:00.000000Z")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"...")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2020-01-02T00:00:00.000000Z")))),(0,i.kt)("p",null,"In order to use the old semantics, the ",(0,i.kt)("inlineCode",{parentName:"p"},"BETWEEN")," keyword should be used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-questdb-sql",metastring:'title="Timestamp string equality using BETWEEN"',title:'"Timestamp',string:!0,equality:!0,using:!0,'BETWEEN"':!0},"SELECT * FROM my_table\nWHERE timestamp BETWEEN '2020-01-01T00:00:00.000000Z' AND '2020-01-02T00:00:00.000000Z'\n")))}d.isMDXComponent=!0}}]);
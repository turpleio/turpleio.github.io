"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[7171],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},47942:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},metadata:function(){return u},toc:function(){return p},default:function(){return m}});var a=n(83117),r=n(80102),i=(n(67294),n(3905)),o=n(46092),s=n(72525),l=["components"],c={title:"Tracking multiple cryptocurrency exchanges using a time series database",author:"Yitaek Hwang",author_title:"Guest",author_url:"https://github.com/Yitaek",author_image_url:"https://avatars.githubusercontent.com/Yitaek",description:"Leveraging QuestDB\u2019s data ingestion via InfluxDB line protocol to build a high-throughput cryptocurrency price tracker capable of handling out-of-order records on the fly.",keywords:["timeseries","crypto","bitcoin","marketdata"],tags:["tutorial","node.js","crypto","market data","bitcoin","javascript"],image:"/img/blog/shared/og-bitcoin.png"},u={permalink:"/blog/2021/06/18/tracking-multiple-cryptocurrency-exchanges",source:"@site/blog/2021-06-18-tracking-multiple-cryptocurrency-exchanges.mdx",title:"Tracking multiple cryptocurrency exchanges using a time series database",description:"Leveraging QuestDB\u2019s data ingestion via InfluxDB line protocol to build a high-throughput cryptocurrency price tracker capable of handling out-of-order records on the fly.",date:"2021-06-18T00:00:00.000Z",formattedDate:"June 18, 2021",tags:[{label:"tutorial",permalink:"/blog/tags/tutorial"},{label:"node.js",permalink:"/blog/tags/node-js"},{label:"crypto",permalink:"/blog/tags/crypto"},{label:"market data",permalink:"/blog/tags/market-data"},{label:"bitcoin",permalink:"/blog/tags/bitcoin"},{label:"javascript",permalink:"/blog/tags/javascript"}],readingTime:6.06,truncated:!1,prevItem:{title:"Comparing InfluxDB, TimescaleDB, and QuestDB timeseries databases",permalink:"/blog/2021/07/05/comparing-questdb-timescaledb-influxdb"},nextItem:{title:"How databases handle 10 million devices in high-cardinality benchmarks",permalink:"/blog/2021/06/16/high-cardinality-time-series-data-performance"}},p=[{value:"Tracking volatility using a Bitcoin ticker",id:"tracking-volatility-using-a-bitcoin-ticker",children:[]},{value:"Prerequisites",id:"prerequisites",children:[]},{value:"Out-of-order data ingestion",id:"out-of-order-data-ingestion",children:[]},{value:"InfluxDB Line Protocol compatibility",id:"influxdb-line-protocol-compatibility",children:[]},{value:"Writing data from multiple cryptocurrency exchanges",id:"writing-data-from-multiple-cryptocurrency-exchanges",children:[]},{value:"Summary",id:"summary",children:[]}],d={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(o.Z,{alt:"A candlestick chart showing Bitcoin prices in US Dollars",height:467,src:"/img/blog/2021-06-18/banner.jpg",width:650,mdxType:"Banner"},"Photo by ",(0,i.kt)("a",{href:"https://unsplash.com/@nick604"},"Nick Chong")," via"," ",(0,i.kt)("a",{href:"https://unsplash.com"},"Unsplash")),(0,i.kt)("p",null,"This submission comes from one of our community contributors\n",(0,i.kt)("a",{parentName:"p",href:"https://yitaek.medium.com/"},"Yitaek Hwang")," who has put together another\nexcellent tutorial that shows how to stream blockchain data into QuestDB for\ntime series data visualization and analysis."),(0,i.kt)("p",null,"Thanks for another great contribution, Yitaek!"),(0,i.kt)("h2",{id:"tracking-volatility-using-a-bitcoin-ticker"},"Tracking volatility using a Bitcoin ticker"),(0,i.kt)("p",null,"Crypto investors saw 1T USD wiped out of the market in May, as the price of\nBitcoin and other cryptocurrencies nosedived to their lowest in 2021. Given the\nvolatile nature of this asset class, traders looking to navigate the market need\nfast and reliable price data from multiple exchanges. Earlier this year, I\nshared a way to\n",(0,i.kt)("a",{parentName:"p",href:"/blog/2021/02/18/realtime-crypto-tracker-with-kafka-and-questdb"},"analyze cryptocurrency price trends in real-time"),"\nvia Kafka and QuestDB. That project polled the Coinbase API for the latest price\nand calculated moving averages prior to sending it to a time series database for\nfurther analysis."),(0,i.kt)("p",null,"Utilizing Kafka, I was able to leverage its scalability and ordering guarantees\nprior to ingesting in QuestDB. However, since I was using the PostgreSQL wire\nprotocol interface, it was not optimized for fast ingestion. Also, the price\nfeed was limited to a single exchange (i.e. Coinbase Pro), reducing our ability\nto react quickly to volatility such as buying or selling Bitcoin based on best\nprice on another exchange."),(0,i.kt)("p",null,"Fortunately,\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/questdb/questdb/releases"},"QuestDB team released an update"),"\nwith significant re-write of their InfluxDB Line Protocol for fast ingestion and\nsupport for out-of-order data. So I decided to modify my previous project to\ntest out these features."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Disclaimer:")," This tutorial is not investment or financial advice. All views\nexpressed here are my own."),(0,i.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.docker.com/get-docker/"},"Docker")," with at least 4GB memory"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://nodejs.org/en/download/"},"Node.js"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," Memory can be increased on Docker Desktop in ",(0,i.kt)("strong",{parentName:"p"},"Settings -> Resources\n-> Memory")," and increasing the default limit from ",(0,i.kt)("inlineCode",{parentName:"p"},"2GB")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"4GB"),"."),(0,i.kt)("h2",{id:"out-of-order-data-ingestion"},"Out-of-order data ingestion"),(0,i.kt)("p",null,"With the release of v6.0.0, QuestDB no longer enforces that timeseries data is\nsent in strict chronological order. This means that QuestDB can deal with\nout-of-order data caused by network delays, hardware jitter, or different\ndelivery mechanisms, using the timestamp field instead of relying on the\nreceived time. As shown in the example below, if a message is received by\nQuestDB after the sample time (delay of 9s, 1s, 2s respectively), QuestDB can\nrecognize this lag and re-orders them prior to committing them to the database."),(0,i.kt)(s.Z,{alt:"A diagram illustrating how delays and network jitter can cause records to arrive out-of-order by time at a database",height:278,src:"/img/guides/out-of-order-commit-lag/o3-data.jpeg",width:650,title:"Data arriving out-of-order due to network delays or jitter",mdxType:"Screenshot"}),(0,i.kt)("p",null,"This removes the burden from the programmer to design their ingestion mechanism\nto deal with delays or network skew. While Kafka guarantees ordering within a\npartition, it was still my responsibility to send messages in order to the\nbroker to consume them chronologically. Since I was polling a single endpoint,\nthere was little chance of records being sent out-of-order. But by adding new\nexchanges to poll information from (e.g. Binance, Gemini), API response times\nand network delays come into factor."),(0,i.kt)("h2",{id:"influxdb-line-protocol-compatibility"},"InfluxDB Line Protocol compatibility"),(0,i.kt)("p",null,"QuestDB also recommends using the InfluxDB line protocol as the primary\ningestion method for highest performance. In fact, QuestDB team\n",(0,i.kt)("a",{parentName:"p",href:"/blog/2021/05/10/questdb-release-6-0-tsbs-benchmark"},"achieved write speeds of 1.43M rows/sec using an AMD Ryzen5"),"\nwhen running the ",(0,i.kt)("a",{parentName:"p",href:"/time-series-benchmark-suite"},"Time Series Benchmark Suite"),"."),(0,i.kt)("p",null,"InfluxDB line protocol also provides the following benefits over using the\nPostgres client (as used in the Kafka project via Kafka Connect):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"higher-throughput"),(0,i.kt)("li",{parentName:"ul"},"robust ingestion from multiple sources into tables"),(0,i.kt)("li",{parentName:"ul"},"configurable commit-lag for out-of-order data"),(0,i.kt)("li",{parentName:"ul"},"schema-agnostic ingestion (i.e. adding new fields will dynamically create new\ncolumns)")),(0,i.kt)("p",null,"The message format for InfluxDB looks as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-pseudo"},"table_name,<tag>=<value> <label>=<value>,<label>=<value> timestamp\\n\n")),(0,i.kt)("p",null,"Each line of the InfluxDB record is ingested as a new row in QuestDB. For this\nproject, ",(0,i.kt)("inlineCode",{parentName:"p"},"table_name")," was ",(0,i.kt)("inlineCode",{parentName:"p"},"crypto"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"tag")," is the symbol for the cryptocurrency\n(e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"BTC"),") with other labels including columns for exchange names and prices."),(0,i.kt)("h2",{id:"writing-data-from-multiple-cryptocurrency-exchanges"},"Writing data from multiple cryptocurrency exchanges"),(0,i.kt)("p",null,"To start, first pull the latest version of QuestDB (v6.0.3 or higher):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"docker pull questdb/questdb:latest\n")),(0,i.kt)("p",null,"Run the image with the following command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"docker run -p 9000:9000 -p 9009:9009 questdb/questdb\n")),(0,i.kt)("p",null,"Port ",(0,i.kt)("inlineCode",{parentName:"p"},"9009")," is used for sending new data to QuestDB using InfluxDB line\nprotocol, and the web interface for QuestDB is exposed on port ",(0,i.kt)("inlineCode",{parentName:"p"},"9000")," to explore\ndata and run SQL queries."),(0,i.kt)("p",null,"For the purposes of the demo, I\u2019ve decided to pull the price of Bitcoin from\nBinance and Gemini every second. To test the out-of-order ingestion more\nobvious, I purposely introduced a random delay between 1\u20135s before sending price\ndata from Gemini."),(0,i.kt)("p",null,"We do not need to create tables beforehand when using InfluxDB line protocol, so\nwe can directly run the following script and a table ",(0,i.kt)("inlineCode",{parentName:"p"},"crypto")," will be created on\nthe fly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const axios = require("axios")\nconst net = require("net")\n\nconst influxClient = new net.Socket()\n\nconst HOST = "localhost"\nconst PORT = 9009\n\nfunction randomInt(low, high) {\n  return Math.floor(Math.random() * (high - low) + low)\n}\n\nasync function main() {\n  await influxClient.connect(PORT, HOST)\n\n  async function getBinanceData() {\n    const { data } = await axios.get(\n      "https://api.binance.us/api/v3/avgPrice?symbol=BTCUSD",\n    )\n    const row = `crypto,currency=BTC,exchange=Binance price=${data.price} ${\n      Date.now() * 1e6\n    }`\n\n    await influxClient.write(`${row}\\n`)\n\n    setTimeout(getBinanceData, 1000)\n  }\n\n  async function getGeminiData() {\n    const { data } = await axios.get("https://api.gemini.com/v1/pricefeed")\n    const { price } = data.find((i) => i.pair === "BTCUSD")\n\n    const row = `crypto,currency=BTC,exchange=Gemini price=${price} ${\n      Date.now() * 1e6\n    }`\n\n    setTimeout(async () => {\n      await influxClient.write(`${row}\\n`)\n    }, randomInt(1000, 5000))\n\n    setTimeout(getGeminiData, 1000)\n  }\n\n  getBinanceData()\n  getGeminiData()\n}\n\nmain()\n')),(0,i.kt)("p",null,"To check if the data is committed in chronological order, I can run the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/function/boolean"},"isOrdered")," function in a query:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"SELECT isOrdered(timestamp) is_ts_ordered FROM crypto\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"is_ts_ordered"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"true")))),(0,i.kt)("p",null,"And despite the fact that I introduced a random network delay on the Gemini\nprice feed, you can see that Bitcoin price from the two exchanges are committed\nin order."),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"In a more realistic scenario, we would run different services on the cloud to\npull data from various exchanges without intentional network delays. Once we\nfigure out a pattern in terms of API response times or lags, we can optimize\nthis process even further by\n",(0,i.kt)("a",{parentName:"p",href:"/docs/guides/out-of-order-commit-lag"},"tweaking the commit lag variables")," on\nQuestDB."),(0,i.kt)("p",null,"Specifying this known lag interval can reduce the compute resources QuestDB uses\nto sort out of order data then merging with persisted data to achieve higher\nthroughput:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# via env variables\ndocker run -p 8812:8812 -p 9000:9000 -p 9009:9009 \\\n  -e QDB_CAIRO_MAX_UNCOMMITTED_ROWS=1000 \\\n  -e QDB_CAIRO_COMMIT_LAG=20000 questdb/questdb\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"-- via SQL\nALTER TABLE crypto SET PARAM maxUncommittedRows = 10000\n")),(0,i.kt)("p",null,"For a project requiring high-throughput and performance needs, QuestDB provides\nnice features to enjoy the best of both worlds: fast ingestion via InfluxDB line\nprotocol without worrying about data being out or order with full SQL support to\nanalyze and act on that data. As with\n",(0,i.kt)("a",{parentName:"p",href:"/blog/2021/02/18/realtime-crypto-tracker-with-kafka-and-questdb"},"the Kafka project"),",\nfeel free to connect it with your account to execute trades with the price data\nor build out more sophisticated statistical models."),(0,i.kt)("p",null,"If you like this content, we'd love to know your thoughts! Feel free to share\nyour feedback or come and say hello in the\n",(0,i.kt)("a",{parentName:"p",href:"https://"},"QuestDB Community Slack"),"."))}m.isMDXComponent=!0},86010:function(e,t,n){function a(e){var t,n,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(r&&(r+=" "),r+=n);else for(t in e)e[t]&&(r&&(r+=" "),r+=t);return r}function r(){for(var e,t,n=0,r="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(r&&(r+=" "),r+=t);return r}n.d(t,{Z:function(){return r}})}}]);
"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[5010],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),f=p(n),m=a,d=f["".concat(s,".").concat(m)]||f[m]||u[m]||i;return n?r.createElement(d,o(o({ref:t},c),{},{components:n})):r.createElement(d,o({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},68637:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return f}});var r=n(83117),a=n(80102),i=(n(67294),n(3905)),o=n(72525),l=["components"],s={title:"Telegraf",description:"Learn how to use Telegraf to collect system metrics and send this data to QuestDB."},p={unversionedId:"third-party-tools/telegraf",id:"third-party-tools/telegraf",isDocsHomePage:!1,title:"Telegraf",description:"Learn how to use Telegraf to collect system metrics and send this data to QuestDB.",source:"@site/docs/third-party-tools/telegraf.md",sourceDirName:"third-party-tools",slug:"/third-party-tools/telegraf",permalink:"/docs/third-party-tools/telegraf",editUrl:"https://github.com/turpleio/homepage/edit/main/docs/third-party-tools/telegraf.md",version:"current",frontMatter:{title:"Telegraf",description:"Learn how to use Telegraf to collect system metrics and send this data to QuestDB."},sidebar:"docs",previous:{title:"JDBC connector",permalink:"/docs/third-party-tools/kafka/jdbc"},next:{title:"Storage model",permalink:"/docs/concept/storage-model"}},c=[{value:"Prerequisites",id:"prerequisites",children:[]},{value:"Configuring Telegraf",id:"configuring-telegraf",children:[{value:"Example Inputs",id:"example-inputs",children:[]}]},{value:"Writing to QuestDB over TCP",id:"writing-to-questdb-over-tcp",children:[]},{value:"Verifying the integration",id:"verifying-the-integration",children:[{value:"Graphing system CPU",id:"graphing-system-cpu",children:[]}]}],u={toc:c};function f(e){var t=e.components,n=(0,a.Z)(e,l);return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://docs.influxdata.com/telegraf/v1.17/"},"Telegraf")," is a client for\ncollecting metrics from many inputs and has support for sending it on to various\noutputs. It is plugin-driven for the collection and delivery of data, so it is\neasily configurable and customizable. Telegraf is compiled as a standalone\nbinary, which means there are no external dependencies required to manage."),(0,i.kt)("p",null,"QuestDB supports ingesting from Telegraf over TCP. This page provides examples\nfor collecting CPU and memory usage metrics using Telegraf and sends these metrics\nto a locally-running QuestDB instance for querying and visualization."),(0,i.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"QuestDB")," must be running and accessible. You can do so from\n",(0,i.kt)("a",{parentName:"p",href:"/docs/get-started/docker"},"Docker"),", the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/get-started/binaries"},"binaries"),", or\n",(0,i.kt)("a",{parentName:"p",href:"/docs/get-started/homebrew"},"Homebrew")," for macOS users.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Telegraf")," can be installed using\n",(0,i.kt)("a",{parentName:"p",href:"https://formulae.brew.sh/formula/telegraf"},"homebrew"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://hub.docker.com/_/telegraf"},"docker"),", or directly as a binary. For more\ndetails, refer to the official Telegraf\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.influxdata.com/telegraf/v1.17/introduction/installation/"},"installation instructions"),"."))),(0,i.kt)("h2",{id:"configuring-telegraf"},"Configuring Telegraf"),(0,i.kt)("p",null,"As Telegraf is a plugin-driven agent, the configuration file provided when\nTelegraf is launched will determine which metrics to collect, if and how\nprocessing of the metrics should be performed, and the destination outputs."),(0,i.kt)("p",null,"The default location that Telegraf can pick up configuration files is\n",(0,i.kt)("inlineCode",{parentName:"p"},"/usr/local/etc/")," on macOS and ",(0,i.kt)("inlineCode",{parentName:"p"},"/etc/telegraf/")," on Linux. After installation,\ndefault configuration files are in the following locations:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Homebrew install: ",(0,i.kt)("inlineCode",{parentName:"li"},"/usr/local/etc/telegraf.conf")),(0,i.kt)("li",{parentName:"ul"},"Linux, Deb and RPM: ",(0,i.kt)("inlineCode",{parentName:"li"},"/etc/telegraf/telegraf.conf"))),(0,i.kt)("p",null,"Full configuration files for writing over TCP are provided below and can\nbe placed in these directories and picked up by Telegraf. To view a\ncomprehensive configuration file with example inputs and outputs, the following\ncommand can generate an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"telegraf -sample-config > example.conf\n")),(0,i.kt)("h3",{id:"example-inputs"},"Example Inputs"),(0,i.kt)("p",null,"The examples on this page will use input plugins that read CPU and memory usage\nstatistics of the host machine and send this to the outputs specified in the\nconfiguration file. The following snippet includes code comments which describe\nthe inputs in more detail:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell",metastring:'title="Example inputs sending host data to QuestDB"',title:'"Example',inputs:!0,sending:!0,host:!0,data:!0,to:!0,'QuestDB"':!0},"...\n# -- INPUT PLUGINS -- #\n[[inputs.cpu]]\n  # Read metrics about cpu usage\n  ## Whether to report per-cpu stats or not\n  percpu = true\n  ## Whether to report total system cpu stats or not\n  totalcpu = true\n  ## If true, collect raw CPU time metrics\n  collect_cpu_time = false\n  ## If true, compute and report the sum of all non-idle CPU states\n  report_active = false\n\n# Read metrics about memory usage\n[[inputs.mem]]\n  # no customisation\n")),(0,i.kt)("h2",{id:"writing-to-questdb-over-tcp"},"Writing to QuestDB over TCP"),(0,i.kt)("p",null,"QuestDB expects influx line protocol messages over TCP on port ",(0,i.kt)("inlineCode",{parentName:"p"},"9009"),". To change\nthe default port, see the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/configuration#influxdb-line-protocol-tcp"},"InfluxDB line protocol (TCP)"),"\nsection of the server configuration page."),(0,i.kt)("p",null,"Create a new file named ",(0,i.kt)("inlineCode",{parentName:"p"},"questdb_tcp.conf")," in one of the locations Telegraf can\nload configuration files from and paste the following example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell",metastring:'title="/path/to/telegraf/config/questdb_tcp.conf"',title:'"/path/to/telegraf/config/questdb_tcp.conf"'},'# Configuration for Telegraf agent\n[agent]\n  ## Default data collection interval for all inputs\n  interval = "5s"\n  hostname = "qdb"\n\n# -- OUTPUT PLUGINS -- #\n[[outputs.socket_writer]]\n  # Write metrics to a local QuestDB instance over TCP\n  address = "tcp://127.0.0.1:9009"\n\n# -- INPUT PLUGINS -- #\n[[inputs.cpu]]\n  percpu = true\n  totalcpu = true\n  collect_cpu_time = false\n  report_active = false\n[[inputs.mem]]\n  # no customisation\n')),(0,i.kt)("p",null,"Run Telegraf and specify this config file with TCP writer settings:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"telegraf --config questdb_tcp.conf\n")),(0,i.kt)("p",null,"Telegraf should report the following if configured correctly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"2021-01-29T12:11:32Z I! Loaded inputs: cpu mem\n2021-01-29T12:11:32Z I! Loaded aggregators:\n2021-01-29T12:11:32Z I! Loaded processors:\n2021-01-29T12:11:32Z I! Loaded outputs: socket_writer\n...\n")),(0,i.kt)("h2",{id:"verifying-the-integration"},"Verifying the integration"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Navigate to the QuestDB Web Console at\n",(0,i.kt)("a",{parentName:"li",href:"http://127.0.0.1:9000/"},"http://127.0.0.1:9000/"),". The Schema Navigator in the\ntop left should display two new tables:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cpu")," generated from ",(0,i.kt)("inlineCode",{parentName:"li"},"inputs.cpu")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mem")," generated from ",(0,i.kt)("inlineCode",{parentName:"li"},"inputs.mem"))),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"Type ",(0,i.kt)("inlineCode",{parentName:"li"},"cpu")," in the query editor and click ",(0,i.kt)("strong",{parentName:"li"},"RUN"))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"cpu")," table will have a column for each metric collected by the Telegraf\nplugin for monitoring memory:"),(0,i.kt)(o.Z,{alt:"Querying CPU metrics using the QuestDB Web Console",src:"/img/docs/telegraf/select_from_cpu.png",width:745,height:375,mdxType:"Screenshot"}),(0,i.kt)("h3",{id:"graphing-system-cpu"},"Graphing system CPU"),(0,i.kt)("p",null,"To create a graph that visualizes CPU usage over time, run the following example\nquery:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"SELECT\navg(usage_system) cpu_average,\nmax(usage_system) cpu_max,\ntimestamp\nFROM cpu SAMPLE BY 1m;\n")),(0,i.kt)("p",null,"Select the ",(0,i.kt)("strong",{parentName:"p"},"Chart")," tab and set the following values:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Chart type ",(0,i.kt)("strong",{parentName:"li"},"line")),(0,i.kt)("li",{parentName:"ul"},"Labels ",(0,i.kt)("strong",{parentName:"li"},"timestamp")),(0,i.kt)("li",{parentName:"ul"},"Series ",(0,i.kt)("strong",{parentName:"li"},"cpu_average")," and ",(0,i.kt)("strong",{parentName:"li"},"cpu_max"))),(0,i.kt)(o.Z,{alt:"Graphing CPU metrics using the QuestDB Web Console",src:"/img/docs/telegraf/cpu_stats_chart.png",width:745,height:375,mdxType:"Screenshot"}))}f.isMDXComponent=!0},86010:function(e,t,n){function r(e){var t,n,a="";if("string"==typeof e||"number"==typeof e)a+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=r(e[t]))&&(a&&(a+=" "),a+=n);else for(t in e)e[t]&&(a&&(a+=" "),a+=t);return a}function a(){for(var e,t,n=0,a="";n<arguments.length;)(e=arguments[n++])&&(t=r(e))&&(a&&(a+=" "),a+=t);return a}n.d(t,{Z:function(){return a}})}}]);
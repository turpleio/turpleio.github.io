"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[4478],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return h}});var n=a(67294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=n.createContext({}),u=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=u(a),h=s,p=m["".concat(l,".").concat(h)]||m[h]||c[h]||r;return a?n.createElement(p,i(i({ref:t},d),{},{components:a})):n.createElement(p,i({ref:t},d))}));function h(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=a.length,i=new Array(r);i[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var u=2;u<r;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},29740:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},metadata:function(){return u},toc:function(){return d},default:function(){return m}});var n=a(83117),s=a(80102),r=(a(67294),a(3905)),i=a(72525),o=["components"],l={title:"Comparing InfluxDB and QuestDB databases",arthor:"Brian Smith",author_title:"QuestDB Team",author_url:"https://github.com/bsmth",author_image_url:"https://avatars.githubusercontent.com/bsmth",description:"An overview of InfluxDB versus QuestDB to compare features, functionality, performance, and ease of use.",keywords:["timeseries","influxdb","questdb","comparison","database"],tags:["tutorial","benchmark","influxdb","comparison"],image:"/img/blog/shared/og-influxdb.png"},u={permalink:"/blog/2021/11/29/questdb-versus-influxdb",source:"@site/blog/2021-11-29-questdb-versus-influxdb.mdx",title:"Comparing InfluxDB and QuestDB databases",description:"An overview of InfluxDB versus QuestDB to compare features, functionality, performance, and ease of use.",date:"2021-11-29T00:00:00.000Z",formattedDate:"November 29, 2021",tags:[{label:"tutorial",permalink:"/blog/tags/tutorial"},{label:"benchmark",permalink:"/blog/tags/benchmark"},{label:"influxdb",permalink:"/blog/tags/influxdb"},{label:"comparison",permalink:"/blog/tags/comparison"}],readingTime:9.91,truncated:!1,prevItem:{title:"QuestDB 6.1.3 December release, Prometheus improvements",permalink:"/blog/2021/12/20/release-prometheus-alertmanager"},nextItem:{title:"A tour of high-frequency finance via the Julia language and QuestDB",permalink:"/blog/2021/11/22/high-frequency-finance-introduction-julia-lang"}},d=[{value:"What are the data models used in InfluxDB and QuestDB",id:"what-are-the-data-models-used-in-influxdb-and-questdb",children:[]},{value:"Comparing database storage models",id:"comparing-database-storage-models",children:[]},{value:"Ease of use of SQL compared to custom query languages",id:"ease-of-use-of-sql-compared-to-custom-query-languages",children:[]},{value:"Measuring time series database performance",id:"measuring-time-series-database-performance",children:[]},{value:"How high-cardinality impacts ingestion rates",id:"how-high-cardinality-impacts-ingestion-rates",children:[]},{value:"Support and community",id:"support-and-community",children:[]},{value:"Choosing a database that fits",id:"choosing-a-database-that-fits",children:[]}],c={toc:d};function m(e){var t=e.components,a=(0,s.Z)(e,o);return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(i.Z,{alt:"Summary of benchmarking results of InfluxDB compared to QuestDB",height:385,src:"/img/blog/2021-11-29/banner.png",width:850,mdxType:"Screenshot"}),(0,r.kt)("p",null,"Time-series data is emerging as the dominant type of data produced in IoT,\nFinancial Services, Manufacturing, DevOps, monitoring, machine learning, and AI.\nTime series databases are specialized for storing and analyzing this kind of\ndata efficiently and quickly. This article compares QuestDB with InfluxDB to\nhelp understand the key differences so you can choose a time series database\nthat fits your use case."),(0,r.kt)("p",null,"The typical uses of time series databases are for:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Application performance, uptime, and response times"),(0,r.kt)("li",{parentName:"ul"},"Analyzing financial transactions and trades"),(0,r.kt)("li",{parentName:"ul"},"Monitoring network logs"),(0,r.kt)("li",{parentName:"ul"},"Asset tracking"),(0,r.kt)("li",{parentName:"ul"},"E-commerce transaction data, sales insights, BI reports"),(0,r.kt)("li",{parentName:"ul"},"Sensor data from IoT devices")),(0,r.kt)("p",null,"While the traditional use of databases was to store the last-known state of a\nsystem, this only shows a snapshot of a point in time. In contrast, time series\ndata adds a historical dimension to help understand how information changes."),(0,r.kt)("p",null,"Understanding how information changes over time help make predictions about your\ndata, gain deeper insights into trends, and be better prepared for future\nvariations. For this reason, developers need a time-series database that's\nrobust, easy to use, and powerful. Importantly, it must be flexible enough to be\nused across different scenarios, industries, and use cases."),(0,r.kt)("h2",{id:"what-are-the-data-models-used-in-influxdb-and-questdb"},"What are the data models used in InfluxDB and QuestDB"),(0,r.kt)("p",null,"One of the first places to begin comparing QuestDB and InfluxDB is how data is\nhandled and stored in each database. InfluxDB has a dedicated ",(0,r.kt)("strong",{parentName:"p"},"line protocol"),"\nmessage format for ingesting measurements. Each measurement has a timestamp, a\nset of tags (a tagset), and a set of fields (a fieldset)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},'measurementName,tagKey=tagValue fieldKey="fieldValue" 1465839830100399000\n--------------- --------------- --------------------- -------------------\n       |               |                  |                    |\n  Measurement         Tags              Fields             Timestamp\n')),(0,r.kt)("p",null,"In InfluxDB, tagset values are strings and are indexed, while fieldset values\nare not indexed. The data types that fields may use are limited to floats, ints,\nstrings, and booleans. The following snippet is an example message in InfluxDB\nline protocol for illustration:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sensors,location=london,version=REV-2.1 temperature=22,humidity=50 1465839830100399000\\n\n")),(0,r.kt)("p",null,"QuestDB supports InfluxDB line protocol for compatibility purposes, so inserts\nusing InfluxDB line protocol match the data types available. QuestDB supports\nadditional numeric types, such as bytes for 8-bit integers, shorts for 16-bit\nintegers, float for 32-bit floats, and long256 for larger integers. Additional\ntypes can be used while ingesting InfluxDB line protocol by creating a table\nwith a desired schema before starting to write data."),(0,r.kt)("p",null,"QuestDB also exposes PostgreSQL wire protocol and a REST API for inserts,\nallowing for more control over the data types that the system can handle,\nincluding additional types such as date, char, and binary. In QuestDB, it's also\npossible to add indexes and to existing columns in tables, which can be done\ndirectly through SQL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"ALTER TABLE sensors ALTER COLUMN firmware ADD INDEX;\n")),(0,r.kt)("p",null,'QuestDB has full support for relational queries, whereas InfluxDB is a NoSQL,\nnon-relational database with a custom data model. QuestDB supports both\nschema-agnostic ingestion over InfluxDB line protocol and a relational data\nmodel. Users can leverage both paradigms and perform SQL JOINs to correlate\n"schemaless" data with relational data by timestamp.'),(0,r.kt)(i.Z,{alt:"A combination of schema-agnostic ingestion and relational data stored and queried in QuestDB",height:385,src:"/img/blog/2021-11-29/relational-and-schema-agnostic.png",width:850,mdxType:"Screenshot"}),(0,r.kt)("h2",{id:"comparing-database-storage-models"},"Comparing database storage models"),(0,r.kt)("p",null,"For storage, InfluxDB uses Time-Structured Merge Trees (TSM) where data is\nstored in a columnar format, and the storage engine stores differences (or\n",(0,r.kt)("em",{parentName:"p"},"deltas"),") between values in a series. For indexing, InfluxDB uses a Time Series\nIndex intended to keep queries fast as cardinality grows. Still, the efficiency\nof this index has its limitations, explored in more detail in the\nHigh-Cardinality section below."),(0,r.kt)("p",null,"QuestDB also uses columnar data structures but indexes data in vector-based\nappend-only column files. As of QuestDB version 6.0, sorting out-of-order data\noccurs in a staging area in-memory, merging sorted and persisted data at commit\ntime using an append model. The reason for sorting in-memory and merging with\npersisted data in this way is to keep the storage engine performant on both read\nand write operations."),(0,r.kt)("p",null,"InfluxDB has a shard group concept as a strategy for partitioning, which allows\nfor grouping data by time. Users can provide a\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.influxdata.com/influxdb/v2.0/reference/internals/shards/#shard-group-duration"},"shard group duration"),"\nwhich defines how large a shard will be and can enable common operations such as\nretention periods for data (deleting data older than X days, for example):"),(0,r.kt)(i.Z,{alt:"An illystration of shard groups in InfluxDB",height:385,src:"/img/blog/2021-11-29/shard-groups.png",width:850,mdxType:"Screenshot"}),(0,r.kt)("p",null,"QuestDB has similar functionality to partition tables by time, and users may\nspecify a partition size for tables based on days, months, or years. When tables\nare partitioned by time, table metadata table is defined once per table, and\ncolumn files are partitioned at the filesystem level into directories per\npartition:"),(0,r.kt)(i.Z,{alt:"A diagram showing the column-based storage model of QuestDB",height:385,src:"/img/blog/2021-11-29/questdb-storage-model.png",width:850,mdxType:"Screenshot"}),(0,r.kt)("p",null,"Both QuestDB and InfluxDB have ways to partition data by time and employ a\nretention strategy. The difference in partitioning for each system is the\nbroader terminology, and the fact that QuestDB does not need to create\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.influxdata.com/influxdb/v2.0/reference/internals/shards/#shards"},"separate TSM files on disk"),"\nper partition."),(0,r.kt)("h2",{id:"ease-of-use-of-sql-compared-to-custom-query-languages"},"Ease of use of SQL compared to custom query languages"),(0,r.kt)("p",null,"The emergence of NoSQL as a popular paradigm has effectively split databases\ninto two categories: SQL and NoSQL. InfluxDB originally started with a language\nsimilar to SQL called InfluxQL, which balanced some aspects of SQL with custom\nsyntax. InfluxDB eventually adopted Flux as a query language to interact with\ndata."),(0,r.kt)("p",null,"QuestDB embraces SQL as the primary query language so that there is no need for\nlearning custom query languages. SQL is a good choice for time-series databases;\nit's easy to understand, most developers are familiar with it already, and SQL\nskills are simple to apply across different systems. As reported by the Stack\nOverflow developer survey of 2020, it's the third most popular language used by\ndevelopers. It proves to be a long-standing choice for quickly asking questions\nabout the characteristics of your data."),(0,r.kt)("p",null,"Flux enables you to work with InfluxDB more efficiently, but it's difficult to\nread, and it's harder to learn and onboard new users. From users' perspective,\nlearning a new custom query language is inconvenient for accessibility\nregardless of their engineering background."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'from(bucket:"example-bucket")\n  |> range(start:-1h)\n  |> filter(fn:(r) =>\n    r._measurement == "cpu" and\n    r.cpu == "cpu-total"\n  )\n  |> aggregateWindow(every: 1m, fn: mean)\n')),(0,r.kt)("p",null,"Consider that the Flux query above can be written in SQL as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"SELECT avg(cpu), avg(cpu-total) FROM 'example-bucket'\nWHERE timestamp > dateadd('h', -1, now())\nSAMPLE BY 1m\n")),(0,r.kt)("p",null,"Users who have no developer background will have a barrier of entry, making it\ndifficult to use standard BI tools to gain insights on time series data. SQL is\na time-tested language that those without engineering backgrounds can pick up\nquickly."),(0,r.kt)("h2",{id:"measuring-time-series-database-performance"},"Measuring time series database performance"),(0,r.kt)("p",null,"Let's compare how QuestDB and InfluxDB operate in terms of performance. The\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/timescale/tsbs"},"Time Series Benchmark Suite")," (TSBS)\nregularly appears in discussions about database performance. The TSBS is a\ncollection of Go programs to generate datasets and then benchmark read and write\nperformance. The suite is extensible so that different use cases and query types\ncan be included and compared across systems. To generate data for these\nbenchmarks, commands look like the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'# Generating the dataset\ntsbs_generate_data --seed=123 --scale=4000 \\\n  --timestamp-start="2016-01-01T00:00:00Z" --timestamp-end="2016-01-02T00:00:00Z" \\\n  --log-interval="10s" --use-case="cpu-only" --format="influx" > /tmp/bigcpu\n# Loading the data\ntsbs_load_questdb --file /tmp/bigcpu --workers 4\n')),(0,r.kt)("p",null,"The data produced from ",(0,r.kt)("inlineCode",{parentName:"p"},"tsbs_generate_data")," above has the following features:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"4000 unique devices (scale)"),(0,r.kt)("li",{parentName:"ul"},"500MB data set"),(0,r.kt)("li",{parentName:"ul"},"24 hours worth of simulated data"),(0,r.kt)("li",{parentName:"ul"},"InfluxDB line protocol")),(0,r.kt)("p",null,"This is an example of the first few lines from the generated data set:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},'"hostname","region","datacenter","rack","os","arch","team","service","service_version","service_environment","usage_user","usage_system","usage_idle","usage_nice","usage_iowait","usage_irq","usage_softirq","usage_steal","usage_guest","usage_guest_nice","timestamp"\n"host_0","eu-central-1","eu-central-1a","6","Ubuntu15.10","x86","SF","19","1","test",58,2,24,61,22,63,6,44,80,38,"2016-01-01T00:00:00.000000Z"\n"host_1","us-west-1","us-west-1a","41","Ubuntu15.10","x64","NYC","9","1","staging",84,11,53,87,29,20,54,77,53,74,"2016-01-01T00:00:00.000000Z"\n"host_2","sa-east-1","sa-east-1a","89","Ubuntu16.04LTS","x86","LON","13","0","staging",29,48,5,63,17,52,60,49,93,1,"2016-01-01T00:00:00.000000Z"\n')),(0,r.kt)("p",null,"QuestDB reaches maximum ingestion performance using four threads, whereas\nInfluxDB requires more workers to hit maximum throughput. QuestDB achieves 959k\nrows/sec with four threads, whereas InfluxDB needs 14 threads to reach its max\ningestion rate (334k rows/sec)."),(0,r.kt)(i.Z,{alt:"Ingestion results comparing QuestDB and InfluxDB using the time series benchmark suite",height:385,src:"/img/blog/2021-11-29/timeseries-benchmark-suite-results.png",width:650,mdxType:"Screenshot"}),(0,r.kt)("h2",{id:"how-high-cardinality-impacts-ingestion-rates"},"How high-cardinality impacts ingestion rates"),(0,r.kt)("p",null,"Cardinality typically refers to the number of elements in a set's size. In the\ncontext of a time series database (TSDB), high-cardinality boils down to many\nindexed columns in a table and each indexed column containing many unique\nvalues."),(0,r.kt)("p",null,"High-cardinality is a known problem area for InfluxDB, and this is likely\nbecause of the system architecture and storage engine. InfluxDB uses data\nstructures based on LSM-trees which are known to perform poorly in\nhigh-cardinality scenarios. In QuestDB, the storage model is radically different\nfrom LSM trees or B-trees and instead uses data stored in densely ordered\nvectors on disk."),(0,r.kt)("p",null,"We ran the TSBS benchmark specifying different scale values for multiple data\nsets and tested ingestion using up to sixteen threads to determine the maximum\nthroughput of each system and to get an idea of how ingestion rates change over\ntime:"),(0,r.kt)(i.Z,{alt:"High-cardinality results comparing QuestDB and InfluxDB using the time series benchmark suite",height:385,src:"/img/blog/2021-11-29/timeseries-benchmark-high-cardinality.png",width:850,title:"TSBS load benchmark maximum throughput results on AWS m5.8xlarge instance (4 threads)",mdxType:"Screenshot"}),(0,r.kt)("p",null,"With low cardinality data sets, QuestDB hits maximum ingestion throughput of\n904k rows/sec, and at 10 million unique devices, QuestDB sustains 640k rows/sec.\nInfluxDB ingestion starts at 220k rows/sec on 100 devices and reached 38k\nrows/sec on the 10M device dataset."),(0,r.kt)("p",null,"As we ran high-cardinality data sets, InfluxDB struggled to keep up with\ninserts. The bottleneck is likely due to the use of Time-Structured Merge Trees.\nThe issues manifested at first in degraded ingestion rates, but eventually,\nout-of-memory errors begin to appear at runtime. We provided more workers to the\nsystems under test to investigate if adding more threads would offer more\nstability, however InfluxDB was unable to finish the tests with 10M devices:"),(0,r.kt)(i.Z,{alt:"High-cardinality results comparing QuestDB and InfluxDB using the time series benchmark suite",height:385,src:"/img/blog/2021-11-29/timeseries-benchmark-suite-throughput.png",width:850,title:"TSBS load benchmark maximum throughput results on AWS m5.8xlarge instance (16 threads)",mdxType:"Screenshot"}),(0,r.kt)("p",null,"InfluxDB requires a lot more threads to be able to handle high-cardinality data,\nbut there are diminishing returns on adding more workers, revealing that there\nare underlying barriers which are not overcome by providing more threads to the\nsystem."),(0,r.kt)("p",null,"QuestDB handles high-cardinality better with more threads. When cardinality is\nlow, fewer workers lead to an overall higher maximum throughput, but a steeper\ndrop in ingestion rates when going from 1M devices to 10M."),(0,r.kt)("h2",{id:"support-and-community"},"Support and community"),(0,r.kt)("p",null,"The community is vital to QuestDB so that beginners have an environment that\nencourages getting up and running quickly. Experienced users have channels for\nraising technical questions or bugs with the engineering team or other power\nusers. We have a growing Slack workspace with over 900 members who discuss how\nthey are using QuestDB daily to power their businesses. Our mission is to solve\nthe problems users have with time series data. To achieve that, we are driven to\nunderstand the pain points that arise from practical scenarios, and we have the\ncommunity as a force that informs our product roadmap."),(0,r.kt)("p",null,"We designed QuestDB to sidestep custom query languages that require specialist\nknowledge to understand. We believe that it should be easy to ask questions\nabout how your own data looks and changes. Support, community forums, and online\nresources are a treasure trove of many decades of knowledge working with SQL\nwhich directly transfers to using QuestDB. If you are new to QuestDB (or SQL),\nit's easy to get started by means of online resources, tutorials, and the\nexpertise shared by our community. For seasoned SQL experts, there is no\nlearning curve except for time-based calculations and analysis specific for time\nseries."),(0,r.kt)("h2",{id:"choosing-a-database-that-fits"},"Choosing a database that fits"),(0,r.kt)("p",null,"We want to make sure engineers can pick the right tool for the job and have\nhighlighted some key differentiators between QuestDB and InfluxDB. If there are\nsuggestions for improving this comparison, we'd be happy to include this in our\nanalysis."))}m.isMDXComponent=!0},86010:function(e,t,a){function n(e){var t,a,s="";if("string"==typeof e||"number"==typeof e)s+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(a=n(e[t]))&&(s&&(s+=" "),s+=a);else for(t in e)e[t]&&(s&&(s+=" "),s+=t);return s}function s(){for(var e,t,a=0,s="";a<arguments.length;)(e=arguments[a++])&&(t=n(e))&&(s&&(s+=" "),s+=t);return s}a.d(t,{Z:function(){return s}})}}]);
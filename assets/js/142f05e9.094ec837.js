"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[8226],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=u(n),m=r,d=h["".concat(s,".").concat(m)]||h[m]||p[m]||i;return n?a.createElement(d,o(o({ref:t},c),{},{components:n})):a.createElement(d,o({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},44809:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return u},metadata:function(){return c},toc:function(){return p},default:function(){return m}});var a=n(83117),r=n(80102),i=(n(67294),n(3905)),o=n(46092),l=n(72525),s=["components"],u={title:"How we built a SIMD JIT compiler for SQL in QuestDB",author:"Andrey Pechkurov",author_title:"Co-authored by Eugene Lysyuchenko",author_url:"https://github.com/puzpuzpuz",author_image_url:"https://avatars.githubusercontent.com/puzpuzpuz",description:"QuestDB 6.2.0 brings a brand new JIT (Just-in-Time) compiler as a part of the SQL engine. This post describes our storage model, how we built a JIT compiler for SQL and our plans for improving it in future.",keywords:["jit","compiler","performance","timeseries","database","engineering"],image:"/img/blog/2022-01-12/banner.png",tags:["engineering","story","performance"]},c={permalink:"/blog/2022/01/12/jit-sql-compiler",source:"@site/blog/2022-01-12-jit-sql-compiler.md",title:"How we built a SIMD JIT compiler for SQL in QuestDB",description:"QuestDB 6.2.0 brings a brand new JIT (Just-in-Time) compiler as a part of the SQL engine. This post describes our storage model, how we built a JIT compiler for SQL and our plans for improving it in future.",date:"2022-01-12T00:00:00.000Z",formattedDate:"January 12, 2022",tags:[{label:"engineering",permalink:"/blog/tags/engineering"},{label:"story",permalink:"/blog/tags/story"},{label:"performance",permalink:"/blog/tags/performance"}],readingTime:9.695,truncated:!0,prevItem:{title:"QuestDB 6.2 January release, SQL JIT compiler",permalink:"/blog/2022/01/27/release-sql-jit-compiler"},nextItem:{title:"Our two-year journey to raise $15m in venture capital",permalink:"/blog/2022/01/03/two-year-journey-raising-15m-venture-capital"}},p=[{value:"Pre-JIT filtering",id:"pre-jit-filtering",children:[]},{value:"JIT-based filtering",id:"jit-based-filtering",children:[]},{value:"How to use it",id:"how-to-use-it",children:[]},{value:"Performance impact",id:"performance-impact",children:[]},{value:"Next up",id:"next-up",children:[]}],h={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(o.Z,{alt:"Details of the latest QuestDB version which includes a JIT compiler for the SQL engine",height:360,src:"/img/blog/2022-01-12/banner.png",width:650,mdxType:"Banner"}),(0,i.kt)("p",null,"QuestDB 6.2.0 brings a brand new JIT (Just-in-Time) compiler as a part of the\nSQL engine. The compiler aims to significantly improve execution times for\nqueries with simple arithmetic expressions used to filter the data. It took us\n11K lines of code, 250+ commits, and plenty of coffee to ship it, and we'd like\nto share the story with you."),(0,i.kt)("p",null,"Before we dive into the implementation details behind our JIT compiler, let's\nunderstand what kind of problems JIT compilation aims to solve in our SQL engine\nand where exactly you should expect performance improvements."),(0,i.kt)("p",null,"It can often happen that analytical queries run by users end up performing a\nfull scan over a table or, at least, over some of its partitions. Here is an\nexample of such a query:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"SELECT *\nFROM trips\nWHERE pickup_datetime IN ('2009-01') AND total_amount > 150;\n")),(0,i.kt)("p",null,"The above query returns relatively expensive trips within one month from 10+\nyears of taxi data available on our ",(0,i.kt)("a",{parentName:"p",href:"https://demo.questdb.io/"},"live demo"),". To\nexecute this query, QuestDB has to scan 13.5 million rows. This means that the\ndatabase has to do many sequential reads from the column files and apply the\nfilter expression (think, ",(0,i.kt)("inlineCode",{parentName:"p"},"WHERE")," clause) to each value. There is a good chance\nthat the data is already in the page cache or the disk is fast enough not to\nbecome the bottleneck. Thus, the execution time for such queries has all chances\nto be limited by the CPU performance."),(0,i.kt)("p",null,"The pre-JIT implementation of filter expression evaluation in QuestDB is based\non the operator function call tree. The functions are nothing more than Java\nclasses you may find\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/questdb/questdb/tree/master/core/src/main/java/io/questdb/griffin/engine/functions"},"as part of the Griffin engine"),".\nThis approach is quite powerful and general, but it also has some disadvantages\nwe will cover."),(0,i.kt)("h2",{id:"pre-jit-filtering"},"Pre-JIT filtering"),(0,i.kt)("p",null,"As you may already know, QuestDB has a\n",(0,i.kt)("a",{parentName:"p",href:"https://questdb.io/docs/concept/storage-model"},"column-based storage model"),".\nData is stored in tables, with each column stored in its own file. For read-only\nqueries, columns with fixed-size data types are read by translating the record\nnumber into an offset in the column file by a simple bit shift. The offset is\nthen translated into an offset in a lazily mapped memory page, where the\nrequired value is read."),(0,i.kt)(l.Z,{alt:"A diagram showing the data model in QuestDB",height:598,src:"/img/blog/2022-01-12/data-model.png",width:650,mdxType:"Screenshot"}),(0,i.kt)("p",null,"This storage model allows queries that do a full or partial table scan to be\nperformed efficiently. The database interprets the filter expression during the\nquery evaluation, translates it into an operator function call tree, and then\nexecutes the query in a tight loop. In the case of our example query, the loop\nlooks something like the following Java code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public boolean hasNext() {\n    while (base.hasNext()) {\n        if (filter.getBool(record)) {\n            return true;\n        }\n    }\n    return false;\n}\n")),(0,i.kt)("p",null,"This method is called when the database iterates through the result set to send\nthe query result to the client. Here, the ",(0,i.kt)("inlineCode",{parentName:"p"},"filter")," is the top-level object from\nthe operator function call tree that we've mentioned. The ",(0,i.kt)("inlineCode",{parentName:"p"},"base")," is the data\nframe cursor responsible for the iteration through the column files, and the\n",(0,i.kt)("inlineCode",{parentName:"p"},"record")," is the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Flyweight_pattern"},"flyweight"),"\nobject that allows accessing column values for the current row. The call tree is\nminuscule in our example and only consists of three objects."),(0,i.kt)(l.Z,{alt:"A diagram showing a function call tree in QuestDB",height:598,src:"/img/blog/2022-01-12/object-tree.png",width:650,mdxType:"Screenshot"}),(0,i.kt)("p",null,"The top-level object called ",(0,i.kt)("inlineCode",{parentName:"p"},"LtDoubleFunction")," is our ",(0,i.kt)("inlineCode",{parentName:"p"},"filter")," object. This\nfunction is a comparison operator while ",(0,i.kt)("inlineCode",{parentName:"p"},"IntConstant")," (the ",(0,i.kt)("inlineCode",{parentName:"p"},"150")," constant\nliteral) and ",(0,i.kt)("inlineCode",{parentName:"p"},"DoubleColumn")," (the ",(0,i.kt)("inlineCode",{parentName:"p"},"total_amount")," column) are its operand\nfunctions. Notice that the ",(0,i.kt)("inlineCode",{parentName:"p"},"pickup_datetime IN ('2009-01')")," part of the query is\nnot present in the filter since QuestDB is smart enough to apply the predicate\nfor the\n",(0,i.kt)("a",{parentName:"p",href:"https://questdb.io/docs/concept/designated-timestamp/"},"designated timestamp"),"\ncolumn (",(0,i.kt)("inlineCode",{parentName:"p"},"pickup_datetime"),") to the underlying data frame cursor and remove it\nfrom the filter tree."),(0,i.kt)("p",null,"As you might have already guessed, the ",(0,i.kt)("inlineCode",{parentName:"p"},"filter.getBool(record)")," method call from\nthe Java snippet calls the filter tree hierarchy for each iterated row. When\ncalled, ",(0,i.kt)("inlineCode",{parentName:"p"},"LtDoubleFunction")," calls its operand function to obtain their values on\nthe current row, compares them, and returns the filter result to the outer loop.\nThe hierarchy and the number of nested calls may be arbitrarily large for\ncomplex SQL queries. JVM's (Java Virtual Machine) own JIT compiler does a great\njob optimizing the code, but it's possible to produce more efficient machine\ncode in this particular case. As we find out later, the difference between JVM's\nJIT output and our own machine code may be noticeable even for simple queries."),(0,i.kt)("p",null,'Another sub-optimal aspect here is that this way of filtering is "scalar", i.e.\nit navigates through the table row by row and applies the filter to a single row\nat a time. In many cases, the execution of the filter expressions could be\naccelerated by vectorized processing when\n',(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/SIMD"},"SIMD instructions")," are used to calculate\nthe filter result for multiple rows simultaneously."),(0,i.kt)("p",null,"Accordingly, we built the JIT compiler to solve the above problems and improve\nCPU usage efficiency for a certain class of SQL queries."),(0,i.kt)("h2",{id:"jit-based-filtering"},"JIT-based filtering"),(0,i.kt)("p",null,"QuestDB's JIT compiler consists of two major parts: the frontend and backend.\nThe frontend is written in Java and kicks in once an execution plan is built for\nthe query. Frontend's primary goal is to analyze whether the filter is suitable\nfor JIT compilation and serialize the filter abstract syntax tree to an\nintermediate representation (IR) along with necessary metadata. The IR is then\nprovided in a call to the backend, which finishes the compilation and emits\ncompact and efficient machine code for the filter function. When vectorized\nexecution is enabled, the filter from our example trips table query compiles to\n58 machine instructions."),(0,i.kt)("p",null,"The compiler backend itself is written in C++ and uses\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/asmjit/asmjit"},"asmjit")," library for machine code generation.\nCurrently, the backend works on x86-64 CPUs only and uses AVX2 instructions in\nthe compiled function when the CPU supports them."),(0,i.kt)("p",null,"The filter function is called on table page frames instead of individual rows.\nWhen the function uses SIMD instructions, the CPU core executes the query\nprocesses multiple rows simultaneously. For instance, for a filter on a single\nINT (32-bit signed integer) column, 8 rows would be processed concurrently since\nAVX2 registers are 256-bit. Once the filter result is calculated on these rows,\ntheir row IDs are appended to an intermediate array. Later, when all rows in the\npage frame are processed, the array is returned back to the Java code. This way,\nwe can benefit from batch processing and vectorized execution."),(0,i.kt)("p",null,"Apart from the supported CPUs, there are a few limitations in the first release\nof the JIT compiler. Only filters with arithmetical expressions for fixed-size\ncolumns are a subject for the compilation. We will expand the functionality of\nthe JIT compiler in future releases."),(0,i.kt)("h2",{id:"how-to-use-it"},"How to use it"),(0,i.kt)("p",null,"SQL JIT compiler is a beta feature and is disabled by default. To enable it, you\nshould change the ",(0,i.kt)("inlineCode",{parentName:"p"},"cairo.sql.jit.mode")," setting in your ",(0,i.kt)("inlineCode",{parentName:"p"},"server.conf")," file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ini",metastring:'title="path/to/server.conf"',title:'"path/to/server.conf"'},"cairo.sql.jit.mode=on\n")),(0,i.kt)("p",null,"Embedded API users are able to enable the compiler globally by providing their\n",(0,i.kt)("inlineCode",{parentName:"p"},"CairoConfiguration")," implementation. Alternatively, JIT compilation can be\nenabled for a single query by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"SqlExecutionContext#setJitMode")," method.\nThe latter may look like the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'final CairoConfiguration configuration = new DefaultCairoConfiguration(temp.getRoot().getAbsolutePath());\ntry (CairoEngine engine = new CairoEngine(configuration)) {\n    final SqlExecutionContextImpl ctx = new SqlExecutionContextImpl(engine, 1);\n    // Enable SQL JIT compiler\n    ctx.setJitMode(SqlJitMode.JIT_MODE_ENABLED);\n    // Subsequent query execution (called as usual) with have JIT enabled\n    try (SqlCompiler compiler = new SqlCompiler(engine)) {\n        try (RecordCursorFactory factory = compiler.compile("abc", ctx).getRecordCursorFactory()) {\n            try (RecordCursor cursor = factory.getCursor(ctx)) {\n                // ...\n            }\n        }\n    }\n}\n')),(0,i.kt)("p",null,"When QuestDB starts with the enabled JIT compiler feature, the server logs will\ncontain messages relating to ",(0,i.kt)("inlineCode",{parentName:"p"},"SQL JIT compiler")," like the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-log"},"2021-12-16T09:25:34.472450Z A server-main SQL JIT compiler mode: on\n2021-12-16T09:25:34.472475Z A server-main Note: JIT compiler mode is a beta feature.\n")),(0,i.kt)("p",null,"As already mentioned, JIT compilation won't take place for any query you run. To\nunderstand whether the compilation took place for a query, you should check the\nserver logs to contain something similar to this message:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-log"},"2021-12-16T09:35:01.742777Z I i.q.g.SqlCodeGenerator JIT enabled for (sub)query [tableName=trips, fd=62]\n")),(0,i.kt)("h2",{id:"performance-impact"},"Performance impact"),(0,i.kt)("p",null,"To get an idea of the performance improvements you can expect with JIT, we can\ndo some benchmarking. It's important to mention that your mileage may vary since\nperformance improvement provided by JIT compilation depends on many factors,\nsuch as exact software versions, hardware, table schema, and query. The below\nresults were obtained on a laptop with i7-1185G7, 32GB RAM, and an NVMe SSD\ndrive running Ubuntu 20.04 and OpenJDK 17.0.1."),(0,i.kt)("p",null,"We start with the query from our example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"SELECT *\nFROM trips\nWHERE pickup_datetime IN ('2009-01') AND total_amount > 150;\n")),(0,i.kt)("p",null,'These are the results of the average query execution time observed after several\nruns (so-called hot query execution). In this case, a "cold run" stands for the\nfirst query run, while "hot run" means a subsequent run where the table data is\nin the page cache.'),(0,i.kt)(l.Z,{alt:"A chart comparing query execution times in QuestDB with JIT enabled and disabled",height:598,src:"/img/blog/2022-01-12/cold-v-hot-run.png",width:650,mdxType:"Screenshot"}),(0,i.kt)("p",null,"The results show that the JIT compiler doesn't make any difference for cold\nruns, i.e., I/O-bound scenarios. Once the data is in the page cache, the query\nexecution becomes CPU-bound, and JIT reduces the time dramatically - by 76%\ncompared with the Java implementation."),(0,i.kt)("p",null,"If we do some back-of-the-envelope calculations, the on-disk size of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"total_amount")," column file in the 2009-01 partition is 110MB. Considering that\nthe query takes around 35ms when JIT is enabled, this yields almost 3.3 GB/s\nfiltering rate. In fact, it's even higher since the SQL engine also needs to do\nother steps when executing a query, like gathering the result set. In addition,\nwith more fine-grained benchmarks, we saw a filtering rate of 9.4 GB/s on the\nsame machine, which is not far away from its peak memory bandwidth (24.9 GB/s on\na single thread)."),(0,i.kt)("p",null,"Why don't we make the task much harder? To do this, we can remove the time\npredicate and run a query for trips with a total amount over a value for a\nsingle passenger across all years. This means a full table scan of 1.6 billion\nrows in total."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"SELECT count(), max(total_amount), avg(total_amount)\nFROM trips\nWHERE total_amount > 150 AND passenger_count = 1;\n")),(0,i.kt)("p",null,"The measurement results for this query are the following:"),(0,i.kt)(l.Z,{alt:"A chart comparing query execution times in QuestDB with JIT enabled and disabled",height:598,src:"/img/blog/2022-01-12/cold-v-hot-run-two.png",width:650,mdxType:"Screenshot"}),(0,i.kt)("p",null,"Once again, we see a significant improvement when the JIT compiler is enabled,\nand the data is in the page cache. Interestingly, due to a larger volume of the\ndata that has to be read from the disk, JIT also improves cold execution time."),(0,i.kt)("h2",{id:"next-up"},"Next up"),(0,i.kt)("p",null,"This is only the beginning for QuestDB's JIT compiler, and we have a lot of\nplans for its future improvements. First of all, we'd like to support ARM64 CPUs\nalong with the NEON instruction set. Next, we'd like to parallelize the query\nexecution when suitable to improve the execution time even further. Finally, we\nplan to expand the limitations on the supported filters and experiment with\npotential optimizations in the JIT compiler."),(0,i.kt)("p",null,"We encourage our users to try out the SQL JIT compiler feature on their\ndevelopment QuestDB instances and provide feedback in our\n",(0,i.kt)("a",{parentName:"p",href:"https://slack.questdb.io/"},"Slack Community"),". JIT compiler is also enabled on\nour ",(0,i.kt)("a",{parentName:"p",href:"https://demo.questdb.io/"},"live demo"),", so you may want to run some queries\nthere. And, of course, open-source contributions to our\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/questdb/questdb"},"project on GitHub")," are more than welcome."))}m.isMDXComponent=!0},86010:function(e,t,n){function a(e){var t,n,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(r&&(r+=" "),r+=n);else for(t in e)e[t]&&(r&&(r+=" "),r+=t);return r}function r(){for(var e,t,n=0,r="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(r&&(r+=" "),r+=t);return r}n.d(t,{Z:function(){return r}})}}]);
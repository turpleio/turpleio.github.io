"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[5468],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=p(n),h=i,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||o;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},26812:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return p},metadata:function(){return c},toc:function(){return d},default:function(){return h}});var a=n(83117),i=n(80102),o=(n(67294),n(3905)),s=n(46092),r=n(72525),l=["components"],p={title:"Monitoring the uptime of an application with Python, Nuxt.js and QuestDB",author:"G\xe1bor Boros",author_title:"Guest",author_url:"https://github.com/gabor-boros",author_image_url:"https://avatars.githubusercontent.com/gabor-boros",description:"This detailed tutorial shows how to use QuestDB in a robust application status page and includes a repository with the example code ready to deploy.",keywords:["timeseries","python","fastapi","nuxtjs","monitoring","uptime"],tags:["tutorial","python","fastapi","monitoring"],image:"/img/blog/shared/og-python.png"},c={permalink:"/blog/2021/01/13/application-uptime-monitoring-with-python-nuxtjs-questdb",source:"@site/blog/2021-01-13-application-uptime-monitoring-with-python-nuxtjs-questdb.mdx",title:"Monitoring the uptime of an application with Python, Nuxt.js and QuestDB",description:"This detailed tutorial shows how to use QuestDB in a robust application status page and includes a repository with the example code ready to deploy.",date:"2021-01-13T00:00:00.000Z",formattedDate:"January 13, 2021",tags:[{label:"tutorial",permalink:"/blog/tags/tutorial"},{label:"python",permalink:"/blog/tags/python"},{label:"fastapi",permalink:"/blog/tags/fastapi"},{label:"monitoring",permalink:"/blog/tags/monitoring"}],readingTime:17.945,truncated:!1,prevItem:{title:"A low-code bitcoin ticker built with QuestDB and n8n.io",permalink:"/blog/2021/01/18/low-code-bitcoin-ticker-workflow-with-time-series-database"},nextItem:{title:"SQL Extensions for Time-Series Data in QuestDB",permalink:"/blog/2021/01/11/sql-extensions-for-timeseries-data"}},d=[{value:"Why build a status page for an application?",id:"why-build-a-status-page-for-an-application",children:[]},{value:"What we will build",id:"what-we-will-build",children:[{value:"Overview",id:"overview",children:[]},{value:"Prerequisites",id:"prerequisites",children:[]}]},{value:"Setting up the environment",id:"setting-up-the-environment",children:[{value:"Create a new project",id:"create-a-new-project",children:[]},{value:"Installing QuestDB &amp; Redis",id:"installing-questdb--redis",children:[]},{value:"Install backend dependencies",id:"install-backend-dependencies",children:[]}]},{value:"Create a simple API",id:"create-a-simple-api",children:[]},{value:"Integrate QuestDB with FastAPI",id:"integrate-questdb-with-fastapi",children:[{value:"Set up the table",id:"set-up-the-table",children:[]},{value:"Connect QuestDB and FastAPI",id:"connect-questdb-and-fastapi",children:[]}]},{value:"Schedule monitoring tasks",id:"schedule-monitoring-tasks",children:[{value:"Scheduling with Celery",id:"scheduling-with-celery",children:[]},{value:"Create a monitoring task",id:"create-a-monitoring-task",children:[]}]},{value:"Implement the frontend",id:"implement-the-frontend",children:[{value:"Setting up frontend",id:"setting-up-frontend",children:[]},{value:"Cleaning up generated project",id:"cleaning-up-generated-project",children:[]}]},{value:"Run the project",id:"run-the-project",children:[]},{value:"Summary",id:"summary",children:[]}],u={toc:d};function h(e){var t=e.components,n=(0,i.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(s.Z,{alt:"A traffic light on a street corner with a green signal",height:433,src:"/img/blog/2021-01-13/banner.jpg",width:650,mdxType:"Banner"},"Photo by ",(0,o.kt)("a",{href:"https://unsplash.com/photos/i3tiM7n9_CE"},"Geoffrey Hauwen")," ","via ",(0,o.kt)("a",{href:"https://unsplash.com"},"Unsplash")),(0,o.kt)("p",null,"This submission comes from one of our community contributors\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gabor-boros"},"G\xe1bor Boros")," who has built an extremely robust\nstatuspage application which uses QuestDB as a data sink."),(0,o.kt)("p",null,"Thanks for your contribution, G\xe1bor!"),(0,o.kt)("h2",{id:"why-build-a-status-page-for-an-application"},"Why build a status page for an application?"),(0,o.kt)("p",null,"Highly available services that serve millions of requests rely on the visibility\nof the system status for customers and internal teams. This tutorial shows how a\nlightweight and performant time-series database coupled with queued status\nchecks and a simple UI are key ingredients for robust application monitoring."),(0,o.kt)("p",null,"Even if we design the most reliable systems, incidents will occur for\nhard-to-predict reasons. It's critical to provide as much information as\npossible to users, customers, and service teams. The most convenient way to\ndisplay this is through a status page."),(0,o.kt)("p",null,"Although the page's responsibility is to provide information, it can reduce the\nsupport team's load and eliminate duplicate support tickets. Status pages are a\ncrucial part of incident management, and usually, other teams enjoy benefits\nlike client and service owners when they need to refer to SLAs. In this\ntutorial, I'll show you how to build a simple yet powerful status page that\nscores well on performance and design."),(0,o.kt)("h2",{id:"what-we-will-build"},"What we will build"),(0,o.kt)("h3",{id:"overview"},"Overview"),(0,o.kt)("p",null,"As mentioned above, we will build a simple status page made of two parts: the\nbackend monitors our service, and a frontend shows our services' status on an\nhourly scale."),(0,o.kt)(r.Z,{alt:"A screenshot of a QuestDB website status indicator showing 100% uptime",height:284,src:"/img/blog/2021-01-13/end-result.png",title:"Finished statuspage indicator",width:650,mdxType:"Screenshot"}),(0,o.kt)("p",null,"You will need some experience in Python, JavaScript, and basic SQL knowledge. To\nbuild our service, we will use FastAPI, an ultra-fast Python web framework,\nCelery for scheduling monitoring tasks, QuestDB, the fastest open-source\ntime-series database, to store monitoring results, and NuxtJs to display them."),(0,o.kt)("p",null,"There's a lot to learn, so let's jump right in!"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"The containerized source code is available at ",(0,o.kt)("a",{parentName:"em",href:"https://github.com/gabor-boros/questdb-statuspage"},"https://github.com/gabor-boros/questdb-statuspage"),".")),(0,o.kt)("h3",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("p",null,"You will need to have the following installed on your machine:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Python 3.8"),(0,o.kt)("li",{parentName:"ul"},"NodeJS 14.x"),(0,o.kt)("li",{parentName:"ul"},"Docker"),(0,o.kt)("li",{parentName:"ul"},"Docker Compose")),(0,o.kt)("h2",{id:"setting-up-the-environment"},"Setting up the environment"),(0,o.kt)("h3",{id:"create-a-new-project"},"Create a new project"),(0,o.kt)("p",null,"First things first, we create a directory, called ",(0,o.kt)("inlineCode",{parentName:"p"},"status-page"),", this is our\nproject root. We also need to create another directory called ",(0,o.kt)("inlineCode",{parentName:"p"},"app")," which will\ncontain the backend code. After following these steps, you should have a project\nstructure like this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"status-page (project root)\n\u2514\u2500\u2500 app (backend service directory)\n")),(0,o.kt)("h3",{id:"installing-questdb--redis"},"Installing QuestDB & Redis"),(0,o.kt)("p",null,"Now, we will install QuestDB and Redis. QuestDB is used to store the HTTP status\nand the service state of our application over time, and Redis is used as a\nmessage broker between the backend application and the workers who will do the\nscheduled monitoring."),(0,o.kt)("p",null,"To install these services, we will use Docker and Docker Compose. We are going\nto create a ",(0,o.kt)("inlineCode",{parentName:"p"},"docker-compose.yml")," file within the project root with the following\ncontent:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'version: "3"\n\nvolumes:\n  questdb_data: {}\n\nservices:\n  redis:\n    image: "redis:latest"\n    ports:\n      - "6379:6379"\n\n  questdb:\n    image: "questdb/questdb:latest"\n    volumes:\n      # Map QuestDB\'s data directory to the host\n      - "questdb_data:/root/.questdb/db"\n    ports:\n      - "9000:9000"\n      - "8812:8812"\n')),(0,o.kt)("p",null,"Voila! When we run ",(0,o.kt)("inlineCode",{parentName:"p"},"docker-compose up"),", QuestDB and Redis start, and we can\naccess QuestDB's interactive console on\n",(0,o.kt)("a",{parentName:"p",href:"http://127.0.0.1:9000"},"http://127.0.0.1:9000"),"."),(0,o.kt)("h3",{id:"install-backend-dependencies"},"Install backend dependencies"),(0,o.kt)("p",null,"Now, we have the project structure, and we can run the required services, so we\nneed to set up our backend service to collect data about the website or service\nwe would like to monitor. We will use poetry to manage Python dependencies\nduring this tutorial, so let's start by installing that."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"$ pip install poetry\n")),(0,o.kt)("p",null,"To define the project requirements, create a ",(0,o.kt)("inlineCode",{parentName:"p"},"pyproject.toml")," file with the\nfollowing content:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'[tool.poetry]\nname = "status-page"\nversion = "0.1.0"\ndescription = "QuestDB tutorial for creating a simple status page."\nauthors = ["Your name <your.email@example.com>"]\nlicense = "MIT"\n\n[tool.poetry.dependencies]\npython = "^3.8"\n\n[build-system]\nrequires = ["poetry-core>=1.0.0"]\nbuild-backend = "poetry.core.masonry.api"\n')),(0,o.kt)("p",null,"In order to let the application communicate with QuestDB utilizing the\n",(0,o.kt)("inlineCode",{parentName:"p"},"psycopg")," client library, we need to install ",(0,o.kt)("inlineCode",{parentName:"p"},"libpq-dev")," package on our\nsystem. To install it, use your package manager; on Windows, you may need\nto install PostgreSQL on your system."),(0,o.kt)("p",null,"Then, install the project dependencies by executing the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'poetry add python fastapi pydantic uvicorn requests \\\n "psycopg[c,pool]" "celery[redis]"\n')),(0,o.kt)("p",null,"As you may assume by checking the requirements, we will use QuestDB's Postgres\ninterface to connect. When ",(0,o.kt)("inlineCode",{parentName:"p"},"poetry")," finishes its job, it will add the\ndependencies to ",(0,o.kt)("inlineCode",{parentName:"p"},"pyproject.toml")," and we can now start to implement the backend\nservice."),(0,o.kt)("h2",{id:"create-a-simple-api"},"Create a simple API"),(0,o.kt)("p",null,"The time has come, let's create the backend service, but step-by-step. Within\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"app")," directory, create an ",(0,o.kt)("inlineCode",{parentName:"p"},"__init__.py")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"main.py"),". The first one is\nresponsible for making the ",(0,o.kt)("inlineCode",{parentName:"p"},"app")," directory to a package, while the latter will\ndefine the APIs our service exposes. Open ",(0,o.kt)("inlineCode",{parentName:"p"},"main.py")," for edit and add the\nfollowing:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# main.py\n\nfrom fastapi import FastAPI\n\napp = FastAPI(\n    title="Status Page",\n    description="This service gives back the status of the configured URL.",\n    version="0.1.0",\n)\n')),(0,o.kt)("p",null,"Congratulations! You just created the backend service. You can go and try it out\nby executing:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"$ poetry run uvicorn app.main:app --host 127.0.0.1 --port 8000 --reload\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n...\nINFO:     Application startup complete.\n")),(0,o.kt)("p",null,"Although the service does nothing yet, it works and listens for any code change.\nAdd a new endpoint and watch it reload:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# main.py\n\n# ...\n\n@app.get(path="/signals", tags=["Monitoring"])\nasync def get_signals():\n  return {}\n')),(0,o.kt)("p",null,"We have now created an API endpoint that will serve the system status data of\nthe monitored URL. If you open\n",(0,o.kt)("a",{parentName:"p",href:"http://127.0.0.1:8000/redoc"},"http://127.0.0.1:8000/redoc"),", you can see the\ngenerated documentation for the endpoint, or you can check it working at\n",(0,o.kt)("a",{parentName:"p",href:"http://127.0.0.1:8000/signals"},"http://127.0.0.1:8000/signals"),", though it won't\nreturn any data yet."),(0,o.kt)("p",null,"It is time to have fun, we are going to integrate QuestDB with our shiny new\nbackend service."),(0,o.kt)("h2",{id:"integrate-questdb-with-fastapi"},"Integrate QuestDB with FastAPI"),(0,o.kt)("p",null,"Integrating QuestDB with FastAPI is easier than you think. Thanks to QuestDB's\n",(0,o.kt)("a",{parentName:"p",href:"/docs/reference/api/postgres"},"Postgres compatibility"),", you can use\nany standard or popular third-party libraries of any programming language which\nimplements Postgres wire protocol."),(0,o.kt)("h3",{id:"set-up-the-table"},"Set up the table"),(0,o.kt)("p",null,"The very first step is to create the table in QuestDB. As said before, our\napproach is simple, so that the table is simple, too. QuestDB is running from\nour docker compose script so, we open the interactive console at\n",(0,o.kt)("a",{parentName:"p",href:"http://127.0.0.1:9000"},"http://127.0.0.1:9000")," and create a new table by running\nthe following query:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE\n    signals(url STRING, http_status INT, received TIMESTAMP, available BOOLEAN)\n    timestamp(received);\n")),(0,o.kt)("p",null,"The query executes, and after refreshing the table list on the left, you can see\nthe table we created."),(0,o.kt)(r.Z,{alt:"Running an SQL query in the web console of QuestDB",height:284,src:"/img/blog/2021-01-13/interactive-console.png",title:"Finished statuspage indicator",width:650,mdxType:"Screenshot"}),(0,o.kt)("h3",{id:"connect-questdb-and-fastapi"},"Connect QuestDB and FastAPI"),(0,o.kt)("p",null,"As we have the table in the database, it is time to connect to QuestDB and query\nsome data to return through the API. To connect, we will use the Postgres\ninterface of QuestDB and Postgres using connection pooling to connect to it."),(0,o.kt)("p",null,"To be able to reuse the pool later on, create a new file in the ",(0,o.kt)("inlineCode",{parentName:"p"},"app")," package\nwhich is responsible for defining how to connect and name it ",(0,o.kt)("inlineCode",{parentName:"p"},"db.py"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# db.py\n\nfrom psycopg_pool import ConnectionPool\n\npool = ConnectionPool(\n    "postgresql://admin:quest@127.0.0.1:8812/qdb", # Use a the default credentials\n    min_size=1, # Set pool size minimum to 1\n    max_size=5, # Set pool size greater than 1 to not block async requests\n)\n')),(0,o.kt)("p",null,"To set up a schema that represents the table in the database, create a ",(0,o.kt)("inlineCode",{parentName:"p"},"models.py"),"\nin the ",(0,o.kt)("inlineCode",{parentName:"p"},"app")," package, containing the schema definition:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# models.py\n\nfrom datetime import datetime\nfrom pydantic import BaseModel, Field\n\n\nclass Signal(BaseModel):\n    """\n    Signal model stands for the results of monitoring requests\n    """\n    url: str = Field(..., description="The monitored URL")\n    http_status: int = Field(..., description="HTTP status code returned by upstream")\n    available: bool = Field(..., description="Represents the service availability")\n    received: datetime = Field(..., description="Timestamp when the signal received")\n')),(0,o.kt)("p",null,"Let's stop here for a moment and talk through what we did in the last steps:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"set up the API which will serve the requests coming from the frontend"),(0,o.kt)("li",{parentName:"ul"},"created a table in QuestDB for our status records and provided connection\ncredentials for Postgres wire"),(0,o.kt)("li",{parentName:"ul"},"implemented the schema which is used to serialize the results returned by the\ndatabase")),(0,o.kt)("p",null,"The next step is to initiate a connection and return the results from the\ndatabase. First, import the ",(0,o.kt)("inlineCode",{parentName:"p"},"pool")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Signal")," schema and then extend the\nfunction which serves the ",(0,o.kt)("inlineCode",{parentName:"p"},"/signals")," endpoint:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"# main.py\n\n# Other imports ...\nfrom app.db import pool\nfrom app.models import Signal\n\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass SignalResponse(BaseModel):\n    url: str\n    records: List[Signal]\n    \n# app and endpoint definitions are below...\n")),(0,o.kt)("p",null,"After adding the ",(0,o.kt)("inlineCode",{parentName:"p"},"defaultdict")," import, the implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"/signals"),"\nendpoint should look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# main.py\n\n# Other imports ...\nfrom collections import defaultdict\n\n# ...\n\n@app.get(path="/signals", response_model=List[SignalResponse], tags=["Monitoring"])\nasync def get_signals(limit: int = 60):\n\n    # A simple query to return every record belongs to the website we will monitor\n    query = f"""\n    SELECT url, http_status, available, received FROM signals\n    WHERE url = \'https://questdb.io\' ORDER BY received DESC LIMIT {limit};\n    """\n\n    signals = defaultdict(list)\n\n    with pool.connection() as conn: # connect to the database\n            # parse the results results returned by QuestDB\n            signal = Signal(\n                url=result[0],\n                http_status=result[1],\n                available=result[2],\n                received=result[3],\n            )\n\n    # Return the response which is validated against the `response_model` schema\n    return [\n        SignalResponse(url=url, records=list(reversed(records)))\n        for url, records in signals.items()\n    ]\n')),(0,o.kt)("p",null,"Let's recap on our code above, starting from the top:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"we added ",(0,o.kt)("inlineCode",{parentName:"li"},"defaultdict")," import (we'll explain that later)"),(0,o.kt)("li",{parentName:"ul"},"extended the function decorator to use ",(0,o.kt)("inlineCode",{parentName:"li"},"response_model=List[SignalResponse]"),",\nthe response model we defined already"),(0,o.kt)("li",{parentName:"ul"},"changed the function signature to include a ",(0,o.kt)("inlineCode",{parentName:"li"},"limit")," parameter and set its\ndefault value to ",(0,o.kt)("inlineCode",{parentName:"li"},"60")," since we will monitor HTTP status every minute"),(0,o.kt)("li",{parentName:"ul"},"select the records from the database and prepare a dictionary for the parsed\n",(0,o.kt)("inlineCode",{parentName:"li"},"Signal"),"s.")),(0,o.kt)("p",null,"You may ask why to group the returned records per URL. Although we will monitor\nonly one URL for the sake of simplicity, I challenge you to change the\nimplementation later and explore QuestDB to handle the monitoring of multiple\nURLs."),(0,o.kt)("p",null,"In the following lines, we are connecting to the database, executing the query,\nand populates the dictionary, which we will use in the last four lines to\nconstruct the ",(0,o.kt)("inlineCode",{parentName:"p"},"SignalResponse"),". Our version of ",(0,o.kt)("inlineCode",{parentName:"p"},"main.py")," at this point looks\nlike the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# main.py\n\nfrom collections import defaultdict\nfrom typing import List\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\nfrom app.db import pool\nfrom app.models import Signal\n\n\n# Add a response model to indicate the structure of the signals API response.\nclass SignalResponse(BaseModel):\n    url: str\n    records: List[Signal]\n\n\napp = FastAPI(\n    title="Status Page",\n    description="This service gives back the status of the configured URL.",\n    version="0.1.0",\n)\n\n@app.get(path="/signals", response_model=List[SignalResponse], tags=["Monitoring"])\nasync def get_signals(limit: int = 60):\n\n    # A simple query to return every record belongs to the website we will monitor\n    query = f"""\n    SELECT * FROM signals\n    WHERE url = \'https://questdb.io\' ORDER BY received DESC LIMIT {limit};\n    """\n\n    signals = defaultdict(list)\n\n    with pool.connection() as conn: # connect to the database\n        # parse the results results returned by QuestDB\n        signal = Signal(\n            url=result[0],\n            http_status=result[1],\n            available=result[2],\n            received=result[3],\n        )\n\n    # Return the response which is validated against the `response_model` schema\n    return [\n        SignalResponse(url=url, records=list(reversed(records)))\n        for url, records in signals.items()\n    ]\n\n')),(0,o.kt)("h2",{id:"schedule-monitoring-tasks"},"Schedule monitoring tasks"),(0,o.kt)("p",null,"For scheduling the monitoring task, we will use Celery Beat, the built-in\nperiodic task scheduler implementation of Celery."),(0,o.kt)("h3",{id:"scheduling-with-celery"},"Scheduling with Celery"),(0,o.kt)("p",null,"Before we schedule any task, we need to configure Celery. In the ",(0,o.kt)("inlineCode",{parentName:"p"},"app")," package,\ncreate a new ",(0,o.kt)("inlineCode",{parentName:"p"},"celery.py")," which will contain the Celery and beat schedule\nconfiguration. Import ",(0,o.kt)("inlineCode",{parentName:"p"},"Celery")," for creating tasks, and ",(0,o.kt)("inlineCode",{parentName:"p"},"crontab")," for\nconstructing Unix-like crontabs for our tasks. The task is the dotted path\nrepresentation of the function which is executed by Celery (",(0,o.kt)("inlineCode",{parentName:"p"},"app.tasks.monitor"),")\nand sent to queues handled by Redis."),(0,o.kt)("p",null,"The only thing left is to configure the beat schedule, which is a simple\ndictionary. We give a name for the schedule, define the dotted path pointing to\nthe task (function), and specify the schedule itself:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# celery.py\n\nfrom celery import Celery\nfrom celery.schedules import crontab\n\nMONITORING_TASK = "app.tasks.monitor"\n\ncelery_app = Celery("tasks", broker="redis://localhost:6379/0")\n\n# Set a queue for task routes\ncelery_app.conf.task_routes = {\n  MONITORING_TASK: "main-queue"\n}\n\n# Schedule the monitoring task\ncelery_app.conf.beat_schedule = {\n    "monitor": { # Name of the schedule\n        "task": MONITORING_TASK, # Register the monitoring task\n        "schedule": crontab(\n            minute=f"*/1" # Run the task every minute\n        ),\n    }\n}\n')),(0,o.kt)("h3",{id:"create-a-monitoring-task"},"Create a monitoring task"),(0,o.kt)("p",null,'And the last part: creating the monitoring task. In the previous section, we\ntalked about the "monitoring task" multiple times, but we didn\'t see the\nconcrete implementation.'),(0,o.kt)("p",null,"In this final backend related section, you will implement the task which will\ncheck the availability of the desired website or service and saves the results\nas records in QuestDB. The monitoring task is a simple ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTP HEAD")," request and\nsaving the response to the database. We see the implementation in pieces of the\n",(0,o.kt)("inlineCode",{parentName:"p"},"app/tasks.py")," referenced in celery as the dotted path before."),(0,o.kt)("p",null,"First, we start with imports:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"# tasks.py\n\nfrom datetime import datetime\n\nimport requests\n\nfrom app.celery import celery_app\nfrom app.db import pool\nfrom app.models import Signal\n\n# ...\n")),(0,o.kt)("p",null,"We import ",(0,o.kt)("inlineCode",{parentName:"p"},"celery_app")," which represents the Celery application, an ",(0,o.kt)("inlineCode",{parentName:"p"},"engine")," to\nsave the results in the database, and finally ",(0,o.kt)("inlineCode",{parentName:"p"},"Signal")," to construct the record\nwe will save. As the necessary imports are in place, we can define the ",(0,o.kt)("inlineCode",{parentName:"p"},"monitor"),"\ntask."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# tasks.py\n\n# ...\n\n@celery_app.task # register the function as a Celery task\ndef monitor():\n    try:\n        response = requests.head("https://questdb.io")\n    except Exception as exc: # handle any exception which may occur due to connection errors\n        query = f"""\n            INSERT INTO signals(received,url,http_status,available)\n            VALUES(systimestamp(), \'https://questdb.io\', -1, False);\n            """\n\n        # Open a connection and execute the query\n        with pool.connection() as conn:\n            conn.execute(query)\n\n        # Re-raise the exception to not hide issues\n        raise exc\n\n# ...\n')),(0,o.kt)("p",null,"As you can see, we send a request to the desired website and store the response\nfor later use. In case the website is down and unreachable, an exception will be\nraised by requests or any underlying packages. As we need to log that the\nrequest does not finish, we catch the exception, save a record in the database,\nand re-raise the exception to not hide anything. Next, we construct a signal to\nsave."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# ...\n\n@celery_app.task\ndef monitor():\n    # ...\n\n    signal = Signal(\n        url="https://questdb.io",\n        http_status=response.status_code,\n        received=datetime.now(),\n        available=response.status_code >= 200 and response.status_code < 400,\n    )\n\n    # ...\n')),(0,o.kt)("p",null,"We don't do anything special here, though the following step is more\ninteresting: inserting the result in the database. Finally, we prepare and\nexecute the query based on the ",(0,o.kt)("inlineCode",{parentName:"p"},"signal"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# ...\n\n@celery_app.task\ndef monitor():\n    # ...\n\n    query = f"""\n    INSERT INTO signals(received,url,http_status,available)\n    VALUES(systimestamp(), \'{signal.url}\', {signal.http_status}, {signal.available});\n    """\n\n    with pool.connection() as conn:\n        conn.execute(query)\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"tasks.py")," should look like this now:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# tasks.py\nfrom datetime import datetime\nimport requests\nfrom app.celery import celery_app\nfrom app.db import pool\nfrom app.models import Signal\n@celery_app.task # register the function as a Celery task\ndef monitor():\n    try:\n        response = requests.head("https://questdb.io")\n    except Exception as exc: # handle any exception which may occur due to connection errors\n        query = f"""\n            INSERT INTO signals(received,url,http_status,available)\n            VALUES(systimestamp(), \'https://questdb.io\', -1, False);\n            """\n        # Open a connection and execute the query\n        with pool.connection() as conn:\n            conn.execute(query)\n        # Re-raise the exception to not hide issues\n        raise exc\n    signal = Signal(\n        url="https://questdb.io",\n        http_status=response.status_code,\n        received=datetime.now(),\n        available=response.status_code >= 200 and response.status_code < 400,\n    )\n    query = f"""\n    INSERT INTO signals(received,url,http_status,available)\n    VALUES(systimestamp(), \'{signal.url}\', {signal.http_status}, {signal.available});\n    """\n    with pool.connection() as conn:\n        conn.execute(query)\n')),(0,o.kt)("p",null,"Congratulations! You just arrived at the last part of the backend service\nimplementation. We did many things and built a service that can periodically\ncheck the website's status, save it in the database, and expose the results\nthrough an API."),(0,o.kt)("p",null,"The very last thing we need to address is to allow connections initiated by the\nfrontend later on. As it will run on localhost:3000 and we don't use domain\nnames, the port is different hence all requests will be rejected with errors\nrelated to\n",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS"},"Cross-Origin Resource Sharing"),"."),(0,o.kt)("p",null,"For the sake of simplicity, we are going to allow all origins. We highly\nrecommended to avoid this in production for security reason but for the tutorial,\nit will be sufficient for us:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# main.py\n\n# Other imports ...\nfrom fastapi.middleware.cors import CORSMiddleware\n\n# app = FastAPI ...\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# rest of the code ...\n')),(0,o.kt)("h2",{id:"implement-the-frontend"},"Implement the frontend"),(0,o.kt)("h3",{id:"setting-up-frontend"},"Setting up frontend"),(0,o.kt)("p",null,"To build the frontend, we will use Nuxt.js. We will use ",(0,o.kt)("inlineCode",{parentName:"p"},"yarn")," to set up the\nstarter project by running ",(0,o.kt)("inlineCode",{parentName:"p"},"yarn")," and selecting the answers detailed below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"$ yarn create nuxt-app frontend\n\n[...]\n\n? Project name: frontend\n? Programming language: JavaScript\n? Package manager: Yarn\n? UI framework: Tailwind CSS\n? Nuxt.js modules: Axios\n? Linting tools: (Press <space> to select, <a> to toggle all, <i> to invert selection)\n? Testing framework: None\n? Rendering mode: Single Page App\n? Deployment target: Static (Static/JAMStack hosting)\n? Development tools: (Press <space> to select, <a> to toggle all, <i> to invert selection)\n? What is your GitHub username? gabor-boros\n? Version control system: Git\n")),(0,o.kt)("p",null,"The project root now looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"status-page\n\u251c\u2500\u2500 app/\n\u251c\u2500\u2500 frontend/\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 poetry.lock\n\u2514\u2500\u2500 pyproject.toml\n")),(0,o.kt)("h3",{id:"cleaning-up-generated-project"},"Cleaning up generated project"),(0,o.kt)("p",null,"Since we don't need any styling delivered by the project generation, we need to\nget rid of them. Open ",(0,o.kt)("inlineCode",{parentName:"p"},"frontend/layouts/default.vue")," and replace its content\nwith"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},"\x3c!-- frontend/layouts/default.vue --\x3e\n\n<template>\n  <div>\n    <Nuxt />\n  </div>\n</template>\n")),(0,o.kt)("p",null,"Now, we will change ",(0,o.kt)("inlineCode",{parentName:"p"},"frontend/pages/index.vue")," and call the backend service.\nLet's begin with ",(0,o.kt)("inlineCode",{parentName:"p"},"<scripts>"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},"\x3c!-- frontend/pages/index.vue --\x3e\n\n\x3c!-- template ... --\x3e\n\n<script>\n  const LIMIT = 60\n\n  async function fetchSignals($axios, limit) {\n    const signals = await $axios.$get(\n      `http://localhost:8000/signals?limit=${limit}`,\n    )\n    return signals\n  }\n\n  export default {\n    data() {\n      return {\n        signals: [],\n      }\n    },\n\n    // Handle initial call\n    async asyncData({ $axios }) {\n      const signals = await fetchSignals($axios, LIMIT)\n      return { signals }\n    },\n\n    methods: {\n      // Calculate uptime based on the signals belongs to a URL\n      uptime: (records) => {\n        let availableRecords = records.filter((record) => record.available)\n          .length\n        return ((availableRecords / records.length) * 100).toFixed(2)\n      },\n    },\n\n    // Set up periodic calls when the component is mounted\n    mounted() {\n      let that = this\n      const axios = this.$axios\n\n      setInterval(() => {\n        Promise.resolve(fetchSignals(axios, LIMIT)).then((signals) => {\n          that.signals = signals\n        })\n      }, 1000 * LIMIT)\n    },\n  }\n<\/script>\n")),(0,o.kt)("p",null,"At the first sight, it might look a lot, but if we check the most important\nparts in pieces everything will be crystal clear."),(0,o.kt)("p",null,"We define ",(0,o.kt)("inlineCode",{parentName:"p"},"fetchSignals")," to reduce code duplication later on. Then, we set up\ninitial ",(0,o.kt)("inlineCode",{parentName:"p"},"signals")," data, where we will store the periodically fetched responses\nreturned by the backed. After that, as part of ",(0,o.kt)("inlineCode",{parentName:"p"},"asyncData"),", we initiate an async\ncall towards the backend to get the initial signals to show."),(0,o.kt)("p",null,"The last part is to define a periodic call to the backend when the component is\n",(0,o.kt)("inlineCode",{parentName:"p"},"mounted"),". Right, we have the logic which will call backend and keep the data up\nto date. Now we have to display the results."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'\x3c!-- frontend/pages/index.vue --\x3e\n\n<template>\n  <div class="p-8 h-screen text-center">\n    <h1 class="text-2xl font-light">QuestDB website status</h1>\n    <h2 class="text-lg font-thin">service uptime in the past 60 minutes</h2>\n\n    <div class="h-8 mt-12 flex justify-center" v-if="signals.length > 0">\n      \x3c!-- Iterate over the signals belongs to records --\x3e\n      <div class="w-1/4" v-for="(signal, s) in signals" :key="s">\n        <div class="flex mb-1 text-sm">\n          <p class="flex-1 text-left font-normal">{{ signal.url }}</p>\n          <p class="flex-1 text-right font-thin">\n            {{ uptime(signal.records) }}% uptime\n          </p>\n        </div>\n        <div class="grid grid-flow-col auto-cols-max gap-x-1">\n          \x3c!-- Draw a green or yellow bar depending on service availability --\x3e\n          <div\n            v-for="(signal, r) in signal.records"\n            :key="r"\n            :class="`w-1 bg-${signal.available ? \'green\' : \'yellow\'}-700`"\n          >\n            &nbsp;\n          </div>\n        </div>\n      </div>\n    </div>\n\n    \x3c!-- In case we have no records yet, show an informative message --\x3e\n    <div v-else>\n      <p>No signals found</p>\n    </div>\n  </div>\n</template>\n\n\x3c!-- scripts ... --\x3e\n')),(0,o.kt)("h2",{id:"run-the-project"},"Run the project"),(0,o.kt)("p",null,"We reached the end of the tutorial. We have both the backend and the frontend.\nIt is time to try everything out. Run the following commands in different shells\nfrom the project root:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"# Shell 1 - Start the application\n$ docker-compose up -d\n$ poetry run uvicorn app.main:app --host 127.0.0.1 --port 8000 --reload\n\n# Shell 2 - Start the worker process\n$ poetry run celery --app=app.tasks worker --beat -l info -Q main-queue -c 1\n\n# Shell 3 - Start the frontend\n$ cd frontend\n$ yarn dev\n")),(0,o.kt)("p",null,"Navigate to ",(0,o.kt)("a",{parentName:"p",href:"http://localhost:3000"},"http://localhost:3000")," to see the backend\nreporting the status of the monitored URL. The first task to check the system\nstatus is executed when the scheduler and worker starts and the status of the\nwebsite over time can be seen after a few minutes on the page or when you check\nback at a later stage:"),(0,o.kt)(r.Z,{alt:"An uptime indicator having fetched the status of the QuestDB website over 3 minutes",height:284,src:"/img/blog/2021-01-13/end-result-2.png",title:"Finished statuspage indicator",width:650,mdxType:"Screenshot"}),(0,o.kt)("h2",{id:"summary"},"Summary"),(0,o.kt)("p",null,"We've successfully built a pretty status page that can be publicly-visible to\nusers or used for internal teams to monitor an application's uptime. We've\nlearned how to queue and schedule tasks and store the responses in a time-series\ndatabase and make use of low-latency queries. Engineers can modify this demo to\nmonitor a website's HTTP response code or multiple endpoints or services for a\nrobust overview of an entire system's status."),(0,o.kt)("p",null,"Thank you for your attention!"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"The containerized source code is available at\n",(0,o.kt)("a",{parentName:"em",href:"https://github.com/gabor-boros/questdb-statuspage"},"https://github.com/gabor-boros/questdb-statuspage"),".")))}h.isMDXComponent=!0},86010:function(e,t,n){function a(e){var t,n,i="";if("string"==typeof e||"number"==typeof e)i+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(i&&(i+=" "),i+=n);else for(t in e)e[t]&&(i&&(i+=" "),i+=t);return i}function i(){for(var e,t,n=0,i="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(i&&(i+=" "),i+=t);return i}n.d(t,{Z:function(){return i}})}}]);
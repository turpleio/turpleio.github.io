"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[3774],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return p}});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=c(n),p=o,m=d["".concat(l,".").concat(p)]||d[p]||u[p]||r;return n?a.createElement(m,i(i({ref:t},h),{},{components:n})):a.createElement(m,i({ref:t},h))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},44314:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},metadata:function(){return h},toc:function(){return u},default:function(){return p}});var a=n(83117),o=n(80102),r=(n(67294),n(3905)),i=n(46092),s=n(72525),l=["components"],c={title:"Building a garbage-free network stack for Kafka streams",author:"Vlad Ilyushchenko",author_title:"QuestDB Team",author_url:"https://github.com/bluestreak01",author_image_url:"https://avatars.githubusercontent.com/bluestreak01",description:"Our database's network stack handles multiple TCP connections on a single thread without garbage collection for reliably ingesting time series data.",keywords:["jdbc","postgres","tcp","kafka","garbage","java","timeseries","database"],image:"/img/blog/2020-12-10/banner.jpg",tags:["kafka","postgres","architecture","engineering"]},h={permalink:"/blog/2020/12/10/garbage-free-stack-for-kafka-streams",source:"@site/blog/2020-12-10-garbage-free-stack-for-kafka-streams.md",title:"Building a garbage-free network stack for Kafka streams",description:"Our database's network stack handles multiple TCP connections on a single thread without garbage collection for reliably ingesting time series data.",date:"2020-12-10T00:00:00.000Z",formattedDate:"December 10, 2020",tags:[{label:"kafka",permalink:"/blog/tags/kafka"},{label:"postgres",permalink:"/blog/tags/postgres"},{label:"architecture",permalink:"/blog/tags/architecture"},{label:"engineering",permalink:"/blog/tags/engineering"}],readingTime:11.635,truncated:!0,prevItem:{title:"SQL Extensions for Time-Series Data in QuestDB",permalink:"/blog/2021/01/11/sql-extensions-for-timeseries-data"},nextItem:{title:"What is time-series data, and why are we building a time-series database (TSDB)?",permalink:"/blog/2020/11/26/why-timeseries-data"}},u=[{value:"How can garbage collection cause performance issues?",id:"how-can-garbage-collection-cause-performance-issues",children:[]},{value:"TCP flow control",id:"tcp-flow-control",children:[]},{value:"Java NIO and garbage collection",id:"java-nio-and-garbage-collection",children:[]},{value:"QuestDB&#39;s thread model",id:"questdbs-thread-model",children:[]},{value:"Adding an IO notification loop",id:"adding-an-io-notification-loop",children:[{value:"Configuring network IO",id:"configuring-network-io",children:[]},{value:"Connection Context",id:"connection-context",children:[]},{value:"Protocol Parsers",id:"protocol-parsers",children:[]},{value:"Worker Threads",id:"worker-threads",children:[]}]},{value:"Take a look",id:"take-a-look",children:[]}],d={toc:u};function p(e){var t=e.components,n=(0,o.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(i.Z,{alt:"Steam network of a Pennsylvania coal power plant",height:433,src:"/img/blog/2020-12-10/banner.jpg",width:650,mdxType:"Banner"}," ","Photo by",(0,r.kt)("a",{href:"https://unsplash.com/photos/a_PDPUPuNZ8"},"Martin Adams")," on"," ",(0,r.kt)("a",{href:"https://unsplash.com"},"Unsplash")," "),(0,r.kt)("p",null,"Garbage collection is a type of automatic memory management that's used in many\nmodern programming languages. The point of the garbage collector is to free up\nmemory used by objects which are no longer being used by a program. Although\nit's convenient for developers not to think about manually deallocating memory,\nit can be a poisoned chalice that comes with several hard-to-predict downsides."),(0,r.kt)("h2",{id:"how-can-garbage-collection-cause-performance-issues"},"How can garbage collection cause performance issues?"),(0,r.kt)("p",null,"Some garbage collectors completely halt the program's execution to make sure no\nnew objects are created while it cleans up. To avoid these unpredictable\n",(0,r.kt)("strong",{parentName:"p"},"stop-the-world")," pauses in a program, incremental and concurrent garbage\ncollectors were developed. Although they provide great benefit in many cases,\nthere's additional design choices that wind up back into development phases\nwhere you have to indirectly deal with memory allocation."),(0,r.kt)("p",null,"Another issue is that garbage collectors themselves consume resources to decide\nwhat to free up, which can add considerable overhead. Environments dealing with\nreal-time data are latency-sensitive and require high performance and\nefficiency. In these applications, unpredictable halting behavior combined with\nexcess computation time or memory usage is not acceptable."),(0,r.kt)("p",null,"As we're building an open source high-performance time series database, we have\nthese environments in mind and use design patterns and tooling that focuses on\nwriting code that's efficient and reliable. When we need additional\nfunctionality that would introduce performance knocks through standard\nlibraries, we can leverage our own implementations using native methods. This is\nwhat prompted us to add a network stack that executes garbage-free."),(0,r.kt)("p",null,"This component bypasses Java's native non-blocking IO with our own notification\nsystem. This component's job is to delegate tasks to worker threads and use\nqueues for events and TCP socket connections. The result is a new generic\nnetwork stack used to handle all incoming network connections. Following our new\nsupport for Kafka, QuestDB's network stack now ingests time series data from\nKafka topics reliably, without garbage collection."),(0,r.kt)("h2",{id:"tcp-flow-control"},"TCP flow control"),(0,r.kt)("p",null,"When we have multiple nodes on a network, there are usually disparities in their\nperformance in computing power and network bandwidth. Some nodes can read\nincoming packets at different rates than others, or conversely, some nodes may\nbe able to send data at a different rate."),(0,r.kt)("p",null,"Let's say we have a network with two nodes; a sender and a receiver. If the\nsender can produce a lot more data than the receiver can read, the receiver is\nlikely to be overwhelmed. We're in luck, though, as TCP uses a built-in flow\ncontrol protocol that acts as a pressure valve to ensure the receiver is not\naffected by such cases."),(0,r.kt)("p",null,"Control flow manifests itself in different ways, depending on whether the\nnetwork socket is blocking or non-blocking. If the receiver can process data\nfaster than a sender, a non-blocking socket is identical to a blocking one, and\nthe receiver thread would be parked while no data is read. There's not much\nconcern about this situation if it happens infrequently, but the park and unpark\nis a waste of resources and CPU cycles if the receiver is under heavy load."),(0,r.kt)("p",null,"Let's assume the receiver gets 0-length data on a non-blocking socket,\nindicating no data has arrived from the sender; there are two options:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Loop over socket reads continuously, waiting for data to arrive."),(0,r.kt)("li",{parentName:"ol"},"Stop looping and consult our parser on two possible actions to take: park for\nmore reads or switch to write.")),(0,r.kt)("p",null,"The first option is quite wasteful, so we went with the second approach. To park\nsocket read operations without blocking the thread, we need a dedicated system\nfor enqueuing and notifying us when the socket has more data to read. On the OS\nkernel level, IO notification utilities exist as ",(0,r.kt)("inlineCode",{parentName:"p"},"epoll")," on Linux, ",(0,r.kt)("inlineCode",{parentName:"p"},"kqueue")," on\nFreeBSD and OSX, and ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," on Windows. In QuestDB, we've implemented a\ndispatcher that operates exactly as these IO notification systems for enqueuing\nsockets, and we named it IODispatcher."),(0,r.kt)("h2",{id:"java-nio-and-garbage-collection"},"Java NIO and garbage collection"),(0,r.kt)("p",null,"As you would expect from cross-platform languages, the IO Notification system\nmust be abstracted away to make application code portable. In Java, this\nabstraction is called ",(0,r.kt)("inlineCode",{parentName:"p"},"Selector"),". If we were to oversimplify a typical\ninteraction with the IO Notification system, it would essentially be a loop.\nMore often than not, this is an infinite loop, or rather, it executes\ncontinuously during the server's uptime."),(0,r.kt)("p",null,"Since we are on a quest to have everything garbage-free, Selector presents a\nproblem right away - the output of the selector is a set of keys, coming from a\nconcurrent hash map via an iterator. All of this allocates objects on every\niteration of the loop. If you are not careful, this allocation continues even\nwhen the server is idling. The behavior is intrinsic to the Java Non-blocking\nI/O (NIO) implementation and cannot be changed."),(0,r.kt)("p",null,"To send or receive data from the network, Java mandates ByteBuffer instances.\nWhen looked at in a vacuum, ByteBuffer may seem like a reasonable abstraction.\nBut if we look closer, it's easy to see it's a bit confused. It is a concrete\nclass instead of an interface, meaning that the whole NIO is stuck with the\nprovided implementation. The API is inconsistent as the OS requires memory\npointers for send and receive methods, but ByteBuffer does not provide an\nexplicit semantic for each case. So how does ByteBuffer translate to a memory\npointer?"),(0,r.kt)("p",null,"When your data is on the heap, there is a memory copy for each socket IO. When\nByteBuffer is direct, there is no copy, but there is an issue releasing memory\nand general Java paranoia about language safety."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Native Java socket write implementation"',title:'"Native',Java:!0,socket:!0,write:!0,'implementation"':!0},"\n/**\n * /java.base/share/classes/sun/nio/ch/SocketChannelImpl.java\n */\npublic int write(ByteBuffer buf) throws IOException {\n    Objects.requireNonNull(buf);\n\n    writeLock.lock();\n    try {\n        boolean blocking = isBlocking();\n        int n = 0;\n        try {\n            beginWrite(blocking);\n            if (blocking) {\n                do {\n                    n = IOUtil.write(fd, buf, -1, nd);\n                } while (n == IOStatus.INTERRUPTED && isOpen());\n            } else {\n                n = IOUtil.write(fd, buf, -1, nd);\n            }\n        } finally {\n            endWrite(blocking, n > 0);\n            if (n <= 0 && isOutputClosed)\n                throw new AsynchronousCloseException();\n        }\n        return IOStatus.normalize(n);\n    } finally {\n        writeLock.unlock();\n    }\n}\n")),(0,r.kt)("p",null,"Considering the allocating nature of the Selector, that Java NIO libraries are a\nlayer above the OS, and how computationally expensive the overhead is with\nByteBuffer, we decided to go out on a limb and interact directly with the OS via\nthe Java Native Interface (JNI). This worked for QuestDB insofar as the API is\nnon-allocating outside of the normal bootstrap phase and lets us work with the\nmemory pointers directly."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="QuestDB\'s JNI call for sending data to a socket"',title:"\"QuestDB's",JNI:!0,call:!0,for:!0,sending:!0,data:!0,to:!0,a:!0,'socket"':!0},"/**\n * /core/src/main/c/share/net.c\n */\nJNIEXPORT jint JNICALL Java_io_questdb_network_Net_send\n        (JNIEnv *e, jclass cl, jlong fd, jlong ptr, jint len) {\n    const ssize_t n = send((int) fd, (const void *) ptr, (size_t) len, 0);\n    if (n > -1) {\n        return n;\n    }\n\n    if (errno == EWOULDBLOCK) {\n        return com_questdb_network_Net_ERETRY;\n    }\n\n    return com_questdb_network_Net_EOTHERDISCONNECT;\n}\n")),(0,r.kt)("h2",{id:"questdbs-thread-model"},"QuestDB's thread model"),(0,r.kt)("p",null,"Starting threads is expensive, and they're more often than not just wrappers for\nthe connection state. QuestDB operates a fixed number of threads to isolate the\ndatabase instance to specific cores and reduce the overhead of starting and\nstopping threads at runtime. The actual threads are encapsulated by a WorkerPool\nclass."),(0,r.kt)("p",null,'The worker pool\'s idea is to have a simple list of "jobs" that all workers will\nrun all the time. Jobs themselves encapsulate "piece of work" and do not have\ntight loops in them. Hence a job can simply return if IO is not available or the\nqueue is full or empty.'),(0,r.kt)("p",null,'We have a notion of a "synchronized job." It is different from the definition of\n"synchronized" in Java in that the QuestDB\'s thread never blocks. However,\nsynchronized jobs guarantee that only one thread can execute a job instance at\nany moment in time.'),(0,r.kt)("h2",{id:"adding-an-io-notification-loop"},"Adding an IO notification loop"),(0,r.kt)("p",null,"IODispatcher is QuestDB's implementation of the IO Notification loop. We have\nimplemented ",(0,r.kt)("inlineCode",{parentName:"p"},"epoll"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"kqueue"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"select"),", so this works cross-platform. The\nappropriate implementation is automatically chosen at runtime based on the OS.\nThe IODispatched API is message-driven via QuestDB's implementation of\nnon-blocking and non-allocating queues. These queues are outside of the scope of\nthis article, but you can read about them in our community\n",(0,r.kt)("a",{parentName:"p",href:"/blog/2020/11/16/http-server-contribution"},"contribution from Alex Pelagenko"),"."),(0,r.kt)(s.Z,{alt:"A diagram of QuestDB's IODispatcher",height:284,src:"/img/blog/2020-12-10/iodispatcher-diagram.png",title:"IODispatcher and queues for events, interest, and disconnections",width:650,mdxType:"Screenshot"}),(0,r.kt)("p",null,"IODispatcher is a synchronized job in context of QuestDB's thread model. It\nconsumes queues on the left and publishes to the queue on the right.\nIODispatcher's main responsibility is to deliver socket handles (individual\nconnection identifiers), that are ready for the IO to the worker threads.\nConsidering that socket handles are read or written to by one thread at a time\nthe underlying IO notification system works in ONESHOT mode. This means socket\nhandle is removed from the IO notification system while there is socket activity\nand re-introduced back when activity tapers off. Interacting with the IO\nnotification system is expensive. Worker thread will only recurse back to the\nIODispatcher for enqueueing if there has been zero data from the socket for the\nset period of time, which we call hysteresis."),(0,r.kt)("p",null,"You can find source code of the implementations of the IODispatcher for\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/questdb/questdb/blob/master/core/src/main/java/io/questdb/network/IODispatcherLinux.java"},"epoll"),"\n,\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/questdb/questdb/blob/master/core/src/main/java/io/questdb/network/IODispatcherOsx.java"},"kqueue"),"\nand\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/questdb/questdb/blob/master/core/src/main/java/io/questdb/network/IODispatcherWindows.java"},"select"),"\non GitHub. Let's take a look at the components in the diagram above with an\noutline of their purpose:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"IO Event Queue:")," Single publisher, multiple consumer queue. It is the\nrecipient of the IO events from as in epoll, kqueue, select. The events are\nsocket handles and the type of operation the OS has associated them with, e.g.,\nread or write. The IODispatcher plays the publisher role, and any number of\nworker threads are the consumers."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Interest Queue:")," Multiple publisher, single consumer queue. Worker threads\npublish socket handles and operations to this queue when IO is unavailable,\ne.g., socket read or write returns zero. The IODispatcher will enqueue the\nsocket handle for more reads or writes as defined by the operation."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Disconnect Queue:")," Multiple publisher, single consumer queue. Worker threads\npublish socket handles to this queue destined to be disconnected from the server\nand have their resources reused by other connections. The worker thread does not\ndisconnect the socket by itself because multiple threads may attempt to access a\ndata structure that is not thread-safe."),(0,r.kt)("h3",{id:"configuring-network-io"},"Configuring network IO"),(0,r.kt)("p",null,"We disregarded ByteBuffer for not being an interface, so it would only be fair\nfor us to have interfaces in key places. One of these places is configuration,\nwhich provides IODispatcher with basics such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The IP address of the network interface"),(0,r.kt)("li",{parentName:"ul"},"Port to bind to"),(0,r.kt)("li",{parentName:"ul"},"Bias"),(0,r.kt)("li",{parentName:"ul"},"Buffer sizes"),(0,r.kt)("li",{parentName:"ul"},"Network facade"),(0,r.kt)("li",{parentName:"ul"},"Clock facade"),(0,r.kt)("li",{parentName:"ul"},"Connection context factory")),(0,r.kt)("p",null,"It's necessary to explain bias here, which might not be so obvious. When the TCP\nconnection is first accepted, it is enqueued for IO right away. The bias\nprovides an expectation of the initial operation of a connection, such as read\nor write. For example, most TCP protocols would have 'read bias', which means\nthat connecting clients will have to send data before the server replies\nanything. You can probably think of a protocol that requires the server to\nrespond first before the client sends anything - in this case, the bias will be\n'write'."),(0,r.kt)("p",null,"Network & clock facades have static implementations for production runtime, but\nfor tests, they can be both spot-implemented to simulate OS failures and produce\nstable timestamps."),(0,r.kt)("h3",{id:"connection-context"},"Connection Context"),(0,r.kt)("p",null,"Connection context is a Java object that encapsulates the connection state,\nwhich is protocol-specific. It is stored together with the socket handle and\nmanaged by IODispatcher via the context factory. We talked a little about the\nQuestDB thread model and that workers are very likely to execute the same job\ninstance simultaneously unless the job is synchronized. In this scenario, the\nonly place a job can reliably store a state is the connection context."),(0,r.kt)("h3",{id:"protocol-parsers"},"Protocol Parsers"),(0,r.kt)("p",null,"Protocol parsers are used by worker threads to make sense of the incoming data.\nQuestDB has a convention that all protocol parsers must be streaming, e.g., they\nnever hold on to the entirety of the data sent over the network. These parsers\nare typically state machines, with state held in connection context. This type\nof parser allows fully real-time ingestion of large data segments, such as text\nfile import."),(0,r.kt)("h3",{id:"worker-threads"},"Worker Threads"),(0,r.kt)("p",null,"Worker threads are required to consume the IO event queue. We already mentioned\nthat the IODispatcher neither reads nor writes connected sockets itself. This is\nthe responsibility of the worker threads."),(0,r.kt)("p",null,'Worker threads almost always use protocol parsers to interpret socket data. They\nmust continue to work with the socket until the socket cannot read or write\nanymore. In which case, the worker threads either express "interest" in further\nsocket interaction or disconnects the socket. In this situation, IODispatcher is\nnot on the execution path during most of the socket interaction.'),(0,r.kt)("p",null,"Threads will often use hysteresis, which means that they busy-spin socket read\nor write operations until either the socket responds or the number of iterations\nhas elapsed. This is sometimes useful when a remote socket is able to respond\nwith minimum delay."),(0,r.kt)("h2",{id:"take-a-look"},"Take a look"),(0,r.kt)("p",null,"In this article, we've covered our approach to implementing non-blocking IO\nusing what we think is a nice solution that's garbage-free. Kafka Connect\nsupport is now available since version 5.0.5. Our new network stack ingests time\nseries data from Kafka topics reliably from multiple TCP connections on a single\nthread without garbage collection and the QuestDB source is open to\n",(0,r.kt)("a",{parentName:"p",href:"https://"},"browse on GitHub"),". If you like this content and our approach to\nnon-blocking and garbage-free IO, or if you know of a better way to approach\nwhat we built, we'd love to know your thoughts! Feel free to share your feedback\n",(0,r.kt)("a",{parentName:"p",href:"https://"},"in our Slack Community"),"."))}p.isMDXComponent=!0},86010:function(e,t,n){function a(e){var t,n,o="";if("string"==typeof e||"number"==typeof e)o+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(o&&(o+=" "),o+=n);else for(t in e)e[t]&&(o&&(o+=" "),o+=t);return o}function o(){for(var e,t,n=0,o="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(o&&(o+=" "),o+=t);return o}n.d(t,{Z:function(){return o}})}}]);
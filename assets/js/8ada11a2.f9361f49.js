"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[8807],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return m}});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(a),m=o,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||i;return a?n.createElement(h,r(r({ref:t},p),{},{components:a})):n.createElement(h,r({ref:t},p))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=a.length,r=new Array(i);r[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var u=2;u<i;u++)r[u]=a[u];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},61359:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},metadata:function(){return u},toc:function(){return p},default:function(){return c}});var n=a(83117),o=a(80102),i=(a(67294),a(3905)),r=a(72525),l=["components"],s={title:"High frequency finance with Julia and QuestDB",author:"Dean Markwick",author_title:"Guest post",author_url:"https://github.com/dm13450",author_image_url:"https://avatars.githubusercontent.com/dm13450",description:"Learn how to use QuestDB as a time series database for high-frequency trading, calculate the limit order book, price impact, trade sign distribution, and other concepts via the Julia programming language.",keywords:["julia","finance","timeseries","database","algotrading"],image:"/img/blog/2021-09-17/banner.png",tags:["tutorial","finance","crypto","algotrading"]},u={permalink:"/blog/2021/09/17/high-frequency-finance-julia-lang",source:"@site/blog/2021-09-17-high-frequency-finance-julia-lang.md",title:"High frequency finance with Julia and QuestDB",description:"Learn how to use QuestDB as a time series database for high-frequency trading, calculate the limit order book, price impact, trade sign distribution, and other concepts via the Julia programming language.",date:"2021-09-17T00:00:00.000Z",formattedDate:"September 17, 2021",tags:[{label:"tutorial",permalink:"/blog/tags/tutorial"},{label:"finance",permalink:"/blog/tags/finance"},{label:"crypto",permalink:"/blog/tags/crypto"},{label:"algotrading",permalink:"/blog/tags/algotrading"}],readingTime:10.65,truncated:!0,prevItem:{title:"Join Hacktoberfest 2021 and contribute to QuestDB!",permalink:"/blog/2021/10/01/hacktoberfest-questdb"},nextItem:{title:"QuestDB 6.0.5 September release, geospatial support",permalink:"/blog/2021/09/13/release-6-0-5-geospatial-data"}},p=[{value:"Connecting to QuestDB from Julia lang",id:"connecting-to-questdb-from-julia-lang",children:[]},{value:"Order sign correlation",id:"order-sign-correlation",children:[]},{value:"Size distribution",id:"size-distribution",children:[]},{value:"Market impact",id:"market-impact",children:[]},{value:"Trades with top of book",id:"trades-with-top-of-book",children:[]},{value:"Summary",id:"summary",children:[]}],d={toc:p};function c(e){var t=e.components,a=(0,o.Z)(e,l);return(0,i.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This post was written by Dean Markwick, who has put together an excellent\nexample using QuestDB as a time series database for high-frequency trading. This\npost shows how to use QuestDB to calculate the limit order book, price impact,\ntrade sign distribution, and other concepts via the Julia programming language."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Originally published at\n",(0,i.kt)("a",{parentName:"em",href:"https://dm13450.github.io/2021/08/12/questdb-part2.html"},"Dean's personal blog"),".")),(0,i.kt)("h2",{id:"connecting-to-questdb-from-julia-lang"},"Connecting to QuestDB from Julia lang"),(0,i.kt)("p",null,"In my first post, I showed how to set up a producer/consumer model to build a\n",(0,i.kt)("inlineCode",{parentName:"p"},"BTCUSD")," trades database using the CoinbasePro WebSocket feed. Now I'll show you\nhow you can connect to the same database to pull out the data, use some specific\ntimeseries database queries and hopefully show where this type of database is\nhelpful by improving some of my old calculations."),(0,i.kt)("p",null,"I ingested just over 24 hours worth of data over the 24th and 25th of July,\n2021, but I completely missed the massive rally, which is just my luck. That\nwould have been interesting to look at, but never mind! I'm going to repeat some\nof the calculations from\n",(0,i.kt)("a",{parentName:"p",href:"http://dm13450.github.io/2021/06/25/HighFreqCrypto.html"},"older blog posts on high-frequency finance"),"\nusing more data this time."),(0,i.kt)("p",null,"Julia can connect to the database using the\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/invenia/LibPQ.jl"},"LibPQ.jl")," package and execute queries\nusing all their functions. This is very handy as we don't have to worry about\ndatabase drivers or connection methods; we can just connect and go."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},"using LibPQ\nusing DataFrames, DataFramesMeta\nusing Plots\nusing Statistics, StatsBase\nusing CategoricalArrays\n")),(0,i.kt)("p",null,"The following is the default connection credentials for the database used to\nconnect to QuestDB:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia",metastring:'title="Connection credentials in Julia"',title:'"Connection',credentials:!0,in:!0,'Julia"':!0},'conn = LibPQ.Connection("""\n             dbname=qdb\n             host=127.0.0.1\n             password=quest\n             port=8812\n             user=admin""")\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"    PostgreSQL connection (CONNECTION_OK) with parameters:\n      user = admin\n      password = ********************\n      dbname = qdb\n      host = 127.0.0.1\n      port = 8812\n      client_encoding = UTF8\n      options = -c DateStyle=ISO,YMD -c IntervalStyle=iso_8601 -c TimeZone=UTC\n      application_name = LibPQ.jl\n      sslmode = prefer\n      sslcompression = 0\n      gssencmode = disable\n      krbsrvname = postgres\n      target_session_attrs = any\n")),(0,i.kt)("p",null,"It's very easy; Julia thinks that it is a regular Postgres database. We can\nquickly move on to working with the data. I started with getting all trades out\nof the database:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},'@time trades = execute(conn, "SELECT * FROM coinbase_trades") |> DataFrame\ndropmissing!(trades);\nnrow(trades)\n')),(0,i.kt)("p",null,"It takes about 5 seconds to pull 210,000 rows into the notebook:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"      4.828067 seconds (9.25 M allocations: 335.378 MiB, 1.64% gc time)\n")),(0,i.kt)("p",null,"Now we can plot the results and export as a ",(0,i.kt)("inlineCode",{parentName:"p"},".png"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia",metastring:'title="Plot query results in Julia"',title:'"Plot',query:!0,results:!0,in:!0,'Julia"':!0},"plot(trades.timestamp, trades.price, label=:none, fmt=:png)\n")),(0,i.kt)(r.Z,{alt:"Plotting SQL query results of entire table from QuestDB via Julia",height:598,src:"/img/blog/2021-09-17/sql-connection-via-julia.png",width:650,mdxType:"Screenshot"}),(0,i.kt)("p",null,"You can see that ",(0,i.kt)("inlineCode",{parentName:"p"},"Plots.jl")," struggles a little with formatting the x-axis\ncorrectly with a time series plot above. The timestamps are pretty long labels\nwhich could be better if the text was angled 45 degrees. It's a shame that I\nmissed the sudden rally on Sunday 25th; that was pretty unlucky, but let's move\non to updating previous graphs with the new dataset."),(0,i.kt)("h2",{id:"order-sign-correlation"},"Order sign correlation"),(0,i.kt)("p",null,"The correlation between buys and sells follows a power law. Last time, I only\nhad 1000 trades to work on after pulling them using the REST API. Now I've got\n200x more, which should improve the uncertainty around the previous values."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},'ac = autocor(trades.side)\nacplot = plot(1:length(ac), ac, seriestype=:scatter, label = :none, xlab="Lag", ylab = "Correlation")\naclogplot = plot(log.(1:length(ac)), log.(ac), seriestype=:scatter, label=:none, xlab= "log(Lag)", ylab="log(Correlation)")\nplot(acplot, aclogplot, fmt=:png)\n')),(0,i.kt)(r.Z,{alt:"Plotting order sign correlation in QuestDB via Julia",height:598,src:"/img/blog/2021-09-17/order-sign-correlation.png",width:650,mdxType:"Screenshot"}),(0,i.kt)("p",null,"In the log-log plot, we can see a nice straight line which we fit a linear model\non."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},"using GLM\n\nsideModel = lm(@formula(log(AC) ~ log(Lag)), DataFrame(AC=ac, Lag=1:length(ac)))\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}}}}, Matrix{Float64}}\n\n:(log(AC)) ~ 1 + :(log(Lag))\n\nCoefficients:\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                 Coef.  Std. Error       t  Pr(>|t|)  Lower 95%  Upper 95%\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n(Intercept)  -0.439012   0.049596    -8.85    <1e-11  -0.538534  -0.339491\nlog(Lag)     -0.70571    0.0156489  -45.10    <1e-42  -0.737112  -0.674308\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n")),(0,i.kt)("p",null,"This time we've got a \ud835\udefe value of 0.7 with more certainty."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},'plot(log.(1:length(ac)), log.(ac), seriestype=:scatter, label=:none)\nplot!(log.(1:length(ac)), coef(sideModel)[1] .+ coef(sideModel)[2] .* log.(1:length(ac)),\n      label="Model", xlab= "log(Lag)", ylab="log(Correlation)", fmt=:png)\n')),(0,i.kt)(r.Z,{alt:"Plotting order sign correlation in QuestDB via Julia",height:598,src:"/img/blog/2021-09-17/order-sign-correlation-2.png",width:650,mdxType:"Screenshot"}),(0,i.kt)("p",null,"This lines up nicely with the data and is better than the previous attempt with\njust 1000 trades. \ud835\udefe is less than one, which means it is a 'long memory' process,\nso trades in the past affect trades in the future for a long time. This is\nusually explained as the effect of people breaking up large trades into slices\nand executing them bit by bit."),(0,i.kt)("h2",{id:"size-distribution"},"Size distribution"),(0,i.kt)("p",null,"Again, the size of each trade follows a power-law distribution too. We use a\nslightly different method to estimate the exponent, and last time, with just\n1000 trades, we struggled to get a stable value. Now, with so much more data, we\ncan have another crack."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},'uSizes = minimum(trades.size):0.05:maximum(trades.size)\n\nempF = ecdf(trades.size)\n\ntradesSizePlot = plot((uSizes), (1 .- empF(uSizes)), seriestype=:scatter, label="P(V > x)", xlabel="Trade Size", ylabel="Probability")\ntradesSizeLogPlot = plot(log.(uSizes), log.(1 .- empF(uSizes)), seriestype=:scatter, label="P(V > x)", xlabel = "log(Trade Size)", ylabel="log(Probability)")\n\nplot(tradesSizePlot, tradesSizeLogPlot, fmt=:png)\n')),(0,i.kt)(r.Z,{alt:"Plotting size distribution in QuestDB via Julia",height:598,src:"/img/blog/2021-09-17/size-distribution.png",width:650,mdxType:"Screenshot"}),(0,i.kt)("p",null,"Let's use the same Hill estimator as last time:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},'function hill_estimator(sizes_sort, k)\n    N = length(sizes_sort)\n    res = log.(sizes_sort[(N-k+1):N] / sizes_sort[N-k])\n    k*(1/sum(res))\nend\nsizes = trades.size\nsizes_sort = sort(sizes)\nbds = 2:100:(length(sizes)-1000-1)\n\nalphak = [hill_estimator(sizes_sort, k) for k in bds]\nplot(bds, alphak, xlabel="k", ylabel="Alpha", label=:none, fmt=:png)\n')),(0,i.kt)(r.Z,{alt:"Plotting size distribution in QuestDB via Julia",height:598,src:"/img/blog/2021-09-17/size-distribution-2.png",width:650,mdxType:"Screenshot"}),(0,i.kt)("p",null,"It's still hard to judge whether it is converging to a value or not. It always\nappears to be decreasing no matter the sample size. Maybe I still need more\ndata, or perhaps I need a better understanding of the Hill estimator!"),(0,i.kt)("h2",{id:"market-impact"},"Market impact"),(0,i.kt)("p",null,"I've not been using QuestDB to its full potential, and repeating all my previous\ngraphs hasn't fully exploited the available features. One of those features is\nthe ability to group by the timestamp across a bucket size (1 second, 5 minutes,\netc.) and aggregate the data. We will use that to try and come up with a better\nmodel of a market impact than I had in my previous post."),(0,i.kt)("p",null,"We aggregate the trades into 1-minute buckets and calculate the total volume\ntraded, the total signed volume (sell trades count as negative), the last price\nand also the number of trades in each bucket."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},'@time marketimpact = execute(conn,\n    "SELECT timestamp, sum(size) as TotalVolume,\n            sum(size*side) as SignedVolume,\n            last(price) as Close,\n            count(*) as NTrades\n     FROM coinbase_trades\n    SAMPLE by 1m") |> DataFrame\ndropmissing!(marketimpact)\nmarketimpact[1:3, :]\n')),(0,i.kt)("p",null,"This took less than a second and is a really easy line of code to write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  0.223987 seconds (167.29 k allocations: 8.708 MiB, 56.20% compilation time)\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"timestamp"),(0,i.kt)("th",{parentName:"tr",align:null},"TotalVolume"),(0,i.kt)("th",{parentName:"tr",align:null},"SignedVolume"),(0,i.kt)("th",{parentName:"tr",align:null},"Close"),(0,i.kt)("th",{parentName:"tr",align:null},"NTrades"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"DateTim\u2026"),(0,i.kt)("td",{parentName:"tr",align:null},"Float64"),(0,i.kt)("td",{parentName:"tr",align:null},"Float64"),(0,i.kt)("td",{parentName:"tr",align:null},"Float64"),(0,i.kt)("td",{parentName:"tr",align:null},"Int64")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2021-07-24T08:50:34.365"),(0,i.kt)("td",{parentName:"tr",align:null},"1.75836"),(0,i.kt)("td",{parentName:"tr",align:null},"-0.331599"),(0,i.kt)("td",{parentName:"tr",align:null},"33649.0"),(0,i.kt)("td",{parentName:"tr",align:null},"52")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2021-07-24T08:51:34.365"),(0,i.kt)("td",{parentName:"tr",align:null},"4.18169"),(0,i.kt)("td",{parentName:"tr",align:null},"-3.01704"),(0,i.kt)("td",{parentName:"tr",align:null},"33625.2"),(0,i.kt)("td",{parentName:"tr",align:null},"67")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2021-07-24T08:52:34.365"),(0,i.kt)("td",{parentName:"tr",align:null},"0.572115"),(0,i.kt)("td",{parentName:"tr",align:null},"-0.325788"),(0,i.kt)("td",{parentName:"tr",align:null},"33620.1"),(0,i.kt)("td",{parentName:"tr",align:null},"46")))),(0,i.kt)("p",null,"Now for the market impact calculation, we calculated the return bucket to bucket\nand normalise the signed volume by the total volume traded to give a value of\nbetween -1 and 1. This is taken from ",(0,i.kt)("a",{parentName:"p",href:"https://arxiv.org/pdf/1206.0682.pdf"},"https://arxiv.org/pdf/1206.0682.pdf")," and\nequation 26."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},"marketimpact[!, :returns] .= 1e4.*[NaN; diff(log.(marketimpact.Close))]\nmarketimpact[!, :NormVolume] .= marketimpact[!, :SignedVolume] ./ marketimpact[!, :TotalVolume]\n\nmiModel = lm(@formula(returns ~ NormVolume + 0), marketimpact[2:end, :])\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}}}}, Matrix{Float64}}\n\nreturns ~ 0 + NormVolume\n\nCoefficients:\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              Coef.  Std. Error      t  Pr(>|t|)  Lower 95%  Upper 95%\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nNormVolume  4.55478    0.290869  15.66    <1e-51     3.9843    5.12526\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n")),(0,i.kt)("p",null,"Here we can see that there is a positive coefficient, \u03b8 in the paper, as\nexpected, and we can interpret this at how much the price moves after buying or\nselling. Specifically, in these minute buckets, those that contained only buy\ntrades moved the market up by 4.5bps and the same for sells in the opposite\ndirection."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},'plot(marketimpact.NormVolume, marketimpact.returns, seriestype=:scatter, label=:none,\n     xlab="Normalised Volume", ylab="Market Impact (log(bps))")\nplot!(-1:0.1:1, coef(miModel)[1] .* collect(-1:0.1:1), label="Model", linewidth=3, legend=:topleft, fmt=:png)\n')),(0,i.kt)(r.Z,{alt:"Plotting market impact in QuestDB via Julia",height:598,src:"/img/blog/2021-09-17/market-impact.png",width:650,mdxType:"Screenshot"}),(0,i.kt)("p",null,"You can see how the model lines of with the data, and there is a very slight\ntrend that is picked. So overall, a better, if still a very simple model of\nmarket impact."),(0,i.kt)("h2",{id:"trades-with-top-of-book"},"Trades with top of book"),(0,i.kt)("p",null,"I've saved down the best bid and offer using the same process as Part 1 of this\nseries. Over the same period, the best bid and offer data has 17 million rows;\nquite a bit more. I use this best bid-offer data to do an ASOF join. ASOF joins\ntake two tables and joins them such that the timestamps align or the previous\nobservation is used. In our case, we can take the trades, join it with the best\nbid and best offer table to get where the mid-price was at the time of the\ntrade."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},'@time trades2 = execute(conn, "SELECT * FROM coinbase_trades ASOF JOIN coinbase_bbo") |> DataFrame\ndropmissing!(trades2);\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  9.745210 seconds (18.49 M allocations: 671.544 MiB, 1.84% gc time)\n")),(0,i.kt)("p",null,"This took 11 seconds but was all done in the database, so no issue with blowing\nout the memory after pulling it into your Julia session. Doing a regular join in\nJulia would only match timestamps exactly, whereas we want the last observed\nbid/offer price at least making the ",(0,i.kt)("inlineCode",{parentName:"p"},"ASOF")," function very useful."),(0,i.kt)("p",null,"We now calculate a mid-price, how far the traded price was from the mid-price,\nand add an indicator for what quantile the trade size landed. We then group by\nthis quantile indicator and calculate the average trade size and the average\ndistance from the mid-price."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},'trades2[!, :Mid] .= (trades2.bid .+ trades2.ask)./2;\ntrades2[!, :Cost] .= 1e4 .* trades2.side .* ((trades2.price .- trades2.Mid) ./ (trades2.Mid))\ntrades2[!, :SizeBucket] .= cut(trades2[!, :size], [quantile(trades2[!, :size], 0:0.1:1); Inf])\ngdata = groupby(@where(trades2, :Cost .> 0), :SizeBucket)\ncostData = @combine(gdata, MeanSize = mean(:size), MeanCost = mean(:Cost))\n\nlogCostPlot = plot(log.(costData.MeanSize),\n                   log.(costData.MeanCost), seriestype=:scatter,\n                   label=:none,\n                   xlab="log(Size)",\n                   ylab="log(Cost)", fmt=:png)\n')),(0,i.kt)(r.Z,{alt:"Plotting top of book results in QuestDB via Julia",height:598,src:"/img/blog/2021-09-17/top-of-book.png",width:650,mdxType:"Screenshot"}),(0,i.kt)("p",null,"Unsurprisingly, we can see that larger trades are further away from the\nmid-price when they execute. This is because they are eating through the posted\nliquidity."),(0,i.kt)("p",null,"This is very similar to my ",(0,i.kt)("a",{parentName:"p",href:"https://cryptoliquiditymetrics.com/"},"https://cryptoliquiditymetrics.com/")," sweep the book\ngraph, which is ",(0,i.kt)("em",{parentName:"p"},"estimating")," the cost of eating liquidity. The graph above shows\nthe ",(0,i.kt)("em",{parentName:"p"},"actual cost")," of eating liquidity for real trades that have happened on\nCoinbase."),(0,i.kt)("p",null,"We can fit a model to this plot, and it is commonly referred to as the square\nroot law of market impact. We ignore the smaller trade sizes, as they aren't\nfollowing the nice linear log-log plot."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},"costModel = lm(@formula(log(MeanCost) ~ log(MeanSize)),\n                     @where(costData, :MeanSize .> exp(-7)))\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}}}}, Matrix{Float64}}\n\n:(log(MeanCost)) ~ 1 + :(log(MeanSize))\n\nCoefficients:\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                   Coef.  Std. Error      t  Pr(>|t|)  Lower 95%  Upper 95%\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n(Intercept)    -0.534863   0.0683721  -7.82    0.0001  -0.696537  -0.373189\nlog(MeanSize)   0.259424   0.0154468  16.79    <1e-06   0.222898   0.29595\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n")),(0,i.kt)("p",null,"The \ud835\udefe value of 0.25 is pretty low compared to other assets, which we would\nexpect to be around 0.5. But we haven't included the usual volatility\ncalculation, which is in front of the volume component."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-julia"},'plot(log.(costData.MeanSize),\n     log.(costData.MeanCost), seriestype=:scatter,\n     label=:none,\n     xlab="log(Size)",\n     ylab="log(Cost)")\nplot!(-8:0.1:3, coef(costModel)[1] .+ coef(costModel)[2] .* (-8:0.1:3),\n      label="Model", legend=:topleft, fmt=:png)\n')),(0,i.kt)(r.Z,{alt:"Plotting top of book results in QuestDB via Julia",height:598,src:"/img/blog/2021-09-17/top-of-book-2.png",width:650,mdxType:"Screenshot"}),(0,i.kt)("p",null,"Apart from the small trades, the model lines up well with the increasing trade\nsize."),(0,i.kt)("p",null,"Using this model, you can start to estimate how much a strategy might cost to\nimplement. The outcome of your strategy is unknown, but your trading costs are\nknown. If it costs you 1bp to enter and exit a trade (round trip), but you only\nthink the price will change by 0.5bps, then you're at a loss even if you were\n100% right on the price direction!"),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"QuestDB makes working with this data incredibly easy. Both aggregating the data\nusing ",(0,i.kt)("inlineCode",{parentName:"p"},"SAMPLE BY")," and joining two datasets using ",(0,i.kt)("inlineCode",{parentName:"p"},"AS OF"),". Connecting to the\ndatabase is a doddle using ",(0,i.kt)("inlineCode",{parentName:"p"},"LibPQ.jl"),", so you can get up and running without any\nissues. These things rarely happen straight out of the box."),(0,i.kt)("p",null,"Using this data, I've ramped up the sample sizes, and all my plots and models\nlook better. Again, all free data and with hopefully, very minimal technical\ndifficulty. As someone that usually finds themselves drowning in CSVs, QuestDB\nhas shown how much more efficient things can be when you use a database."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"If you have have feedback or questions about this article, feel free ask in our\n",(0,i.kt)("a",{parentName:"p",href:"https://slack.questdb.io/"},"Slack Community")," or browse the\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/questdb/questdb"},"project on GitHub")," where we welcome\ncontributions of all kinds."))}c.isMDXComponent=!0},86010:function(e,t,a){function n(e){var t,a,o="";if("string"==typeof e||"number"==typeof e)o+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(a=n(e[t]))&&(o&&(o+=" "),o+=a);else for(t in e)e[t]&&(o&&(o+=" "),o+=t);return o}function o(){for(var e,t,a=0,o="";a<arguments.length;)(e=arguments[a++])&&(t=n(e))&&(o&&(o+=" "),o+=t);return o}a.d(t,{Z:function(){return o}})}}]);
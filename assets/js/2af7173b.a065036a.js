"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[8308],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return d}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=u(n),d=r,h=c["".concat(s,".").concat(d)]||c[d]||p[d]||l;return n?a.createElement(h,o(o({ref:t},m),{},{components:n})):a.createElement(h,o({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=c;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var u=2;u<l;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},50268:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},metadata:function(){return u},toc:function(){return m},default:function(){return c}});var a=n(83117),r=n(80102),l=(n(67294),n(3905)),o=n(46092),i=["components"],s={title:"Aggregating billions of rows per second with SIMD",author:"Tancrede Collard",author_title:"QuestDB Team",author_url:"https://github.com/TheTanc",author_image_url:"https://avatars.githubusercontent.com/TheTanc",description:"How SIMD instructions make aggregations faster in QuestDB, including benchmark results and a comparison with Postgres.",keywords:["performance","simd","parallelization","cpu","questdb"],tags:["benchmark","performance","simd","release"],image:"/img/blog/2020-04-02/banner.png"},u={permalink:"/blog/2020/04/02/using-simd-to-aggregate-billions-of-rows-per-second",source:"@site/blog/2020-04-02-using-simd-to-aggregate-billions-of-rows-per-second.md",title:"Aggregating billions of rows per second with SIMD",description:"How SIMD instructions make aggregations faster in QuestDB, including benchmark results and a comparison with Postgres.",date:"2020-04-02T00:00:00.000Z",formattedDate:"April 2, 2020",tags:[{label:"benchmark",permalink:"/blog/tags/benchmark"},{label:"performance",permalink:"/blog/tags/performance"},{label:"simd",permalink:"/blog/tags/simd"},{label:"release",permalink:"/blog/tags/release"}],readingTime:6.385,truncated:!0,prevItem:{title:"Things we learned about sums",permalink:"/blog/2020/05/12/interesting-things-we-learned-about-sums"},nextItem:{title:"Speeding up InfluxDB line protocol",permalink:"/blog/2019/12/19/lineprot"}},m=[{value:"What are SIMD operations?",id:"what-are-simd-operations",children:[]},{value:"How much faster is SIMD?",id:"how-much-faster-is-simd",children:[{value:"How can we improve upon SIMD performance?",id:"how-can-we-improve-upon-simd-performance",children:[]}]},{value:"Benchmarking QuestDB versus Postgres performance",id:"benchmarking-questdb-versus-postgres-performance",children:[]},{value:"How we will improve time series data performance",id:"how-we-will-improve-time-series-data-performance",children:[]},{value:"About the release: QuestDB 4.2",id:"about-the-release-questdb-42",children:[{value:"Important",id:"important",children:[]},{value:"What is new?",id:"what-is-new",children:[]},{value:"What we fixed",id:"what-we-fixed",children:[]}]}],p={toc:m};function c(e){var t=e.components,s=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,a.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,l.kt)(o.Z,{alt:"QuestDB release 4.2 banner",height:143,src:"/img/blog/2020-04-02/banner.png",width:650,mdxType:"Banner"}),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/SIMD"},"SIMD instructions")," are specific CPU\ninstruction sets for arithmetic calculations that use synthetic parallelization.\nThis approach allows us to perform the same calculations and operations on\nnumerous data points simultaneously. This post describes how SIMD works with\ntypical operation performance and describes additional optimizations we managed\nto achieve."),(0,l.kt)("h2",{id:"what-are-simd-operations"},"What are SIMD operations?"),(0,l.kt)("p",null,"Instead of spreading the work across CPU cores, SIMD performs vector operations\non multiple items using a ",(0,l.kt)("strong",{parentName:"p"},"single")," CPU instruction. In practice, if you were\nto add 8 numbers together, SIMD does that in 1 operation instead of 8. We get\ncompounded performance improvements by combining SIMD with actual\nparallelisation and spanning the work across CPUs."),(0,l.kt)("p",null,"QuestDB 4.2 introduces SIMD instructions, which made our aggregations faster by\n100x! QuestDB is available open source (Apache 2.0) . If you like what we do,\nplease consider ",(0,l.kt)("a",{parentName:"p",href:"https://"},"starring our repo")," following us on GitHub and\nstarring our project."),(0,l.kt)("p",null,"As of now, SIMD operations are available for non-keyed aggregation queries, such\nas ",(0,l.kt)("inlineCode",{parentName:"p"},"select sum(value) from table"),". In future releases, we will extend these to\nkeyed aggregations, for example ",(0,l.kt)("inlineCode",{parentName:"p"},"select key, sum(value) from table")," (note the\nintentional omission of ",(0,l.kt)("inlineCode",{parentName:"p"},"GROUP BY"),"). This will also result in ultrafast\naggregation for time bucketed queries using ",(0,l.kt)("inlineCode",{parentName:"p"},"SAMPLE BY"),"."),(0,l.kt)("h2",{id:"how-much-faster-is-simd"},"How much faster is SIMD?"),(0,l.kt)("p",null,"We ran performance tests using 2 different CPUs: the\n",(0,l.kt)("a",{parentName:"p",href:"https://ark.intel.com/content/www/us/en/ark/products/134899/intel-core-i7-8850h-processor-9m-cache-up-to-4-30-ghz.html"},"Intel 8850H"),"\nand the\n",(0,l.kt)("a",{parentName:"p",href:"https://www.amd.com/en/products/cpu/amd-ryzen-9-3900x"},"AMD Ryzen 3900X"),". Both\nwere running on 4 threads."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Test"),(0,l.kt)("th",{parentName:"tr",align:null},"Query"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sum of 1Bn doubles ",(0,l.kt)("br",null)," no nulls"),(0,l.kt)("td",{parentName:"tr",align:null},"create table zz as (select rnd_double() d from long_sequence(1000000000)); ",(0,l.kt)("br",null)," select sum(d) from zz;")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sum of 1Bn ints"),(0,l.kt)("td",{parentName:"tr",align:null},"create table zz as (select rnd_int() i from long_sequence(1000000000)); ",(0,l.kt)("br",null)," select sum(i) from zz;")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sum of 1Bn longs"),(0,l.kt)("td",{parentName:"tr",align:null},"create table zz as (select rnd_long() l from long_sequence(1000000000));",(0,l.kt)("br",null),"select sum(l) from zz;")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max of 1Bn doubles"),(0,l.kt)("td",{parentName:"tr",align:null},"create table zz as (select rnd_double() d from long_sequence(1000000000));",(0,l.kt)("br",null),"select max(d) from zz;")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max of 1Bn longs"),(0,l.kt)("td",{parentName:"tr",align:null},"create table zz as (select rnd_long() l from long_sequence(1000000000));",(0,l.kt)("br",null),"select max(l) from zz;")))),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Intel 8850H benchmark",src:n(32729).Z})),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"AMD 3900X benchmark",src:n(95700).Z})),(0,l.kt)("p",null,"The dataset producing the results shown above does not contain NULL values.\nInterestingly, when introducing nulls, QuestDB sum() query time is unchanged.\nThis can be tested by creating the table as follows."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Test"),(0,l.kt)("th",{parentName:"tr",align:null},"Query"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sum of 1Bn doubles ",(0,l.kt)("br",null),"(nulls)"),(0,l.kt)("td",{parentName:"tr",align:null},"create table zz as (select rnd_double(5) d from long_sequence(1000000000));",(0,l.kt)("br",null),"select sum(d) from zz;")))),(0,l.kt)("h3",{id:"how-can-we-improve-upon-simd-performance"},"How can we improve upon SIMD performance?"),(0,l.kt)("p",null,"Our approach is currently slightly more complicated as we convert each 32-bit\ninteger to a 64-bit long to avoid overflow. By removing this overhead and more,\nthere is scope left to make our implementation faster in the future."),(0,l.kt)("h2",{id:"benchmarking-questdb-versus-postgres-performance"},"Benchmarking QuestDB versus Postgres performance"),(0,l.kt)("p",null,"The execution times outlined above become more interesting once put into\ncontext. This is how QuestDB compares to Postgres when doing a sum of 1 billion\nnumbers from a given table ",(0,l.kt)("inlineCode",{parentName:"p"},"select sum(d) from 1G_double_nonNull"),"."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Benchmark results for QuestDB vs PostgreSQL",src:n(16724).Z})),(0,l.kt)("p",null,"We found that our performance figures are constrained by the available memory\nchannels. Both the 8850H and the 3900X have 2 memory channels, and throwing more\nthan 4 cores at the query above does not improve the performance. On the other\nhand, if the CPU has more memory channels, then performance scales almost\nlinearly."),(0,l.kt)("p",null,"To get an idea of the impact of memory channels, we spun off a m5.metal instance\non AWS. This instance has two 24-core Intel 8275CL with 6 memory channels each.\nHere are the results compared to the 2-channel 3900X:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"cpu cores"),(0,l.kt)("th",{parentName:"tr",align:null},"1"),(0,l.kt)("th",{parentName:"tr",align:null},"2"),(0,l.kt)("th",{parentName:"tr",align:null},"3"),(0,l.kt)("th",{parentName:"tr",align:null},"4"),(0,l.kt)("th",{parentName:"tr",align:null},"5"),(0,l.kt)("th",{parentName:"tr",align:null},"6"),(0,l.kt)("th",{parentName:"tr",align:null},"7"),(0,l.kt)("th",{parentName:"tr",align:null},"8"),(0,l.kt)("th",{parentName:"tr",align:null},"9"),(0,l.kt)("th",{parentName:"tr",align:null},"10"),(0,l.kt)("th",{parentName:"tr",align:null},"11"),(0,l.kt)("th",{parentName:"tr",align:null},"12"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"8275CL"),(0,l.kt)("td",{parentName:"tr",align:null},"910"),(0,l.kt)("td",{parentName:"tr",align:null},"605"),(0,l.kt)("td",{parentName:"tr",align:null},"380"),(0,l.kt)("td",{parentName:"tr",align:null},"240"),(0,l.kt)("td",{parentName:"tr",align:null},"193"),(0,l.kt)("td",{parentName:"tr",align:null},"176"),(0,l.kt)("td",{parentName:"tr",align:null},"156"),(0,l.kt)("td",{parentName:"tr",align:null},"148"),(0,l.kt)("td",{parentName:"tr",align:null},"140"),(0,l.kt)("td",{parentName:"tr",align:null},"136"),(0,l.kt)("td",{parentName:"tr",align:null},"133"),(0,l.kt)("td",{parentName:"tr",align:null},"141")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"3900X"),(0,l.kt)("td",{parentName:"tr",align:null},"621"),(0,l.kt)("td",{parentName:"tr",align:null},"502"),(0,l.kt)("td",{parentName:"tr",align:null},"381"),(0,l.kt)("td",{parentName:"tr",align:null},"260"),(0,l.kt)("td",{parentName:"tr",align:null},"260"),(0,l.kt)("td",{parentName:"tr",align:null},"260"),(0,l.kt)("td",{parentName:"tr",align:null},"260"),(0,l.kt)("td",{parentName:"tr",align:null},"260"),(0,l.kt)("td",{parentName:"tr",align:null},"260"),(0,l.kt)("td",{parentName:"tr",align:null},"260"),(0,l.kt)("td",{parentName:"tr",align:null},"260"),(0,l.kt)("td",{parentName:"tr",align:null},"260")))),(0,l.kt)("p",null,"We plot those results below on the left. On the right-hand side, we normalise\nthe results for each CPU and plot the performance improvement of going from 1 to\nmore cores."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Charts showing the execution time for the Intel 8275CL and AMD 3900X when using a various number of cores",src:n(5999).Z})),(0,l.kt)("p",null,"Interestingly, the 2-channel 3900X, is much faster on 1 core than the 8275CL.\nBut it does not scale well and hits a performance ceiling at 4 cores. This is\nbecause it only has 2 memory channels that are already saturated. The 6-channel\n8275CL allows QuestDB to scale almost linearly as we add more CPU cores and hits\na performance ceiling at around 12 cores."),(0,l.kt)("p",null,"Unfortunately AWS CPUs are hyperthreaded. We could unpack even more performance\nif CPU were fully isolated to run the computations."),(0,l.kt)("p",null,"We did not get our hands on CPUs with more memory channels for this test, but if\nyou have easy access to 8 or 12-channel servers and would like to benchmark\nQuestDB, we'd love to hear the results. You can\n",(0,l.kt)("a",{parentName:"p",href:"/docs/"},"download QuestDB")," and leave a\n",(0,l.kt)("a",{parentName:"p",href:"https:///issues/146"},"comment on github"),"."),(0,l.kt)("h2",{id:"how-we-will-improve-time-series-data-performance"},"How we will improve time series data performance"),(0,l.kt)("p",null,"In further releases, we will roll out this functionality to other parts of our\nSQL implementation. QuestDB implements SIMD in a generic fashion, which will\nallow us to continue adding SIMD to about everything our SQL engine does, such\nas keyed aggregations, indexing etc. We will also keep improving QuestDB's\nperformance. Through some further work on assembly, we estimate that we can gain\nanother 15% speed on these operations. In the meantime, if you want to know\nexactly how we have achieved this, all of our code is\n",(0,l.kt)("a",{parentName:"p",href:"https://"},"open source"),"!"),(0,l.kt)("h2",{id:"about-the-release-questdb-42"},"About the release: QuestDB 4.2"),(0,l.kt)("p",null,"We have implemented SIMD-based vector execution of queries, such as\n",(0,l.kt)("inlineCode",{parentName:"p"},"select sum(value) from table"),". This is ~100x faster than non-vector based\nexecution. This is just the beginning as we will introduce vectors to more\noperations going forward. Try our first implementation in this release - stay\ntuned for more features in the upcoming releases!"),(0,l.kt)("h3",{id:"important"},"Important"),(0,l.kt)("p",null,"Metadata file format has been changed to include a new flag for columns of type\nsymbol. It is necessary to convert existing tables to new format. Running the\nfollowing SQL: ",(0,l.kt)("inlineCode",{parentName:"p"},"repair table myTable")," will update the table metadata."),(0,l.kt)("h3",{id:"what-is-new"},"What is new?"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Java: vectorized sum(), avg(), min(), max() for DOUBLE, LONG, INT"),(0,l.kt)("li",{parentName:"ul"},"Java: select distinct symbol optimisation"),(0,l.kt)("li",{parentName:"ul"},"FreeBSD support"),(0,l.kt)("li",{parentName:"ul"},"Automatically restore data consistency and recover from partial data loss.")),(0,l.kt)("h3",{id:"what-we-fixed"},"What we fixed"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"SQL: NPE when parsing SQL text with malformed table name expression , for\nexample ')', or ', blah'"),(0,l.kt)("li",{parentName:"ul"},"SQL: parsing 'fill' clause in sub-query context was causing unexpected syntax\nerror (#115)"),(0,l.kt)("li",{parentName:"ul"},"SQL: possible internal error when ordering result of group-by or sample-by"),(0,l.kt)("li",{parentName:"ul"},"Data Import: Ignore byte order marks (BOM) in table names created from an\nimported CSV (#114)"),(0,l.kt)("li",{parentName:"ul"},"SQL: 'timestamp' propagation thru group-by code had issues. sum() was tripping\nover null values. Added last() aggregate function. (#113)"),(0,l.kt)("li",{parentName:"ul"},"LOG: make service log names consistent on windows (#106)"),(0,l.kt)("li",{parentName:"ul"},"SQL: deal with the following syntax 'select ","*"," from select ( select a from\n....)'"),(0,l.kt)("li",{parentName:"ul"},"SQL: allow the following syntax 'case cast(x as int) when 1 then ...'"),(0,l.kt)("li",{parentName:"ul"},'fix(griffin): syntax check for "case"-\')\' overlap, e.g. "a + (case when .. )\nend"')))}c.isMDXComponent=!0},86010:function(e,t,n){function a(e){var t,n,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(r&&(r+=" "),r+=n);else for(t in e)e[t]&&(r&&(r+=" "),r+=t);return r}function r(){for(var e,t,n=0,r="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(r&&(r+=" "),r+=t);return r}n.d(t,{Z:function(){return r}})},95700:function(e,t,n){t.Z=n.p+"assets/images/benchmark3900x-ebfc53da30cc1b3fb28267640318e0f4.png"},32729:function(e,t,n){t.Z=n.p+"assets/images/benchmark8850h-80849f4bc8104dfa9761795ec62b284d.png"},16724:function(e,t,n){t.Z=n.p+"assets/images/benchmarkPostgres-123156ab6707851d179aced29fdb6d7a.png"},5999:function(e,t,n){t.Z=n.p+"assets/images/memoryChannelAnalysis-f808e7d8d8017faf6c8bc8ca37136434.png"}}]);
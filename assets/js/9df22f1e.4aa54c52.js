"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[6277],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return c}});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,l=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),h=u(a),c=o,p=h["".concat(s,".").concat(c)]||h[c]||m[c]||l;return a?n.createElement(p,i(i({ref:t},d),{},{components:a})):n.createElement(p,i({ref:t},d))}));function c(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=a.length,i=new Array(l);i[0]=h;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:o,i[1]=r;for(var u=2;u<l;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},33817:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},metadata:function(){return u},toc:function(){return d},default:function(){return h}});var n=a(83117),o=a(80102),l=(a(67294),a(3905)),i=a(46092),r=["components"],s={title:"Crypto Volume Profiles with QuestDB and Julia",author:"Dean Markwick",author_url:"https://github.com/dm13450",author_image_url:"https://avatars.githubusercontent.com/dm13450",description:"Build Bitcoin volume curves using Julia and QuestDB to better understand the flow of trading throughout the day.",keywords:["timeseries","julialang","trading","marketdata"],tags:["tutorial","julialang","market data","trading","bitcoin"],image:"/img/blog/2022-03-29/graph.png"},u={permalink:"/blog/2022/03/29/crypto-volumes-julia-questdb",source:"@site/blog/2022-03-29-crypto-volumes-julia-questdb.md",title:"Crypto Volume Profiles with QuestDB and Julia",description:"Build Bitcoin volume curves using Julia and QuestDB to better understand the flow of trading throughout the day.",date:"2022-03-29T00:00:00.000Z",formattedDate:"March 29, 2022",tags:[{label:"tutorial",permalink:"/blog/tags/tutorial"},{label:"julialang",permalink:"/blog/tags/julialang"},{label:"market data",permalink:"/blog/tags/market-data"},{label:"trading",permalink:"/blog/tags/trading"},{label:"bitcoin",permalink:"/blog/tags/bitcoin"}],readingTime:14.93,truncated:!1,prevItem:{title:"Demo of live crypto data streamed with QuestDB and Grafana",permalink:"/blog/2022/04/12/demo-live-crypto-data-streamed-with-questdb-and-grafana"},nextItem:{title:"Visualizing cryptocurrency data with Python, Grafana and QuestDB",permalink:"/blog/2022/03/15/cryptocurrency-grafana-questdb"}},d=[{value:"Environment",id:"environment",children:[]},{value:"Contents",id:"contents",children:[]},{value:"Importing CSVs into QuestDB via Julia",id:"importing-csvs-into-questdb-via-julia",children:[]},{value:"Bitcoin daily volume trends",id:"bitcoin-daily-volume-trends",children:[]},{value:"Bitcoin intraday volume profiles",id:"bitcoin-intraday-volume-profiles",children:[]},{value:"Bitcoin volume profiles for each weekday",id:"bitcoin-volume-profiles-for-each-weekday",children:[]},{value:"Smoothing the volume profiles with LOESS",id:"smoothing-the-volume-profiles-with-loess",children:[]},{value:"Conclusion",id:"conclusion",children:[]}],m={toc:d};function h(e){var t=e.components,s=(0,o.Z)(e,r);return(0,l.kt)("wrapper",(0,n.Z)({},m,s,{components:t,mdxType:"MDXLayout"}),(0,l.kt)(i.Z,{alt:"crypto volume profiles with questdb and julia",height:467,src:"/img/blog/2022-03-29/graph.png",width:650,mdxType:"Banner"}),(0,l.kt)("p",null,"When is the Bitcoin market most active and how does this activity change\nthroughout the day? This is an important question to answer for any algorithmic\ntrading strategy as it is more expensive to trade in low volume (illiquid) times\nand this could end up costing you money. In this post, I'll use QuestDB and\nJulia to calculate the average intraday volume profile which will show us how\nthe pattern of trading varies throughout the day."),(0,l.kt)("h2",{id:"environment"},"Environment"),(0,l.kt)("p",null,"I'm using QuestDB version 6.2 and Julia version 1.7. I've installed the\nfollowing packages from the Julia general repository."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},"using LibPQ\nusing DataFrames, DataFramesMeta\nusing PlotThemes\nusing Plots\nusing Dates\n")),(0,l.kt)("p",null,"For more information about getting setup with QuestDB read their\n",(0,l.kt)("a",{parentName:"p",href:"https://questdb.io/docs/get-started/docker/"},"get started with QuestDB")," guide."),(0,l.kt)("h2",{id:"contents"},"Contents"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#importing-csvs-into-questdb-via-julia"},"Importing CSV's into QuestDB")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#bitcoin-daily-volume-trends"},"Bitcoin daily volume trends")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#bitcoin-intraday-volume-profiles"},"Bitcoin intraday volume profiles")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#smoothing-the-volume-profiles-with-loess"},"Smoothing the volume profiles with LOESS"))),(0,l.kt)("h2",{id:"importing-csvs-into-questdb-via-julia"},"Importing CSVs into QuestDB via Julia"),(0,l.kt)("p",null,"I've written before about connecting a data source to QuestDB in real-time and\n",(0,l.kt)("a",{parentName:"p",href:"https://dm13450.github.io/2021/08/05/questdb-part-1.html"},"building you own crypto trade database"),".\nNow I will take a different approach and show you how to use QuestDB with csv\nfiles. This involves connecting to QuestDB using the REST API and passing the\nfile with a corresponding database schema."),(0,l.kt)("p",null,"As most of us have our data in CSVs, (despite the flaws) this will hopefully\nhelp you build Bitcoin volume curves using Julia and QuestDB to better\nunderstand the flow of trading throughout the day. ove to a more practical\ndatabase solution. I spent most of my Ph.D. wrestling with flat files and could\nhave saved some time by moving to a database sooner."),(0,l.kt)("p",null,"In my case, I have a folder of CSV files of BTCUSD trades downloaded from Alpaca\nMarkets (using ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/dm13450/AlpacaMarkets.jl"},"AlpacaMarkets.jl"),")\nand iterate through them to upload to QuestDB."),(0,l.kt)("p",null,"For the schema, we tell QuestDB what the column the time stamp is (",(0,l.kt)("inlineCode",{parentName:"p"},"t")," in our\ncase) and the format of the time string. Alpaca provides microseconds so that is\ntranslated into ",(0,l.kt)("inlineCode",{parentName:"p"},"yyyy-MM-ddTHH:mm:ss.SSSUUUZ"),". We then define what columns are\nsymbols."),(0,l.kt)("p",null,"What's a symbol? Well in our case it is a type of string that is constant in a\ncolumn. Some people call them enums, you might also call them factors. Symbol\nvalues can only be set few values. So for our data, the exchanges (column ",(0,l.kt)("inlineCode",{parentName:"p"},"x"),")\nare one of three values, therefore suited as a symbol."),(0,l.kt)("p",null,"For each file, we simply open and post to our localhost at port 9000 where\nQuestDB is running."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'using HTTP, JSON\n\nconst host = "http://localhost:9000"\n\nfunction run()\n  SCHEMA = [Dict("name"=>"t", "type"=>"TIMESTAMP", "pattern" => "yyyy-MM-ddTHH:mm:ss.SSSUUUZ"),\n            Dict("name" => "symbol", "type" => "SYMBOL"),\n            Dict("name" => "x", "type" => "SYMBOL"),\n            Dict("name" => "tks", "type" => "SYMBOL")]\n\n  SCHEMA_JSON = JSON.json(SCHEMA)\n\n  for (root, dirs, files) in walkdir("../data/trades/ETHUSD")\n\n    for file in files\n      fl = joinpath(root, file)\n      println(fl)\n      csvfile = open(fl)\n\n      body = HTTP.Form(["schema" => SCHEMA_JSON, "data" => csvfile])\n\n      HTTP.post(host * "/imp?name=alpaca_crypto_trades&overwrite=false&timestamp=t&partitionBy=DAY", [], body; verbose = 2)\n\n      close(csvfile)\n    end\n  end\n\nend\n\n')),(0,l.kt)("p",null,"Let's take a look at the ",(0,l.kt)("inlineCode",{parentName:"p"},"post")," command in detail:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'HTTP.post(host * "/imp?name=alpaca_crypto_trades&\n                                      overwrite=false&\n                                      timestamp=t&\n                                      partitionBy=DAY",\n                                      [], body; verbose = 2)\n')),(0,l.kt)("p",null,"We split this out into the different parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"name=alpaca_crypto_trades"),": the name of the table where we are writing the\ndata."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"overwrite=false"),": With each data file ",(0,l.kt)("em",{parentName:"li"},"don't")," overwrite the existing table,\nappend the data to the table."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"timestamp=t"),": This is the designated timestamp. This is the key column in the\ndata as our operations all depends on this timestamp. In our case, it is the\ntime at which the trade occurred, so if we want to aggregate the data to say\nhourly or even days this is the column QuestDB needs to work with."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"partitionBy=DAY"),": We have lots of data and want QuestDB to operate as\nefficiently as possible. By partitioning the data we store each day as a\nseparate file which means faster read times and better performance. In our\ncase, partitioning by each day is a sensible choice as our questions are\nlikely to be around daily statistics, (average daily volume, average daily\ndistribution). For a different application, say sensor data, you might find a\ndifferent partitioning interval works better.")),(0,l.kt)("p",null,"We iterate through all the different files and receive a message telling us\nwhether the file was successfully uploaded. We can go to the web GUI and check\nto make sure everything worked by counting the number of rows."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"QuestDB GUI screenshot",src:a(43810).Z,title:"QuestDB GUI screenshot"})),(0,l.kt)("p",null,"Now let's connect to the database in Julia and see if we get the same result."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'conn() = LibPQ.Connection("""\n             dbname=qdb\n             host=127.0.0.1\n             password=quest\n             port=8812\n             user=admin""")\n\nexecute(conn(), "SELECT count(*) FROM alpaca_crypto_trades") |> DataFrame\n')),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"center"},"count"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"center"},"54508191")))),(0,l.kt)("p",null,"The same as the above screenshot. Our import method runs without a hitch so now\nlet's do some finance."),(0,l.kt)("h2",{id:"bitcoin-daily-volume-trends"},"Bitcoin daily volume trends"),(0,l.kt)("p",null,"Bitcoin has been having a tough time recently. Everyone is back to school or\ntheir jobs and doesn't have time to day-trade cryptocurrencies anymore. Central\nbanks are raising rates, economies are about to start their 'post' COVID period\nand so many other macro factors are leading us into a new asset regime. How has\nthis changed the number of daily trades and also the total amount of traded\ndollar volume each day in Bitcoin?"),(0,l.kt)("p",null,"This type of query is where QuestDB shines and we can answer with some simple\ncode. We have partitioned our table by day and thus it can iterate through each\nday, summing the amount of volume and the total number of trades to come up with\nour daily summaries."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'dailyVolume = execute(conn(),\n"SELECT t, symbol, sum(s), count(*) FROM alpaca_crypto_trades\n  SAMPLE by 1d\n  GROUP BY symbol, t"\n) |> DataFrame\n\ndropmissing!(dailyVolume);\n\nfirst(dailyVolume, 4)\n')),(0,l.kt)("div",{class:"data-frame"},(0,l.kt)("table",{class:"data-frame"},(0,l.kt)("thead",null,(0,l.kt)("tr",null,(0,l.kt)("th",null),(0,l.kt)("th",null,"t"),(0,l.kt)("th",null,"symbol"),(0,l.kt)("th",null,"sum"),(0,l.kt)("th",null,"count"))),(0,l.kt)("tbody",null,(0,l.kt)("tr",null,(0,l.kt)("th",null,"1"),(0,l.kt)("td",null,"2021-10-23T00:00:00.098"),(0,l.kt)("td",null,"BTCUSD"),(0,l.kt)("td",null,"6721.99"),(0,l.kt)("td",null,"293601")),(0,l.kt)("tr",null,(0,l.kt)("th",null,"2"),(0,l.kt)("td",null,"2021-10-24T00:00:00.098"),(0,l.kt)("td",null,"BTCUSD"),(0,l.kt)("td",null,"8420.77"),(0,l.kt)("td",null,"369846")),(0,l.kt)("tr",null,(0,l.kt)("th",null,"3"),(0,l.kt)("td",null,"2021-10-25T00:00:00.098"),(0,l.kt)("td",null,"BTCUSD"),(0,l.kt)("td",null,"10167.0"),(0,l.kt)("td",null,"383259")),(0,l.kt)("tr",null,(0,l.kt)("th",null,"4"),(0,l.kt)("td",null,"2021-10-26T00:00:00.098"),(0,l.kt)("td",null,"BTCUSD"),(0,l.kt)("td",null,"10122.0"),(0,l.kt)("td",null,"397424"))))),(0,l.kt)("p",null,"Which we then plot as both the total volume per day and the total number of\ntrades per day."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'ticks = minimum(dailyVolume.t):Day(60):maximum(dailyVolume.t)\ntick_labels = Dates.format.(ticks, "dd-mm-yyyy")\n\nvPlot = plot(dailyVolume.t, dailyVolume.sum, label = "Notional Volume", xticks = (ticks, tick_labels))\nnPlot = plot(dailyVolume.t, dailyVolume.count, label = "Total Trades", xticks = (ticks, tick_labels))\nplot(vPlot, nPlot)\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Daily Bitcoin trends",src:a(74649).Z,title:"Daily Bitcoin trends"})),(0,l.kt)("p",null,"Both the total notional traded and the total number of daily trades dropped off\naround Christmas time, which is to be expected. We are all too busy feasting on\nturkey to be trading Bitcoin! But so far in 2022, the daily notional has\nremained subdued whereas the number of daily trades has picked up which\nindicates there are more people trading but only smaller amounts. Now given the\nabsolute rout in Bitcoin's price so far in 2022 (-20% so far) this is could\nindicate it is mainly small participants selling the smaller holdings."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'plot(dailyVolume.t, dailyVolume.sum ./ dailyVolume.count, label = "Average Trade Size")\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Bitcoin average trade size",src:a(97769).Z,title:"Bitcoin average trade size"})),(0,l.kt)("p",null,"Dividing the average daily notional by the total number of daily trades shows\nthis steady reduction in the average trade size."),(0,l.kt)("p",null,"We have an idea of how much is traded every day, but how is this distributed\nthroughout the day? Anyone trading frequently or trading with lots of volumes\nwill want to be trading when everyone else is to make sure they are getting the\nbest prices and not just pushing the price around."),(0,l.kt)("p",null,"How do we calculate these volume profiles and more importantly, how do we\ncalculate these profiles efficiently? QuestDB to the rescue!"),(0,l.kt)("h2",{id:"bitcoin-intraday-volume-profiles"},"Bitcoin intraday volume profiles"),(0,l.kt)("p",null,"For each hour and minute of the day, we want to calculate the total amount\ntraded. We then want to divide this by the total amount traded over the full\nsample to arrive at a percentage. This will then give us the fraction of the\ntotal volume traded aka the volume profile of a given day."),(0,l.kt)("p",null,"To make our life easier we create a ",(0,l.kt)("inlineCode",{parentName:"p"},"volume_minute")," table that aggregates the\nraw market data into minute frequencies."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},"execute(conn(),\n\"\nCREATE TABLE volume_minute\nAS(\n    SELECT t, avg(p) as avg_price, avg(s) as avg_size, sum(s) as total_size\n    FROM alpaca_crypto_trades\n    WHERE t >'2021-11-08'\n    SAMPLE BY 1m)\n\")\n")),(0,l.kt)("p",null,"This is exploiting the full power of QuestDB. Using the ",(0,l.kt)("inlineCode",{parentName:"p"},"SAMPLE BY")," function we\ncan reduce our raw data into 1-minute subsamples that each has the total amount\ntraded in that one minute. This function will create a new table called\n",(0,l.kt)("inlineCode",{parentName:"p"},"volume_minute")," which we can use for the rest of our analysis."),(0,l.kt)("p",null,"We can now aggregate this over the hour and minute of the day to arrive at our\nprofile of volumes over a given day. We want to know the total amount trade in\nour data set for each minute."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'intraVolume = execute(conn(), "SELECT hour(t), minute(t), sum(total_size)\n                                                  FROM volume_minute\n                                                  GROUP BY hour(t), minute(t)" ) |>\nDataFrame |> dropmissing;\n\ntotalVolume = execute(conn(),\n    "SELECT sum(total_size) from volume_minute"\n) |> DataFrame |> dropmissing;\n')),(0,l.kt)("p",null,"Once those have been calculated in QuestDB we pull them into Julia and calculate\nthe fraction of the volume traded at each hour and minute."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},"intraVolume = @transform(intraVolume,\n    :ts = DateTime(today()) + Hour.(:hour) + Minute.(:minute),\n    :frac = :sum ./ totalVolume.sum);\n")),(0,l.kt)("p",null,"Like everything in life, a graph is better than a table."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'ticks = minimum(intraVolume.ts):Hour(2):maximum(intraVolume.ts)\ntick_labels = Dates.format.(ticks, "HH:MM")\n\nplot(intraVolume.ts, intraVolume.frac,\n     xticks = (ticks, tick_labels), seriestype = :scatter, label=:none, ylabel="Fraction of Volume Traded")\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Intraday Bitcoin profile",src:a(43258).Z,title:"Intraday Bitcoin profile"})),(0,l.kt)("p",null,"This looks great, we see trading is at the lowest at 10:00 but peaks at 16:00.\nIt is very noisy though."),(0,l.kt)("p",null,"We can also think in terms of how much is left to trade at a given time of day.\nSo as the clock turns midnight we have 100% of the day's volume to trade. This\nis equivalent to calculating the cumulative proportion."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'plot(intraVolume.ts, 1 .- cumsum(intraVolume.frac),  xticks = (ticks, tick_labels),\n     label = "How much is left to trade in the day?",\n     ylabel = "Fraction of Total Volume Remaining")\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Bitcoin fraction left to trade over the day",src:a(58714).Z,title:"Bitcoin fraction left to trade over the day"})),(0,l.kt)("p",null,"So we can see that by 06:00 there is roughly still 75% of the day's volume to\ntrade. By 18:00 just over 25% left. So from our earlier analysis of how much\ndaily volume is roughly traded, we can start predicting how much volume is left\nto trade over a day when we log into our broker."),(0,l.kt)("p",null,"As Bitcoin crypto markets are unique as they trade over the weekends. So we\nshould split these volume curves up into the day of the week and see how they\nlook."),(0,l.kt)("h2",{id:"bitcoin-volume-profiles-for-each-weekday"},"Bitcoin volume profiles for each weekday"),(0,l.kt)("p",null,"This is as simple as adding an extra clause to the ",(0,l.kt)("inlineCode",{parentName:"p"},"GROUP BY")," statement to add\nthe day of the week. Again, we repeat the same process as before."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'dowLabel = DataFrame(day_of_week = 1:7,\n                     day_of_week_label = ["Mon", "Tue", "Wed",\n                                          "Thur", "Fri", "Sat", "Sun"]);\n\nintraVolume_day_req = async_execute(conn(),\n"SELECT day_of_week(t), hour(t), minute(t), sum(total_size) FROM volume_minute GROUP BY day_of_week(t), hour(t), minute(t)"\n)\n\nintraVolume_day = fetch(intraVolume_day_req) |> DataFrame |> dropmissing;\n\ntotalVolume_day = execute(conn(),\n    "SELECT day_of_week(t), sum(total_size) from volume_minute GROUP BY day_of_week(t)"\n) |> DataFrame |> dropmissing\n\nrename!(totalVolume_day, ["day_of_week", "total_daily_volume"])\ntotalVolume_day = leftjoin(totalVolume_day, dowLabel, on = "day_of_week")\n\nintraVolume_day = leftjoin(intraVolume_day, totalVolume_day, on="day_of_week");\n')),(0,l.kt)("p",null,"This gives us the total volume at each minute and hour per weekday, plus the\ntotal amount traded for that weekday in the period too."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},"intraVolume_day = @transform(intraVolume_day,\n    :ts = DateTime(today()) + Hour.(:hour) + Minute.(:minute),\n    :Volume_Frac = :sum ./ :total_daily_volume);\n\nsort!(intraVolume_day, :day_of_week)\nfirst(intraVolume_day, 4)\n")),(0,l.kt)("div",{class:"data-frame"},(0,l.kt)("table",{class:"data-frame"},(0,l.kt)("thead",null,(0,l.kt)("tr",null,(0,l.kt)("th",null,"hour"),(0,l.kt)("th",null,"minute"),(0,l.kt)("th",null,"sum"),(0,l.kt)("th",null,"total_daily_volume"),(0,l.kt)("th",null,"day_of_week_label"),(0,l.kt)("th",null,"ts"))),(0,l.kt)("tbody",null,(0,l.kt)("tr",null,(0,l.kt)("td",null,"0"),(0,l.kt)("td",null,"0"),(0,l.kt)("td",null,"369.729"),(0,l.kt)("td",null,"3.11011e5"),(0,l.kt)("td",null,"Mon"),(0,l.kt)("td",null,"2022-03-09T00:00:00")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"0"),(0,l.kt)("td",null,"1"),(0,l.kt)("td",null,"249.165"),(0,l.kt)("td",null,"3.11011e5"),(0,l.kt)("td",null,"Mon"),(0,l.kt)("td",null,"2022-03-09T00:01:00")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"0"),(0,l.kt)("td",null,"2"),(0,l.kt)("td",null,"589.069"),(0,l.kt)("td",null,"3.11011e5"),(0,l.kt)("td",null,"Mon"),(0,l.kt)("td",null,"2022-03-09T00:02:00")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"0"),(0,l.kt)("td",null,"3"),(0,l.kt)("td",null,"265.611"),(0,l.kt)("td",null,"3.11011e5"),(0,l.kt)("td",null,"Mon"),(0,l.kt)("td",null,"2022-03-09T00:03:00"))))),(0,l.kt)("p",null,"Plotting this gives us the intraday volume profile for each day of the week."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'plot(intraVolume_day.ts,\n     intraVolume_day.Volume_Frac,\n     group=intraVolume_day.day_of_week_label,\n     xticks = (ticks, tick_labels),\n     ylabel="Fraction of Volume Traded")\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Weekday volume curves",src:a(41779).Z,title:"Weekday volume curves"})),(0,l.kt)("p",null,"Very noisy! We can sort of see the general increase of volume at 16:00 similar\nto the single curve above. Comparing the weekdays becomes a bit easier when we\nlook at how left is left to trade at each time."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'gdata = groupby(intraVolume_day, :day_of_week)\nintraVolume_day = @transform(gdata, :CumVolume = cumsum(:Volume_Frac));\n\nplot(intraVolume_day.ts,\n     1 .- intraVolume_day.CumVolume,\n     group=intraVolume_day.day_of_week_label,\n     legend = :topright, xticks = (ticks, tick_labels),\n     ylabel = "Fraction of Total Volume Remaining")\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Weekday fraction left to trade",src:a(43774).Z,title:"Weekday fraction left to trade"})),(0,l.kt)("p",null,"Saturday is the day that strays away from all the others. This shows that the\nprofile of trading BTCUSD over Saturday is structurally different to the other\nweekdays. So if you are running an algorithmic trading strategy 24 hours 7 days\na week then you will need to consider how Saturday might need some special\nrules."),(0,l.kt)("h2",{id:"smoothing-the-volume-profiles-with-loess"},"Smoothing the volume profiles with LOESS"),(0,l.kt)("p",null,"The next step is to smooth these curves out. We want to remove the noise so we\ncan better understand the underlying shape of the volume traded. Plus if this\ntype of data was feeding into an algorithmic trading strategy we wouldn't want\nthe jitter of the data to influence the trading data."),(0,l.kt)("p",null,"We are going to use ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Local_regression"},"LOESS"),"\n(locally estimated scatterplot smoothing) which takes the points and looks at\nthe nearest neighbours to come up with a value that is a rough average. It then\nmoves along to the next point and repeats the process. There is a free parameter\nthat controls how far ahead and behind it looks to calculate the average which\nwe will set to 0.15."),(0,l.kt)("p",null,"This is all implemented in the\n",(0,l.kt)("a",{parentName:"p",href:"https://github.com/JuliaStats/Loess.jl"},"Loess.jl")," package, so you don't need to\nworry about what is happening, we can just use the function."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'using Loess\n\nmodel = loess(1:nrow(intraVolume), intraVolume.frac, span=0.15)\n\nvs = Loess.predict(model, Float64.(1:nrow(intraVolume)))\n\nsmoothPlot = plot(intraVolume.ts, intraVolume.frac, xticks = (ticks, tick_labels), label = "Raw")\nplot!(smoothPlot, intraVolume.ts, vs, label = "LOESS - 0.15", linewidth=3)\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"svg",src:a(22297).Z})),(0,l.kt)("p",null,"This smoothed curve produces a sensible-looking approximation to the raw data\nand removes much of the noise. The curve is a more sensible input into an\nalgorithmic trading model instead of the raw data. If we look around 14:00 we\ncan see that there is a large spike in the raw volume, whereas the LOESS curve\nsmoothes this out. If our trading model was using the raw data it might expect a\nsurge in volume at 14:00 all the time and start trading accordingly, whereas in\nreality, we are confident that is just noise and our smoothed profile is more\nreliable."),(0,l.kt)("p",null,"However, there is a major point to consider when using LOESS as a smoothing\nmethod. As it looks at a local neighbourhood of points, it is looking into the\nfuture to smooth a value in the past. If we were using these values to predict\nsomething, this would be a big no-no as we are using the information in the\nfuture to predict the past. But for this application, it is ok. We are only\ntrying to understand the shape of the curves and not predict future values,\ntherefore so long as we bear what LOESS is doing in mind, we can safely use it\nto smooth out our volume numbers. So we wouldn't be able to use LOESS in\nreal-time to smooth the market volumes as it requires points from the future."),(0,l.kt)("p",null,"With all that considered now let's apply it to the rest of our weekdays."),(0,l.kt)("p",null,"Let's write a function that does the smoothing and apply it to each different\nday of the week."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},"function loess_smooth(x; smooth=0.5)\n    model = loess(eachindex(x), x, span=smooth)\n    Loess.predict(model, Float64.(eachindex(x)))\nend\n")),(0,l.kt)("p",null,"Applying this to each weekday using the ",(0,l.kt)("inlineCode",{parentName:"p"},"groupby")," functions on the data frame."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},"gdata = groupby(intraVolume_day, :day_of_week)\nintraVolume_day = @transform(gdata, :SmoothVolume = loess_smooth(:Volume_Frac));\nsort!(intraVolume_day, :day_of_week)\ndropmissing!(intraVolume_day);\n\nweekdays = @subset(intraVolume_day, :day_of_week .<= 5)\nweekends = @subset(intraVolume_day, :day_of_week .> 5);\n")),(0,l.kt)("p",null,"I've added an indicator if it is a weekday or weekend for easy separation."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'ticks = minimum(intraVolume.ts):Hour(6):maximum(intraVolume.ts)\ntick_labels = Dates.format.(ticks, "HH:MM")\n\nweekdayPlot = plot(weekdays.ts,\n     weekdays.SmoothVolume,\n     group=weekdays.day_of_week_label,\n     xticks = (ticks, tick_labels),\n     legend = :bottomright)\nweekendPlot = plot(weekends.ts,\n     weekends.SmoothVolume,\n     group=weekends.day_of_week_label,\n     xticks = (ticks, tick_labels),\n     legend = :bottomright)\n\nplot(weekdayPlot, weekendPlot)\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"svg",src:a(14452).Z})),(0,l.kt)("p",null,"Much more interpretable! The smoothed curves make it easier to see some\ninteresting features:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Wednesday and Thursday have a second peak of trading at about 19:00."),(0,l.kt)("li",{parentName:"ul"},"Mondays and Fridays have the highest peaks at 16:00."),(0,l.kt)("li",{parentName:"ul"},"The weekend is flatter in activity, the peaks are smaller."),(0,l.kt)("li",{parentName:"ul"},"Sunday trading starts increasing earlier and then carries on as it moves into\nMonday morning."),(0,l.kt)("li",{parentName:"ul"},"Saturday follows the more typical pattern with an interesting increase at\n06:00.")),(0,l.kt)("h2",{id:"conclusion"},"Conclusion"),(0,l.kt)("p",null,"The power of QuestDB shows how easy and quick it is to gain intuition around\nwhere the most active periods of Bitcoin trading happen throughout the day.\nWe've shown how average daily volumes and number of trades has fallen in recent\nmonths which has also led to a smaller average trade size in the same period."),(0,l.kt)("p",null,"Once we looked at the average profile over the day we found that the peak\nvolumes are in the afternoon from about 15:00 onwards, coinciding with America\nwaking up and trading."),(0,l.kt)("p",null,"Finally, we then found that weekends have a less extreme profile than weekdays\nand more interestingly that Sundays trading continues in the late hours as the\nworking week begins."),(0,l.kt)("p",null,"For an algorithmic trading system, you will use this information to adjust the\nstrategy at different times of the day. A signal telling you to buy at 2 am in\nthis illiquid period could end up costing you money if you trade too\naggressively."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"This post comes from ",(0,l.kt)("a",{parentName:"em",href:"https://twitter.com/DeanMarkwick"},"Dean Markwick"),". If you\nlike this content, we'd love to hear your thoughts! Feel free to try out QuestDB\non ",(0,l.kt)("a",{parentName:"em",href:"https://github.com/questdb/questdb#try-questdb"},"GitHub")," or just come and say\nhello in ",(0,l.kt)("a",{parentName:"em",href:"https://"},"our community on Slack"),".")))}h.isMDXComponent=!0},86010:function(e,t,a){function n(e){var t,a,o="";if("string"==typeof e||"number"==typeof e)o+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(a=n(e[t]))&&(o&&(o+=" "),o+=a);else for(t in e)e[t]&&(o&&(o+=" "),o+=t);return o}function o(){for(var e,t,a=0,o="";a<arguments.length;)(e=arguments[a++])&&(t=n(e))&&(o&&(o+=" "),o+=t);return o}a.d(t,{Z:function(){return o}})}}]);
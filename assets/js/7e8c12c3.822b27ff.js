"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[3724],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),l=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(d.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,d=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(n),m=r,h=p["".concat(d,".").concat(m)]||p[m]||c[m]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},109:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},metadata:function(){return d},toc:function(){return l},default:function(){return c}});var a=n(3117),r=n(102),o=(n(7294),n(3905)),i=["components"],s={title:"Updating data",sidebar_label:"Updating data",description:"How the UPDATE statement is implemented in QuestDB."},d={unversionedId:"operations/updating-data",id:"operations/updating-data",isDocsHomePage:!1,title:"Updating data",description:"How the UPDATE statement is implemented in QuestDB.",source:"@site/docs/operations/updating-data.md",sourceDirName:"operations",slug:"/operations/updating-data",permalink:"/docs/operations/updating-data",editUrl:"https://github.com/turpleio/homepage/edit/main/docs/operations/updating-data.md",version:"current",sidebar_label:"Updating data",frontMatter:{title:"Updating data",sidebar_label:"Updating data",description:"How the UPDATE statement is implemented in QuestDB."},sidebar:"docs",previous:{title:"Backup and restore",permalink:"/docs/operations/backup"},next:{title:"Prometheus monitoring and alerting",permalink:"/docs/third-party-tools/prometheus"}},l=[{value:"Storage model",id:"storage-model",children:[]},{value:"Column versions",id:"column-versions",children:[]},{value:"Vacuum updated columns",id:"vacuum-updated-columns",children:[]},{value:"Limitations",id:"limitations",children:[]}],u={toc:l};function c(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This document describes how the UPDATE statement works in QuestDB and what happens\nunder the hood when an update is executed."),(0,o.kt)("h2",{id:"storage-model"},"Storage model"),(0,o.kt)("p",null,"To be able to understand how table rows are updated in QuestDB, first we\nneed to have an idea of how the data is stored. The documentation contains\ndetailed descriptions of the ",(0,o.kt)("a",{parentName:"p",href:"/docs/concept/storage-model"},"storage model")," and\nthe ",(0,o.kt)("a",{parentName:"p",href:"/docs/concept/root-directory-structure#db-directory"},"directory layout"),"\nbut if we quickly want to summarize it:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Each table has its own folder in the db root, the directory is named after the table"),(0,o.kt)("li",{parentName:"ul"},"Partitions are manifested as subdirectories under the folder which represents the table"),(0,o.kt)("li",{parentName:"ul"},"The actual data is stored in column files inside these subdirectories"),(0,o.kt)("li",{parentName:"ul"},"Column files store data ",(0,o.kt)("strong",{parentName:"li"},"ordered by the designated timestamp")," and they are\n",(0,o.kt)("strong",{parentName:"li"},"append-only"),". This goes naturally with time series data, just think about market\ndata where the price of different financial instruments are tracked during the\ntrading day, for example")),(0,o.kt)("h2",{id:"column-versions"},"Column versions"),(0,o.kt)("p",null,"Since the data is stored in order and the files are append-only updating it is not\nstraightforward. We took the optimistic approach and assumed that past data\nwill never have to change. This is great for read performance.\nHowever, sometimes you may need to ",(0,o.kt)("strong",{parentName:"p"},"amend data")," which has been recorded incorrectly\nbecause of a bug or for any other reason."),(0,o.kt)("p",null,"We could break our append-only model and start accessing different parts of the\ncolumn files to fix incorrect data. The problem we would face with is inconsistent\nreads. Readers running queries on the table would not be happy as they could see\nsome part of the data updated but not others."),(0,o.kt)("p",null,"The solution is to make the update ",(0,o.kt)("strong",{parentName:"p"},"transactional")," and ",(0,o.kt)("strong",{parentName:"p"},"copy-on-write"),". Basically\na new column file is created when processing the UPDATE statement. All readers are\nlooking at a previous consistent view of the data from an older column file while the\nUPDATE is in progress. Readers can find the latest committed version of column files\nbased on a record stored in a metadata file. When the update is completed and a new\ncolumn version is available for the readers, this metadata record gets updated as part\nof the commit. After metadata has changed newly submitted SELECT queries will see the\nupdated data."),(0,o.kt)("p",null,"The copy-on-write approach gives us data consistency and good performance at a price,\ndisk usage will increase. When sizing disk space we should account for extra storage\nto make sure UPDATE statements have enough headroom. Only those column files will get\na new version where data is actually changing. For example, if only a single column\nis updated in a single partition of a table, then only a single column file will be\nrewritten."),(0,o.kt)("p",null,"Please, also check the following guide on ",(0,o.kt)("a",{parentName:"p",href:"/docs/guides/modifying-data"},"modifying data"),"\nin QuestDB for additional information."),(0,o.kt)("h2",{id:"vacuum-updated-columns"},"Vacuum updated columns"),(0,o.kt)("p",null,"When a column is updated, the new version of the column is written to disk and a background\ntask starts to vacuum redundant column files. The term Vacuum originates from Postgres, it means\nthe collection of garbage and release of disk space. The Vacuum task checks periodically if\nolder column versions are still used by readers and deletes unused files.\nVacuum runs automatically and there is also a ",(0,o.kt)("a",{parentName:"p",href:"/docs/reference/sql/vacuum-table"},(0,o.kt)("inlineCode",{parentName:"a"},"VACUUM TABLE")),"\nSQL command to trigger it. "),(0,o.kt)("h2",{id:"limitations"},"Limitations"),(0,o.kt)("p",null,"Current implementation of the UPDATE operation rewrites the column files by copying\nrecords in their existing order from the previous version, and replacing the value if\nit needs changing. As a result the ",(0,o.kt)("strong",{parentName:"p"},"designated timestamp cannot be updated.")),(0,o.kt)("p",null,"Modifying the designated timestamp would lead to rewriting history of the time series.\nRecords would need to be reordered, this could even mean moving rows in between\ndifferent partitions. We may remove this limitation in the future if there is enough\ndemand by users."))}c.isMDXComponent=!0}}]);
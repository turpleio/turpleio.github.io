"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[4041],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),l=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(d.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,d=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=l(n),h=r,p=c["".concat(d,".").concat(h)]||c[h]||m[h]||o;return n?a.createElement(p,i(i({ref:t},u),{},{components:n})):a.createElement(p,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},10784:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return d},metadata:function(){return l},toc:function(){return u},default:function(){return c}});var a=n(83117),r=n(80102),o=(n(67294),n(3905)),i=n(46092),s=["components"],d={title:"QuestDB 6.6.1 - Dynamic Commits",author:"Vlad Ilyushchenko",author_title:"QuestDB Team",author_url:"https://github.com/bluestreak01",author_image_url:"https://avatars.githubusercontent.com/bluestreak01",description:"The detailed story of how QuestDB 6.6.1 increases data freshness",keywords:["engineering","community","timeseries","datafreshness","database","open source"],image:"/img/blog/2022-11-25/banner.png",tags:["timeseries","database","engineering","community","release"]},l={permalink:"/blog/2022/11/25/questdb-6.6.1-dynamic-commits",source:"@site/blog/2022-11-25-questdb-6.6.1-dynamic-commits.md",title:"QuestDB 6.6.1 - Dynamic Commits",description:"The detailed story of how QuestDB 6.6.1 increases data freshness",date:"2022-11-25T00:00:00.000Z",formattedDate:"November 25, 2022",tags:[{label:"timeseries",permalink:"/blog/tags/timeseries"},{label:"database",permalink:"/blog/tags/database"},{label:"engineering",permalink:"/blog/tags/engineering"},{label:"community",permalink:"/blog/tags/community"},{label:"release",permalink:"/blog/tags/release"}],readingTime:4.16,truncated:!0,prevItem:{title:"Listen to Your CPU - Full-table Scans Are Fast",permalink:"/blog/2022/11/30/full-table-scan-are-fast"},nextItem:{title:"SQL Extensions for Time Series Data in QuestDB - Part II",permalink:"/blog/2022/11/23/sql-extensions-time-series-data-questdb-part-ii"}},u=[{value:"QuestDB&#39;s data structure and out-of-order data ingestion",id:"questdbs-data-structure-and-out-of-order-data-ingestion",children:[]},{value:"Community-driven development",id:"community-driven-development",children:[]},{value:"Dynamic commits",id:"dynamic-commits",children:[]}],m={toc:u};function c(e){var t=e.components,d=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},m,d,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(i.Z,{alt:"QuestDB 6.6.1 release highlights",height:467,src:"/img/blog/2022-11-25/banner.png",width:650,mdxType:"Banner"}),(0,o.kt)("p",null,"We are excited to announce the release of\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/questdb/questdb/releases/tag/6.6.1"},"QuestDB 6.6.1"),", which\nbrings dynamic commits to optimize ingestion throughput and data freshness for\nreads. In this blog post, our CTO, Vlad, shares the story driving the creation\nof the dynamic commits."),(0,o.kt)("h2",{id:"questdbs-data-structure-and-out-of-order-data-ingestion"},"QuestDB's data structure and out-of-order data ingestion"),(0,o.kt)("p",null,"Many storage systems adopt a Log-Structured Merge tree at their core. QuestDB\ndiffers from them, and the ingested data will always be ordered by timestamp\nonce it is committed to disk. QuestDB 6.0 enabled\n",(0,o.kt)("a",{parentName:"p",href:"/blog/2021/05/10/questdb-release-6-0-tsbs-benchmark/"},"out-of-order ingestion"),",\nfor which we introduced a ",(0,o.kt)("a",{parentName:"p",href:"/docs/guides/out-of-order-commit-lag/"},"commit lag")," to\noptimize ingestion throughput for unordered data. The commit lag includes a\ntime-based buffer and delays the data commit. This way, out-of-order data can be\nre-ordered on the fly in memory. QuestDB's in-memory reordering is particularly\nefficient, and avoids heavy copy-on-merge operations, which would be needed\notherwise."),(0,o.kt)("p",null,"As such, we have an implicit trade-off between the ingestion throughput of\nunordered data and the availability of data for reads. A higher buffer implies a\nlonger time delay for the data to be available for reads, while a short buffer\nmight affect disk write throughput, as we need to reshuffle already committed\nout-of-order data."),(0,o.kt)("p",null,"To recap, when treating the incoming data, the commit lag ensures:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Data is sorted chronologically."),(0,o.kt)("li",{parentName:"ul"},"New data is merged with the existing one."),(0,o.kt)("li",{parentName:"ul"},"A consistent view of the existing data is maintained for concurrent reads.")),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(20450).Z})),(0,o.kt)("p",null,'For QuestDB 6.5.5 and earlier versions, users needed to understand the "shape"\nof their data to adjust the commit lag value, either through server\nconfiguration or query settings.'),(0,o.kt)("p",null,"A misconfigured commit lag would lead to user pain and frustration: some of our\nusers would expect data to be available for reads immediately, but the default\nconfiguration was out of whack. For heavy out-of-order ingestion patterns, the\ndefault commit lag would lead to too many copy-on-merge operations and\nsignificantly slow down the database. And this was where the story started."),(0,o.kt)("h2",{id:"community-driven-development"},"Community-driven development"),(0,o.kt)("p",null,"A couple of weeks ago, I was working on a massive WAL (Write Ahead Log) PR, when\nNic, our CEO, sent me a thread of messages:"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"Nic:")," FYI I asked Javier and Imre to connect and look at this commit lag\ntogether. Our default settings are not good enough\u2026Someone in the community just\nasked me if the best we can do is ingestion with a 5-minute delay. These default\nsettings give the wrong impression that we cannot process data in real time.\nLet's brainstorm.")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"Me:")," They can reduce the commit lag, why would not they do that? They can\nset it to 0?")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"Nic:")," They don't know that the commit lag is configurable, and this leaves a\nbad impression on new users.")),(0,o.kt)("p",null,"This feedback was too important to ignore, so I caught up with our Core\nEngineer, Imre Aranyosi, and DevRel, Javier Ramirez. It turned out that Javier\nhad produced a demo project in Go, sending data to QuestDB Cloud in small\nbatches - approximately 10k rows every 50 ms. When querying data from this\nproject, Javier could not see new data immediately. Similarly, data visibility\nis one of the most frequently asked questions on QuestDB Slack as well as on\nStackoverflow. To our users, it wasn't clear which configuration parameters to\nset and where to show this data, either. We had to investigate this problem\nfurther."),(0,o.kt)("p",null,"Imre and I began exploring and we soon realized that it was due to the commit\nlag setting that data were not readily available. To increase data freshness, we\nhad to commit more often and decouple the commit frequency from the commit lag\nvalue. We wanted to improve our user experience, without complicating the\ndatabase configuration. So we went back to the whiteboard and considered the\ncommit lag anew. Its optimal size depended on the shape of the incoming data,\nwhich was not static. This meant that the commit lag size had to be dynamic! We\nneeded to predict the commit lag size and resize the value dynamically."),(0,o.kt)("h2",{id:"dynamic-commits"},"Dynamic commits"),(0,o.kt)("p",null,"This is what we eventually implemented for QuestDB 6.6.1: to predict the correct\ncommit lag value, QuestDB takes the maximum of the latest 4 overlap values with\na multiplication factor - a bigger commit lag is better than a smaller one. This\nprediction is updated every second. The commit lag value shrinks down to 0 when\ndata stops overlapping (no out-of-order data) and inflates rapidly in response\nto out-of-order demands, depending on the data shape prediction."),(0,o.kt)("p",null,"Javier has upgraded his demo project to QuestDB 6.6.1 and now data is visible\ninstantly. Our DevRel is happy, and so are our users: it does not matter the\ndata ingestion method and the scope of the data, QuestDB automatically adjusts\nsettings and delivers the optimal data immediacy."),(0,o.kt)("p",null,"In short, users do not need to do anything to benefit from the optimal ingestion\nrate and data availability for read operations. Check us out on\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/questdb/questdb/tree/6.6#readme"},"GitHub")," for more details."))}c.isMDXComponent=!0},86010:function(e,t,n){function a(e){var t,n,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(r&&(r+=" "),r+=n);else for(t in e)e[t]&&(r&&(r+=" "),r+=t);return r}function r(){for(var e,t,n=0,r="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(r&&(r+=" "),r+=t);return r}n.d(t,{Z:function(){return r}})},20450:function(e,t,n){t.Z=n.p+"assets/images/commit_lag-6f98392ba73df62e9123a813795cd08a.png"}}]);
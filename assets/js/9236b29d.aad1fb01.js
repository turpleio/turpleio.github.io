"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[5121],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),u=r,h=p["".concat(l,".").concat(u)]||p[u]||m[u]||o;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},12083:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var a=n(83117),r=n(80102),o=(n(67294),n(3905)),i=n(72525),s=["components"],l={title:"Storage model",sidebar_label:"Storage model",description:"Overview of QuestDB's column-based storage model. It ensures table level atomicity and durability while keeping low overhead for maximum performance."},c={unversionedId:"concept/storage-model",id:"concept/storage-model",isDocsHomePage:!1,title:"Storage model",description:"Overview of QuestDB's column-based storage model. It ensures table level atomicity and durability while keeping low overhead for maximum performance.",source:"@site/docs/concept/storage-model.md",sourceDirName:"concept",slug:"/concept/storage-model",permalink:"/docs/concept/storage-model",editUrl:"https://github.com/turpleio/homepage/edit/main/docs/concept/storage-model.md",version:"current",sidebar_label:"Storage model",frontMatter:{title:"Storage model",sidebar_label:"Storage model",description:"Overview of QuestDB's column-based storage model. It ensures table level atomicity and durability while keeping low overhead for maximum performance."},sidebar:"docs",previous:{title:"Telegraf",permalink:"/docs/third-party-tools/telegraf"},next:{title:"Designated timestamp",permalink:"/docs/concept/designated-timestamp"}},d=[{value:"Append model",id:"append-model",children:[]},{value:"Read model",id:"read-model",children:[]},{value:"Consistency and durability",id:"consistency-and-durability",children:[]},{value:"Summary",id:"summary",children:[]}],m={toc:d};function p(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"QuestDB uses a ",(0,o.kt)("strong",{parentName:"p"},"column-based")," storage model. Data is stored in tables with\neach column stored in its own file and its own native format. New data is\nappended to the bottom of each column to allow data to be organically retrieved\nin the same order that it was ingested."),(0,o.kt)("h2",{id:"append-model"},"Append model"),(0,o.kt)("p",null,"QuestDB appends one column at a time and each one is updated using the same\nmethod. The tail of column file is mapped into the memory page in RAM and the\ncolumn append is effectively a memory write at an address. Once the memory page\nis exhausted it is unmapped and a new page is mapped."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"This method ensures minimum resource churn and consistent append latency.")),(0,o.kt)(i.Z,{alt:"Architecture of the file storing a column",height:435,src:"/img/docs/concepts/columnUpdate.svg",width:745,mdxType:"Screenshot"}),(0,o.kt)("h2",{id:"read-model"},"Read model"),(0,o.kt)("p",null,"Table columns are randomly accessible. Columns with fixed size data types are\nread by translating the record number into a file offset by a simple bit shift.\nThe offset in the column file is then translated into an offset in a lazily\nmapped memory page, where the required value is read from."),(0,o.kt)(i.Z,{alt:"Diagram showing how the data from a column file is mapped to the memory",height:447,src:"/img/docs/concepts/columnRead.svg",width:745,mdxType:"Screenshot"}),(0,o.kt)("h2",{id:"consistency-and-durability"},"Consistency and durability"),(0,o.kt)("p",null,"QuestDB ensures table level ",(0,o.kt)("strong",{parentName:"p"},"isolation")," and ",(0,o.kt)("strong",{parentName:"p"},"consistency")," by applying table\nupdates ",(0,o.kt)("strong",{parentName:"p"},"atomically"),". Updates to a table are applied in the context of a table\ntransaction which is either committed or rolled back in an atomic operation.\nQueries that are concurrent with table updates are consistent in the sense that\nthey will return data either as it was before or after the table transaction was\ncommitted \u2014 no intermediate uncommitted data will be shown in a query result."),(0,o.kt)("p",null,"To guarantee ",(0,o.kt)("strong",{parentName:"p"},"atomicity"),", each table maintains a ",(0,o.kt)("inlineCode",{parentName:"p"},"last_committed_record_count"),"\nin a separate file. By convention, any table reader will never read more records\nthan the transaction count. This enables the ",(0,o.kt)("strong",{parentName:"p"},"isolation")," property: where\nuncommitted data cannot be read. Since uncommitted data is appended directly to\nthe table, the transaction size is only limited by the available disk space."),(0,o.kt)("p",null,"Once all data is appended, QuestDB ",(0,o.kt)("inlineCode",{parentName:"p"},"commit()")," ensures that the transaction count\nis updated atomically both in multi-threaded and multi-process environments. It\ndoes so lock-free to ensure minimal impact on concurrent reads."),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"consistency")," assurance of the data stored is limited to QuestDB\nauto-repairing abnormally terminated transactions. We do not yet support\nuser-defined constraints, checks and triggers."),(0,o.kt)("p",null,"By default QuestDB relies on OS-level data ",(0,o.kt)("strong",{parentName:"p"},"durability")," leaving the OS to\nwrite dirty pages to disk. Data durability can be also configured with\n",(0,o.kt)("inlineCode",{parentName:"p"},"commit()")," optionally being able to invoke ",(0,o.kt)("inlineCode",{parentName:"p"},"msync()")," with a choice of\nsynchronous or asynchronous IO. The ",(0,o.kt)("inlineCode",{parentName:"p"},"msync()")," calls are made for column files\nonly, so while the ",(0,o.kt)("inlineCode",{parentName:"p"},"sync"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"async")," commit modes improve the overall durability,\nthey don't guarantee durability in the face of OS errors or power loss."),(0,o.kt)(i.Z,{alt:"Diagram of a commit across several column files",height:426,src:"/img/docs/concepts/commitModel.svg",width:745,mdxType:"Screenshot"}),(0,o.kt)("h2",{id:"summary"},"Summary"),(0,o.kt)("p",null,"The QuestDB storage model uses memory mapped files and cross-process atomic\ntransaction updates as a low overhead method of inter-process communication.\nData committed by one process can be instantaneously read by another process,\neither randomly (via queries) or incrementally (as a data queue). QuestDB provides\na variety of reader implementations."),(0,o.kt)(i.Z,{alt:"Architecture of the storage model with column files, readers/writers and the mapped memory",height:596,src:"/img/docs/concepts/storageSummarized.svg",width:745,mdxType:"Screenshot"}),(0,o.kt)("span",null))}p.isMDXComponent=!0},86010:function(e,t,n){function a(e){var t,n,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(r&&(r+=" "),r+=n);else for(t in e)e[t]&&(r&&(r+=" "),r+=t);return r}function r(){for(var e,t,n=0,r="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(r&&(r+=" "),r+=t);return r}n.d(t,{Z:function(){return r}})}}]);
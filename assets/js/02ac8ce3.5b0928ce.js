"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[2972],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=d(n),m=r,h=p["".concat(l,".").concat(m)]||p[m]||c[m]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},99077:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},metadata:function(){return d},toc:function(){return u},default:function(){return p}});var a=n(83117),r=n(80102),o=(n(67294),n(3905)),i=n(72525),s=["components"],l={title:"How to generate time-series data in QuestDB",author:"G\xe1bor Boros",author_title:"Guest",author_url:"https://github.com/gabor-boros",author_image_url:"https://avatars.githubusercontent.com/gabor-boros",description:"Learn how to mock timeseries data using built-in SQL functions in QuestDB to generate dummy data for testing and rapid prototyping according to your schemas.",keywords:["timeseries","questdb","sql","database"],tags:["tutorial","timeseries","sql"],image:"/img/blog/shared/og-sql.png"},d={permalink:"/blog/2022/03/14/mock-sql-timeseries-data-questdb",source:"@site/blog/2022-03-14-mock-sql-timeseries-data-questdb.mdx",title:"How to generate time-series data in QuestDB",description:"Learn how to mock timeseries data using built-in SQL functions in QuestDB to generate dummy data for testing and rapid prototyping according to your schemas.",date:"2022-03-14T00:00:00.000Z",formattedDate:"March 14, 2022",tags:[{label:"tutorial",permalink:"/blog/tags/tutorial"},{label:"timeseries",permalink:"/blog/tags/timeseries"},{label:"sql",permalink:"/blog/tags/sql"}],readingTime:11.095,truncated:!1,prevItem:{title:"Visualizing cryptocurrency data with Python, Grafana and QuestDB",permalink:"/blog/2022/03/15/cryptocurrency-grafana-questdb"},nextItem:{title:"Exploring Crypto Prices with QuestDB and Pandas",permalink:"/blog/2022/03/08/questdb-crypto-pandas"}},u=[{value:"Mocking and generating time series data",id:"mocking-and-generating-time-series-data",children:[]},{value:"Types of time series data",id:"types-of-time-series-data",children:[]},{value:"What is mocking and why is it useful?",id:"what-is-mocking-and-why-is-it-useful",children:[]},{value:"Running QuestDB",id:"running-questdb",children:[]},{value:"Mocking different types of data in QuestDB",id:"mocking-different-types-of-data-in-questdb",children:[]},{value:"Generator functions in QuestDB",id:"generator-functions-in-questdb",children:[]},{value:"Creating realistic generative data",id:"creating-realistic-generative-data",children:[]},{value:"Summary",id:"summary",children:[]}],c={toc:u};function p(e){var t=e.components,l=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},c,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(i.Z,{alt:"The QuestDB logo",height:591,src:"/img/blog/2022-03-14/banner.png",width:770,mdxType:"Screenshot"}),(0,o.kt)("p",null,"This post comes from G\xe1bor Boros, who has written an excellent tutorial that\nshows how to mock timeseries data using built-in SQL functions in QuestDB to\ngenerate dummy data for testing and rapid prototyping according to custom\nschemas. Thanks for the submission, G\xe1bor!"),(0,o.kt)("h2",{id:"mocking-and-generating-time-series-data"},"Mocking and generating time series data"),(0,o.kt)("p",null,"As developers, we often have to generate sample data for numerous reasons:\nfeeding integration tests, realistic staging environments or developing an\napplication locally."),(0,o.kt)("p",null,"This process can be time-consuming, especially when we need data on a bigger\nscale. Fortunately, some databases are helping our work and trying to offload\nsome weight from our shoulders by providing functions to generate data."),(0,o.kt)("p",null,"This tutorial will cover how to generate test data using QuestDB using built-in\ngenerators so you can quickly mock data similar to your own production data."),(0,o.kt)("h2",{id:"types-of-time-series-data"},"Types of time series data"),(0,o.kt)("p",null,'Before diving deep into generating data using QuestDB, we need to take one step\nback to discuss what types of time series data we can generate, what "mock data"\nis, and what generator functions are available for use. Let\'s start with the\ndifferent types of time series data. We can classify the data based on the\nfrequency we receive them into two categories: regular and irregular data.'),(0,o.kt)("p",null,"Regular data is received per a pre-defined period, usually collected by a\ncollector node or sent by an agent. Collecting metrics from a server fits into\nthis category perfectly, as shown in the tutorial where we\n",(0,o.kt)("a",{parentName:"p",href:"/blog/2021/07/09/telegraf-and-questdb-for-storing-metrics-in-a-timeseries-database/"},"connected Telegraf with QuestDB"),".\nThe Telegraf agent running on the server collects the metrics on a pre-defined\nbasis and sends them to the QuestDB instance."),(0,o.kt)("p",null,"The opposite of regular data is the irregular data which is collected\ndynamically. The main point about irregular data is that we cannot predict how\noften the data will arrive. As of examples,\n",(0,o.kt)("a",{parentName:"p",href:"/blog/2021/03/31/automating-etl-jobs-on-time-series-data-on-gcp/"},"automating ETL jobs"),"\ncould be a great example. The data comes in when automation or the user sends it\nto the pipeline, hence we cannot know beforehand the data arrives."),(0,o.kt)("p",null,"Of course, these categories can split into multiple groups, for instance, based\non the field it used: IoT, financial, operations, industrial telemetry, and so\non. Regardless of how we categorize the data, the most important is knowing the\ndata and use-case before generating it."),(0,o.kt)("h2",{id:"what-is-mocking-and-why-is-it-useful"},"What is mocking and why is it useful?"),(0,o.kt)("p",null,"Software development is about making things, but in some cases, testing what we\nmake is challenging. There are multiple scenarios when we want to check for\nerrors and failures, invalid input, we need lots of test data, or we want to\noperate a production-like environment without user data."),(0,o.kt)("p",null,"The function or application we test may have dependencies. To test the edge\ncases, we have to isolate and simulate the behavior of these dependencies. This\nkind of simulation can happen on multiple levels. Think about integration test\nsuites; we do not want to imitate the behavior of the components we are testing,\nbut we may want to load fake data in the system."),(0,o.kt)("p",null,"Simulation of the behavior of components or data is called mocking. Remember the\nETL job mentioned above. If we would like to test hundreds of thousands of\nprocessing, we would need to craft the input data on our own. That would be\ntime-consuming and ineffective. On the other hand, generating mock data help us\nfocus on the processor job, not the data generation."),(0,o.kt)("p",null,"The way we generate mock data may differ case-by-case. Since it highly depends\non the application being developed, let's see how can we mock different types of\ndata with QuestDB easily."),(0,o.kt)("h2",{id:"running-questdb"},"Running QuestDB"),(0,o.kt)("p",null,"To discover the capabilities of how QuestDB can generate data for us, we need to\nrun it. We will use ",(0,o.kt)("a",{parentName:"p",href:"https://www.docker.com/"},"Docker")," and the latest\n",(0,o.kt)("a",{parentName:"p",href:"https://hub.docker.com/r/questdb/questdb"},"questdb")," Docker image for\nconvenience. To start QuestDB via Docker, run the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"docker run -p 9000:9000 \\\n  -p 9009:9009 \\\n  -p 8812:8812 \\\n  questdb/questdb\n")),(0,o.kt)("p",null,"Alternatively, macOS users can use Homebrew:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"brew install questdb\nbrew services start questdb\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://questdb.io/get-questdb/"},"QuestDB downloads page")," has downloads for\nbinaries if you wish to run it as a standalone."),(0,o.kt)("h2",{id:"mocking-different-types-of-data-in-questdb"},"Mocking different types of data in QuestDB"),(0,o.kt)("p",null,"After starting QuestDB, the web console is available on port ",(0,o.kt)("inlineCode",{parentName:"p"},"9000"),", so\nnavigating to ",(0,o.kt)("inlineCode",{parentName:"p"},"http://127.0.0.1:9000")," should show the UI of a locally-running\ninstance which looks like the following:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"webui",src:n(37675).Z})),(0,o.kt)("p",null,"Mock data generation in QuestDB is surprisingly easy. The DB comes with numerous\ngenerator functions, all with a different purpose. If you ever used PostgreSQL's\n",(0,o.kt)("inlineCode",{parentName:"p"},"generate_series"),", you will find QuestDB's generator functions pleasant and\nrelieving. To generate rows, we use the\n",(0,o.kt)("a",{parentName:"p",href:"https://questdb.io/docs/reference/function/row-generator/"},(0,o.kt)("inlineCode",{parentName:"a"},"long_sequence")),"\ngenerator function that can create billions of rows depending on our needs. Its\nsyntax looks like"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ebnf"},"SELECT <COLUMNS> FROM long_sequence(<NUMBER_OF_ROWS>[, <SEED1>, <SEED2>]]);\n")),(0,o.kt)("p",null,"If we need deterministic row generation, we can optionally provide ",(0,o.kt)("inlineCode",{parentName:"p"},"<SEED1>")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"<SEED2>"),", that are ",(0,o.kt)("inlineCode",{parentName:"p"},"64")," bit integers, and anchor the start of the random\ngenerator to obtain the same sequence on every run. That could be useful when\npopulating data for tests, CI/CD pipelines, or development environments. Let's\ngenerate some rows to see ",(0,o.kt)("inlineCode",{parentName:"p"},"long_sequence")," in action."),(0,o.kt)("p",null,"For a first query, paste the following in the SQL editor:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"SELECT x, x*x FROM long_sequence(5);\n")),(0,o.kt)("p",null,"You will see five rows with two columns. The first column counts from one to\nfive, while the second column contains the square of the values of column one."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"x"),(0,o.kt)("th",{parentName:"tr",align:null},"column"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"1"),(0,o.kt)("td",{parentName:"tr",align:null},"1")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"2"),(0,o.kt)("td",{parentName:"tr",align:null},"4")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"3"),(0,o.kt)("td",{parentName:"tr",align:null},"9")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"4"),(0,o.kt)("td",{parentName:"tr",align:null},"16")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"5"),(0,o.kt)("td",{parentName:"tr",align:null},"25")))),(0,o.kt)("p",null,"Easy, right? It is that simple to get started on generating mock data with\nQuestDB. We have basic example of generating numbers, and next, we'll look at\ngenerating booleans, characters, strings, timestamps, and many more types."),(0,o.kt)("h2",{id:"generator-functions-in-questdb"},"Generator functions in QuestDB"),(0,o.kt)("p",null,"We have seen how to generate basic rows, and we mentioned random value\ngeneration too. It's time to see how we can generate random values with\nQuestDB's built-in\n",(0,o.kt)("a",{parentName:"p",href:"https://questdb.io/docs/reference/function/random-value-generator"},"random generator functions"),"."),(0,o.kt)("p",null,"QuestDB supports random generator functions for several\n",(0,o.kt)("a",{parentName:"p",href:"https://questdb.io/docs/reference/sql/datatypes"},"data types"),":"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"type"),(0,o.kt)("th",{parentName:"tr",align:null},"generator function"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"binary"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_bin"},"rnd_bin"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"boolean"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_boolean"},"rnd_boolean"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"byte"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_byte"},"rnd_byte"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"char"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_char"},"rnd_char"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"date"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_date"},"rnd_date"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"double"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_double"},"rnd_double"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"float"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_float"},"rnd_float"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"geohash"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/spatial/#rnd_geohash"},"rnd_geohash"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"int"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_int"},"rnd_int"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"long256"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_long256"},"rnd_long256"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"long"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_long"},"rnd_long"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"short"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_short"},"rnd_short"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"string"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_str"},"rnd_str"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"symbol"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_symbol"},"rnd_symbol"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"timestamp"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://questdb.io/docs/reference/function/random-value-generator#rnd_timestamp"},"rnd_timestamp"))))),(0,o.kt)("p",null,"All these functions can be parameterized with seed values to narrow the\nfunction's range. This is an extremely useful feature, especially if we need to\ndebug our application using the generated test data."),(0,o.kt)("p",null,"Although these functions can be handy in many scenarios, it is important to\nhighlight that these functions should be used for populating test tables only.\nThey do not hold values in memory and calculations should not be performed at\nthe same time as the random numbers are generated."),(0,o.kt)("p",null,"The best practice when populating test tables is creating the table first, then\npopulating and querying it. Consider the following example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"SELECT round(a,2), a FROM (SELECT rnd_double() a FROM long_sequence(10));\n")),(0,o.kt)("p",null,"This would return inconsistent and ephemeral results while the approach below\nwill return consistent results that are persisted as a normal database table."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"-- creating the table first\nCREATE TABLE test(val double);\n-- populating the test table\nINSERT INTO test SELECT * FROM (SELECT rnd_double() FROM long_sequence(10));\n-- querying generated data\nSELECT round(val,2) FROM test;\n")),(0,o.kt)("p",null,"Now that we know what types of data can be generated and have seen how to\ngenerate random values, it is time to create more complex data."),(0,o.kt)("h2",{id:"creating-realistic-generative-data"},"Creating realistic generative data"),(0,o.kt)("p",null,"To see data generation in action, we will replicate the schema used by the\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/timescale/tsbs"},"Time Series Benchmark Suite"),", a tool for\ncomparing and evaluating databases for time series data."),(0,o.kt)("p",null,"In the benchmarking example, TSBS uses truck diagnostic data sent through the\nInfluxDB protocol to populate tables. We will take a different approach. Instead\nof sending the data, we will generate it directly using the web UI."),(0,o.kt)("p",null,"Following the approach described above, let's create the table first. Navigate\nto the web UI and create the ",(0,o.kt)("inlineCode",{parentName:"p"},"diagnostics")," table that you can see below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"CREATE TABLE 'diagnostics' (\n    name                     STRING,   -- identifier of the truck\n    fleet                    STRING,   -- division where the truck belongs to\n    driver                   STRING,   -- the name of the driver who drove the track on the given day\n    model                    STRING,   -- the model of the truck\n    device_version           STRING,   -- version number of the data collector device\n    load_capacity            INT,      -- maximum load capacity of the truck at the beginning of the shift\n    fuel_capacity            INT,      -- fuel capacity of the truck at the beginning of the shift\n    nominal_fuel_consumption INT,      -- fuel consumption at the given time\n    fuel_state               DOUBLE,   -- the current state of the fuel level: 1 is full, 0 is empty\n    current_load             INT,      -- the weight of the current load\n    status                   INT,      -- status of the truck\n    ts                       TIMESTAMP -- timestamp the diagnostic entry got recorded\n) timestamp(ts) PARTITION BY year;\n")),(0,o.kt)("p",null,"By this point, we have the table without any records. For now, we don't set\nconstraints on the data, like the capacity must be consistent or fuel capacity\nshould remain the same over the days. Also, we assume that we get a report from\na sensor per hour, no matter from which truck."),(0,o.kt)("p",null,"Keeping the above in mind, let's populate the table with some test data. For\ndoing that, we are going to use four different random value generators, namely\n",(0,o.kt)("inlineCode",{parentName:"p"},"rnd_int"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"rnd_double"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"rnd_str"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"rnd_timestamp"),". All these functions\nhave different arguments and capabilities. To generate some rows, run the\nfollowing query:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"INSERT INTO 'diagnostics' SELECT * FROM (\n    SELECT\n        rnd_str('truck_1234', 'truck_5678', 'truck_9123', 'truck_3210'),\n        rnd_str('North', 'East', 'South', 'West'),\n        rnd_str('Alice', 'Bob', 'John', 'Mike', 'Robert'),\n        rnd_str('G-0', 'H-2', 'I-1'),\n        rnd_str('v1.2', 'v1.3'),\n        rnd_int(1000, 1500, 0),\n        rnd_int(150, 200, 0),\n        rnd_int(0, 15, 0),\n        rnd_double(),\n        rnd_int(0, 1500, 0),\n        rnd_int(0, 4, 0),\n        rnd_timestamp(\n            to_timestamp('2022-01-01T00:00:00', 'yyyy-mm-ddTHH:mm:ss'),\n            to_timestamp('2022-02-28T23:00:00', 'yyyy-mm-ddTHH:mm:ss'),\n            0\n        )\n    FROM long_sequence(28)\n);\n")),(0,o.kt)("p",null,"After the query ran successfully, ensure we have the 28 records we expect. Run\n",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT * FROM 'diagnostics';")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"generated-rows",src:n(45345).Z})),(0,o.kt)("p",null,"Congratulations, we successfully generated twenty eight rows with random data.\nAlthough the data is in place, the timestamps seem to be odd; we have multiple\nrecords for the same hour. The reason behind this is how ",(0,o.kt)("inlineCode",{parentName:"p"},"rnd_timestamp")," works.\nIt generates data within the given range, without considering any sequence."),(0,o.kt)("p",null,"To fix this issue, we need to use a timestamp sequence generator, called\n",(0,o.kt)("inlineCode",{parentName:"p"},"timestamp_sequence"),". This generator can be used as a timestamp generator to\ncreate data for testing. The timestamp is increased by providing a ",(0,o.kt)("inlineCode",{parentName:"p"},"steps"),"\nargument, which sets the step size in microseconds."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"SELECT\n    timestamp_sequence(\n        to_timestamp('2022-02-01T00:00:00', 'yyyy-mm-ddTHH:mm:ss'),\n        3600000000L\n    )\nFROM long_sequence(10);\n")),(0,o.kt)("p",null,"Running the query above generates ten rows, where every row will follow the\nprevious row's value increased by one hour."),(0,o.kt)("p",null,"Now that we know how we can generate sequentially increasing timestamps,\nrefactor the query we used to generate test data as follows. Before running the\nquery, execute ",(0,o.kt)("inlineCode",{parentName:"p"},"truncate table 'diagnostics'")," to clean up the previously\ngenerated rows."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-questdb-sql"},"INSERT INTO 'diagnostics' SELECT * FROM (\n    SELECT\n        rnd_str('truck_1234', 'truck_5678', 'truck_9123', 'truck_3210'),\n        rnd_str('North', 'East', 'South', 'West'),\n        rnd_str('Alice', 'Bob', 'John', 'Mike', 'Robert'),\n        rnd_str('G-0', 'H-2', 'I-1'),\n        rnd_str('v1.2', 'v1.3'),\n        rnd_int(1000, 1500, 0),\n        rnd_int(150, 200, 0),\n        rnd_int(0, 15, 0),\n        rnd_double(),\n        rnd_int(0, 1500, 0),\n        rnd_int(0, 4, 0),\n        timestamp_sequence(\n            to_timestamp('2022-01-01T00:00:00', 'yyyy-mm-ddTHH:mm:ss'),\n            3600000000L\n        )\n    FROM long_sequence(28)\n);\n")),(0,o.kt)("p",null,"The new query will create 28 records, where all timestamps increase by one hour.\nAlthough this is close to what we would like to see, it is still not 28 days.\nFrom now on, we need to do some basic math. To get 28 days of records where\nevery record is one hour away from the previous one, we need to generate\n",(0,o.kt)("inlineCode",{parentName:"p"},"28 * 24")," records (that's 672 records)."),(0,o.kt)("p",null,"Changing ",(0,o.kt)("inlineCode",{parentName:"p"},"FROM long_sequence(28)")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"FROM long_sequence(672)")," and running the\nquery will generate the expected number of records with the expected timestamp\ndifferences."),(0,o.kt)("p",null,'So far, we have learned how to generate simple and more complex test data, also\nwe experienced the difference between generating random timestamps and\nsequentially increasing timestamps. You may now wonder, "How could we generate\nten years of data?". The answer is simple, and you probably assume it: let\'s\ncalculate a bit.'),(0,o.kt)("p",null,"If we would like to generate test data for one year, we would need to generate\n",(0,o.kt)("inlineCode",{parentName:"p"},"365 * 24")," records. Based on this logic, to produce the desired ten years of\nrandom data we generate ",(0,o.kt)("inlineCode",{parentName:"p"},"10 * 365 * 24")," records, which is 87600 rows. By simply\nchanging the ",(0,o.kt)("inlineCode",{parentName:"p"},"long_sequence")," parameters to ",(0,o.kt)("inlineCode",{parentName:"p"},"87600")," and running the query one\nmore time, we can generate data for the next ten years in less than a second."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"final-rows",src:n(70691).Z})),(0,o.kt)("h2",{id:"summary"},"Summary"),(0,o.kt)("p",null,"In this tutorial, we discussed what mock data is useful, what kinds of types are\navailable in QuestDB, how to generate random data, and create tables with test\ndata for 1, 3, or 10 years. This tutorial demonstrated well how to combine the\ngenerator functions to create complex generative data. Thanks for your\nattention!"),(0,o.kt)("p",null,"If you like this content, we'd love to know your thoughts. Feel free to share\nyour feedback or just come and say hello in the\n",(0,o.kt)("a",{parentName:"p",href:"https://"},"QuestDB Community Slack"),"."))}p.isMDXComponent=!0},86010:function(e,t,n){function a(e){var t,n,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(r&&(r+=" "),r+=n);else for(t in e)e[t]&&(r&&(r+=" "),r+=t);return r}function r(){for(var e,t,n=0,r="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(r&&(r+=" "),r+=t);return r}n.d(t,{Z:function(){return r}})}}]);
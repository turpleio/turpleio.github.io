"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[2349],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return h}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var u=r.createContext({}),l=function(e){var n=r.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=l(e.components);return r.createElement(u.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=l(t),h=a,m=d["".concat(u,".").concat(h)]||d[h]||p[h]||o;return t?r.createElement(m,s(s({ref:n},c),{},{components:t})):r.createElement(m,s({ref:n},c))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=d;var i={};for(var u in n)hasOwnProperty.call(n,u)&&(i[u]=n[u]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=t[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9989:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return u},metadata:function(){return l},toc:function(){return c},default:function(){return d}});var r=t(83117),a=t(80102),o=(t(67294),t(3905)),s=t(46092),i=["components"],u={title:"How we built inter-thread messaging from scratch",author:"Vlad Ilyushchenko",author_title:"QuestDB Team",author_url:"https://github.com/bluestreak01",author_image_url:"https://avatars.githubusercontent.com/bluestreak01",description:"Detailed explanation of QuestDB's thread messaging system. A benchmark also shows the capabilities of this system.",keywords:["performance","opensource","inter-thread messaging","questdb","database","architecture"],tags:["engineering","multithreading","architecture"],image:"/img/blog/2020-03-15/header.png"},l={permalink:"/blog/2021/11/03/interthread",source:"@site/blog/2021-11-03-interthread.md",title:"How we built inter-thread messaging from scratch",description:"Detailed explanation of QuestDB's thread messaging system. A benchmark also shows the capabilities of this system.",date:"2021-11-03T00:00:00.000Z",formattedDate:"November 3, 2021",tags:[{label:"engineering",permalink:"/blog/tags/engineering"},{label:"multithreading",permalink:"/blog/tags/multithreading"},{label:"architecture",permalink:"/blog/tags/architecture"}],readingTime:6.155,truncated:!0,prevItem:{title:"Why I joined QuestDB as a core database engineer",permalink:"/blog/2021/11/09/miguel-arregui-working-at-questdb"},nextItem:{title:"Real-time stock price dashboard using QuestDB, Python and Plotly",permalink:"/blog/2021/11/01/plotly-finnhub-realtime-dashboard"}},c=[{value:"Architecture",id:"architecture",children:[]},{value:"Performance",id:"performance",children:[]},{value:"How to get it",id:"how-to-get-it",children:[]}],p={toc:c};function d(e){var n=e.components,t=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)(s.Z,{alt:"Flock of birds flying in a harmonised way",height:360,src:"/img/blog/2020-03-15/header.png",width:650,mdxType:"Banner"}),(0,o.kt)("p",null,"Inter-thread messaging is a fundamental part of any asynchronous system. It is\nthe component responsible for the transportation of data between threads.\nMessaging forms the infrastructure, scaffolding multi-threaded applications, and\njust like real-world transport infrastructure, we want it to be inexpensive,\nfast, reliable, and clean. For QuestDB, we wrote our own messaging system, and\nthis post is about how it works and how fast it is."),(0,o.kt)("h2",{id:"architecture"},"Architecture"),(0,o.kt)("p",null,"Borrowing heavily from world-famous Disruptor our messaging revolves around\nmultiple threads accessing shared circular data structure. We call it RingQueue.\nSemantically RingQueue provides unbounded, index-based, random access to its\nelements. It does not coordinate concurrent access nor does it provide\nguarantees on thread safety. Coordination and thread-safety is a concern of\nSequences. Sequences are responsible for providing indices that can be used to\naccess RingQueue concurrently and safely."),(0,o.kt)("p",null,"To help sequences do their magic they have to be shaped into a graph. We start\nwith syntax to chain sequences together:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"a.then(b).then(c).then(d)")),(0,o.kt)("p",null,"The result is a trivial sequence graph:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"a -> b -> c -> d")),(0,o.kt)("p",null,"To branch we use helper class FanOut:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"a.then(FanOut.to(b).and(c)).then(d)")),(0,o.kt)("p",null,"The result is this sequence graph:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"     +--\x3e B --\x3e+\nA --\x3e|         |--\x3e D\n     +--\x3e C --\x3e+\n")),(0,o.kt)("p",null,"These two pieces of syntax are flexible enough to create any desired flow. This\nexample shows that FanOut can have chain of sequences and other FanOuts:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"a.then(FanOut.to(FanOut.to(b).and(c)).and(d.then(e)).then(f)")),(0,o.kt)("p",null,"It is quite a mouthful but it creates this nice little graph:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"        +--\x3e B --\x3e+\n    +-> |         |\n    |   +--\x3e C --\x3e+\nA--\x3e|             |--\x3e F\n    |             |\n    +-> D -> E --\x3e+\n")),(0,o.kt)("p",null,"FanOut can also be used as a placeholder in a chain to allow threads to\nsubscribe/unsubscribe on the fly. Dynamic subscription is then simply adding a\nnew sequence to FanOut:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"// You can add as many sequences into fan out as you like.\n// Sequences can be added either up front or subscribe/unsubscribe on the fly.\nFanOut fanOut = new FanOut();\n\n// ordinary producer sequence\nSequence seqProducer = new SPSequence(queue.getCapacity());\n// daisy chain producer and fan out and loop back producer\nseqProducer.then(fanOut).then(seqProducer);\n\n// meanwhile in another thread ....\n...\n\n// Add individual consumer sequences later as needed.\n// This is thread safe non-blocking operation that can be performed from any thread.\n// It is important to use current producer position as consumer starting point when subscribing on the fly.\nSequence consumer1 = fanOut.addAndGet(new SCSequence(seqProducer.current()));\n\n// do something useful with consumer1 sequence\n...\n\n// remove sequence from fanOut to unsubscribe\nfanOut.remove(consumer1);\n")),(0,o.kt)("p",null,"Typical graph must contain single producer sequence and one or more consumer\nsequences. It will also have to be circular, e.g. to start and end with producer\nsequence. Graph has to be circular because we use circular underlying data\nstructure, RingQueue. Without loop-back producer would be liable to overwrite\nqueue elements before consumers had a chance to read them. Worse still, queue\nelements can be written to and read from concurrently. We don't want that to\nhappen, right?"),(0,o.kt)("p",null,"To help create practical sequence graph we implemented 4 types of sequences we\ncan play with. These sequences are better understood as combination of their\ntypes and properties. SP - single producer, MP - multiple producer, SC - single\nconsumer and MC - multiple consumer. Multi- sequences allow concurrent access\nand they guarantee that no two threads can retrieve same index. It is this\nproperty adds extra fun dimension to sequence graphs. Consider this graph:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"A -> B -> A")),(0,o.kt)("p",null,"or in Java notations:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"A.then(B).then(A)")),(0,o.kt)("p",null,'When "B" is an instance of MCSequence() we have a self-balancing worker pool.\nWhen "A" is MPSequence(), we have many-to-many pub-sub system. Cool, eh?'),(0,o.kt)("p",null,"Single- sequences are faster but they are not thread-safe. They should be\npreferred for single-threaded consumer models."),(0,o.kt)("p",null,"Lets take a look at how threads interact with sequences. This is a typical\nexample of publisher:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'// loop until there is work to do\n// consumer thread may be able to rely on producer to\n// publish "special" message to indicate end of stream.\nwhile (true) {\n\n  // Non-blocking call. Method returns immediately either with zero-based\n  // ring queue index or negative long indicating one of following:\n  // -1 = queue is empty\n  // -2 = there was a contest for queue index and this thread has lost\n  long cursor = sequence.next();\n  if (cursor < 0) {\n    // negative cursor is an error\n    // thread has a choice of things to do:\n    // - busy spin\n    // - yield/park\n    // - work on something else\n    LockSupport.parkNanos(1);\n    continue;\n  }\n\n  // write to queue\n  try {\n    queue.get(cursor).value;\n  } finally {\n    // releasing cursor promptly is important\n    sequence.done(cursor);\n  }\n}\n\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Sequence.next()")," return values are:"),(0,o.kt)("p",null,"-1 Queue is unavailable. It is either full or empty, depending on whether it is\nproducer or consumer sequence"),(0,o.kt)("p",null,"-2 Temporary race condition. Sequence failed CAS and delegated decision to your\napplication."),(0,o.kt)("p",null,"Consumer sequence interaction is almost identical. The only difference would be\nconsumer reading queue item instead of writing it."),(0,o.kt)("p",null,"Performance of single-threaded sequences can benefit further from batching.\nBatching relies on receiving range of indices from sequence and calling done()\nat end of batch rather than for every queue item. This is what consumer code\nmight look like (producer code is the same):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"while (running) {\n  long cursor = sequence.next();\n\n  if (cursor < 0) {\n    LockSupport.parkNanos(1);\n    continue;\n  }\n\n  // get max index sequence can reach\n  long available = sequence.available();\n\n  // look thru queue elements without using sequence\n  while (cursor < available) {\n    queue.get(cursor++);\n  }\n\n  // calling done() only once per batch can yield significant performance benefit\n  sequence.done(available - 1);\n}\n")),(0,o.kt)("p",null,"Multi-threaded sequence do not support batches."),(0,o.kt)("h2",{id:"performance"},"Performance"),(0,o.kt)("p",null,"I used Shipilev's project that already had Disruptor benchmark and I added\nQuestDB implementation of the same pipeline."),(0,o.kt)("p",null,"Benchmark source on ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/bluestreak01/disrupting-fjp"},"GitHub")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"2 CPU MBP 2015")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"Benchmark          (slicesK)  (threads)  (workMult)  Mode  Cnt    Score    Error  Units\nDisruptor.run            500          2          10    ss   50   10.043 \xb1  0.158  ms/op\nDisruptor.run           1000          2          10    ss   50   19.944 \xb1  0.285  ms/op\nDisruptor.run           5000          2          10    ss   50  133.082 \xb1  6.032  ms/op\nQuestdbFanOut.run        500          2          10    ss   50   13.027 \xb1  0.180  ms/op\nQuestdbFanOut.run       1000          2          10    ss   50   26.329 \xb1  0.327  ms/op\nQuestdbFanOut.run       5000          2          10    ss   50  141.686 \xb1  4.129  ms/op\nQuestdbWorker.run        500          2          10    ss   50   29.470 \xb1  0.976  ms/op\nQuestdbWorker.run       1000          2          10    ss   50   62.205 \xb1  3.278  ms/op\nQuestdbWorker.run       5000          2          10    ss   50  321.697 \xb1 12.031  ms/op\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"4 CPU x5960 @ 4.2Ghz")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"Benchmark          (slicesK)  (threads)  (workMult)  Mode  Cnt    Score    Error  Units\nDisruptor.run            500          4          10    ss   50    6.892 \xb1  0.654  ms/op\nDisruptor.run           1000          4          10    ss   50   10.143 \xb1  0.623  ms/op\nDisruptor.run           5000          4          10    ss   50   54.084 \xb1  4.164  ms/op\nQuestdbFanOut.run        500          4          10    ss   50    6.364 \xb1  0.197  ms/op\nQuestdbFanOut.run       1000          4          10    ss   50   11.454 \xb1  0.754  ms/op\nQuestdbFanOut.run       5000          4          10    ss   50   50.928 \xb1  3.264  ms/op\nQuestdbWorker.run        500          4          10    ss   50   14.240 \xb1  1.341  ms/op\nQuestdbWorker.run       1000          4          10    ss   50   27.246 \xb1  2.777  ms/op\nQuestdbWorker.run       5000          4          10    ss   50  142.207 \xb1 15.157  ms/op\n")),(0,o.kt)("p",null,"Disruptor and QuestDB perform essentially the same."),(0,o.kt)("h2",{id:"how-to-get-it"},"How to get it"),(0,o.kt)("p",null,"Our messaging system is on Maven central as a part of QuestDB. Don't worry about\npackage size though, QuestDB jar is around 3.6MB and has no dependencies. Jump\nto the ",(0,o.kt)("a",{parentName:"p",href:"https:///releases"},"GitHub release page")," for version reference."))}d.isMDXComponent=!0},86010:function(e,n,t){function r(e){var n,t,a="";if("string"==typeof e||"number"==typeof e)a+=e;else if("object"==typeof e)if(Array.isArray(e))for(n=0;n<e.length;n++)e[n]&&(t=r(e[n]))&&(a&&(a+=" "),a+=t);else for(n in e)e[n]&&(a&&(a+=" "),a+=n);return a}function a(){for(var e,n,t=0,a="";t<arguments.length;)(e=arguments[t++])&&(n=r(e))&&(a&&(a+=" "),a+=n);return a}t.d(n,{Z:function(){return a}})}}]);
"use strict";(self.webpackChunkquestdb_io=self.webpackChunkquestdb_io||[]).push([[6398],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=u(n),h=a,g=p["".concat(l,".").concat(h)]||p[h]||d[h]||o;return n?r.createElement(g,s(s({ref:t},c),{},{components:n})):r.createElement(g,s({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var u=2;u<o;u++)s[u]=n[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},95466:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},metadata:function(){return u},toc:function(){return c},default:function(){return p}});var r=n(83117),a=n(80102),o=(n(67294),n(3905)),s=n(72525),i=["components"],l={title:"Speeding up InfluxDB line protocol",author:"Tancrede Collard",author_title:"QuestDB Team",author_url:"https://github.com/TheTanc",author_image_url:"https://avatars.githubusercontent.com/TheTanc",description:"Comparison between InfluxDB and QuestDB regarding the performance of the line protocol when ingesting data.",keywords:["timeseries","influxdb","questdb","database"],tags:["engineering","performance","influxdb","telegraf"],image:"/img/blog/shared/og-influxdb.png"},u={permalink:"/blog/2019/12/19/lineprot",source:"@site/blog/2019-12-19-lineprot.md",title:"Speeding up InfluxDB line protocol",description:"Comparison between InfluxDB and QuestDB regarding the performance of the line protocol when ingesting data.",date:"2019-12-19T00:00:00.000Z",formattedDate:"December 19, 2019",tags:[{label:"engineering",permalink:"/blog/tags/engineering"},{label:"performance",permalink:"/blog/tags/performance"},{label:"influxdb",permalink:"/blog/tags/influxdb"},{label:"telegraf",permalink:"/blog/tags/telegraf"}],readingTime:5.08,truncated:!0,prevItem:{title:"Aggregating billions of rows per second with SIMD",permalink:"/blog/2020/04/02/using-simd-to-aggregate-billions-of-rows-per-second"}},c=[{value:"Why does QuestDB now support InfluxDB line protocol?",id:"why-does-questdb-now-support-influxdb-line-protocol",children:[]},{value:"Data loss over UDP",id:"data-loss-over-udp",children:[]},{value:"It comes down to ingestion speed",id:"it-comes-down-to-ingestion-speed",children:[]},{value:"Why is the sender&#39;s rate slower for InfluxDB compared to QuestDB?",id:"why-is-the-senders-rate-slower-for-influxdb-compared-to-questdb",children:[]},{value:"QuestDB&#39;s secret sauce",id:"questdbs-secret-sauce",children:[]},{value:"Get started",id:"get-started",children:[]}],d={toc:c};function p(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"InfluxDB is the current market leader in time series. This post examines their\ningestion format called ",(0,o.kt)("strong",{parentName:"p"},"InfluxDB line protocol (ILP)")," and compares data\ningestion performance between QuestDB and InfluxDB. We'll look at data loss over\nUDP and some of the reasons why QuestDB is more efficient at ingesting records\nin ILP."),(0,o.kt)("p",null,"It would not be an overstatement to say that InfluxDB uses a lot of CPU. We set\nourselves to build a receiver for ILP, which stores data faster than InfluxDB\nwhile being hardware efficient."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Update 09-07-2021:")," Our community contributor Yitaek Hwang has put together\nan article which\n",(0,o.kt)("a",{parentName:"p",href:"/blog/2021/07/05/comparing-questdb-timescaledb-influxdb/"},"compares InfluxDB, TimescaleDB and QuestDB"),"\nwhich may be useful for an up-to-date feature overview."),(0,o.kt)("h2",{id:"why-does-questdb-now-support-influxdb-line-protocol"},"Why does QuestDB now support InfluxDB line protocol?"),(0,o.kt)("p",null,"Starting with QuestDB 4.0.4, users can ingest data through ILP and use standard\nSQL to query InfluxDB data alongside other tables in a relational database while\nkeeping the flexibility of ILP."),(0,o.kt)(s.Z,{alt:"A diagram showing QuestDB ingesting schema-agnostic InfluxDB line protocol and relational data",height:591,src:"/img/blog/2021-07-05/questdb-influxdb-postgres-join.png",width:770,mdxType:"Screenshot"}),(0,o.kt)("h2",{id:"data-loss-over-udp"},"Data loss over UDP"),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"The UDP receiver is deprecated since QuestDB version 6.5.2.\nWe recommend the ",(0,o.kt)("a",{parentName:"p",href:"/docs/reference/api/ilp/tcp-receiver/"},"TCP receiver")," instead."))),(0,o.kt)("p",null,"We have conducted our testing over UDP, thus expecting some level of data loss.\nHowever, we did not anticipate that InfluxDB would lose so much. We have built a\nsender, which caches outgoing messages in a small buffer before sending them to\na UDP socket. It sends data as fast as possible to overpower the consumers and\nintroduce packet loss eventually. To test for different use cases, we have\nthrottled the sender by varying its buffer size. A smaller buffer results in\nmore frequent network calls and results in lower sending rates."),(0,o.kt)("p",null,"The benchmark publishes 50 million messages at various speeds. We then measure\nthe number of entries in each DB after the fact to calculate the implied capture\nrate."),(0,o.kt)("p",null,"We use the Dell XPS 15 7590, 64Gb RAM, 6-core i9 CPU, 1TB SSD drive. In this\nexperiment, both the sender and QuestDB/InfluxDB instances run on the same\nmachine. UDP publishing is over loopback. OS is Fedora 31, OS UDP buffer size\n(",(0,o.kt)("inlineCode",{parentName:"p"},"net.core.rmem_max"),") is ",(0,o.kt)("inlineCode",{parentName:"p"},"104_857_600"),"."),(0,o.kt)("h2",{id:"it-comes-down-to-ingestion-speed"},"It comes down to ingestion speed"),(0,o.kt)("p",null,"Database performance is the bottleneck that results in packet loss. Messages are\ndenied entry, and the loss rate is a direct function of the underlying database\nspeed. By sending 50M messages at different speeds, we get the following\noutcome."),(0,o.kt)(s.Z,{alt:"Table showing a comparison of the capture rate between QuestDB and InfluxDB",height:591,src:"/img/blog/2019-12-19/captureRate.png",width:770,title:"Capture rate as a function of sender speed",mdxType:"Screenshot"}),(0,o.kt)("p",null,"InfluxDB's capture rate rapidly drops below 50%, eventually converging toward\nsingle-digit rates."),(0,o.kt)(s.Z,{alt:"Chart showing a comparison of the capture rate between QuestDB and InfluxDB",height:591,src:"/img/blog/2019-12-19/captureRateChart.png",width:770,title:"Capture rate as a function of sender speed",mdxType:"Screenshot"}),(0,o.kt)("p",null,"QuestDB's ingestion speed results are obtained through ILP. Our ingestion speed\nis considerably higher while using our native input formats instead."),(0,o.kt)(s.Z,{alt:"Chart showing a comparison of the capture rate between QuestDB and InfluxDB",height:591,src:"/img/blog/2019-12-19/impliedSpeed.png",width:770,title:"Implied ingestion speed in function of Sender speed",mdxType:"Screenshot"}),(0,o.kt)("h2",{id:"why-is-the-senders-rate-slower-for-influxdb-compared-to-questdb"},"Why is the sender's rate slower for InfluxDB compared to QuestDB?"),(0,o.kt)("p",null,"In this test, we run the sender and the DB on the same machine, and it turns out\nthat InfluxDB slows down our UDP sender by cannibalizing the CPU. Here is what\nhappens to your CPUs while using InfluxDB:"),(0,o.kt)(s.Z,{alt:"Bar chart showing the CPU usage of InfluxDB, idle versus under load",height:591,src:"/img/blog/2019-12-19/impliedSpeed.png",width:770,title:"InfluxDB\u2019s CPU usage when serving requests",mdxType:"Screenshot"}),(0,o.kt)("p",null,"When in use, InfluxDB saturates all of the CPU. As a consequence, it slows down\nany other program running on the same machine."),(0,o.kt)("h2",{id:"questdbs-secret-sauce"},"QuestDB's secret sauce"),(0,o.kt)("p",null,"We maximize the utilization of each CPU, from which we extract as much\nperformance as possible. For the example below, we compared InfluxDB's ingestion\nspeed using 12 cores to QuestDB using one CPU core only. Despite utilizing one\ncore instead of 12, QuestDB still outperforms InfluxDB significantly."),(0,o.kt)("p",null,"If spare CPU capacity arises, QuestDB will execute multiple data ingestion in\nparallel, leveraging multiple CPUs at the same time, but with one key\ndifference; QuestDB uses work-stealing algorithms to ensure every last bit of\nCPU capacity is used while never being idle. Let us illustrate why this is the\ncase."),(0,o.kt)("p",null,"Modern network cards have much superior throughput than the single receiver.\nBeing limited to one receiver by design, InfluxDB considerably under-utilizes\nthe network card, which is the limiting factor in the pipeline."),(0,o.kt)(s.Z,{alt:"Chart showing InfluxDB's queuing mechanism",height:591,src:"/img/blog/2019-12-19/queueInflux.png",width:770,title:"All CPU cores open one single receiver that under-utilizes the network card",mdxType:"Screenshot"}),(0,o.kt)("p",null,"Conversely, QuestDB can open parallel receivers (requiring one core each), fully\nutilizing the network card capabilities. The following illustration assumes that\nthere would be spare CPU capacity in other cores to be filled. In such a\nscenario we would get QuestDB utilizing 12 cores, with each one of those being\nconsiderably faster than InfluxDB's combined 12 cores!"),(0,o.kt)(s.Z,{alt:"Chart showing QuestDB's queuing mechanism",height:591,src:"/img/blog/2019-12-19/queueQuest.png",width:770,title:"Each CPU core opens an independent receiver working in parallel that fully leverages the network card",mdxType:"Screenshot"}),(0,o.kt)("p",null,"Besides ingestion, InfluxDB also saturates the CPU on queries. The current user\ncannibalizes the whole CPU, while other users have to wait for their turn."),(0,o.kt)(s.Z,{alt:"How the CPU is shared under InfluxDB's load",height:591,src:"/img/blog/2019-12-19/userInflux.png",width:770,title:"Users monopolize all CPU cores one after the other",mdxType:"Screenshot"}),(0,o.kt)("p",null,"By contrast, QuestDB uses each core separately, allowing multiple users to query\nor write concurrently without delay. The performance gap between QuestDB and\nInfluxDB grows significantly as the number of simultaneous users increases."),(0,o.kt)(s.Z,{alt:"How the CPU is shared under QuestDB's load",height:591,src:"/img/blog/2019-12-19/userQuest.png",width:770,title:"Users share CPU cores and are served concurrently, with full CPU core utilization.",mdxType:"Screenshot"}),(0,o.kt)("h2",{id:"get-started"},"Get started"),(0,o.kt)("p",null,"QuestDB supports ILP over UDP multicast and unicast sockets. TCP support will\nfollow shortly. You don't need to change anything in your application. For\nTelegraf, you can configure the UDP sender for QuestDB's address and port."),(0,o.kt)("p",null,"Follow this link to ",(0,o.kt)("a",{parentName:"p",href:"/get-questdb"},"download QuestDB"),". You can also use our\n",(0,o.kt)("a",{parentName:"p",href:"https:///blob/master/benchmarks/src/main/java/org/questdb/LineUDPSenderMain.java"},"sender"),"\nagainst QuestDB and InfluxDB to reproduce the experiment."))}p.isMDXComponent=!0},86010:function(e,t,n){function r(e){var t,n,a="";if("string"==typeof e||"number"==typeof e)a+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=r(e[t]))&&(a&&(a+=" "),a+=n);else for(t in e)e[t]&&(a&&(a+=" "),a+=t);return a}function a(){for(var e,t,n=0,a="";n<arguments.length;)(e=arguments[n++])&&(t=r(e))&&(a&&(a+=" "),a+=t);return a}n.d(t,{Z:function(){return a}})}}]);